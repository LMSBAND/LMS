desc:LMS - CHRIS' BEDROOM — Amp Sim + Room
//tags: amp guitar distortion reverb room
//author: LMS + Claude

import lms_core.jsfx-inc
options:gmem=DrumBanger

slider1:0<0,100,0.1>-Input Gain (%)
slider2:0<0,3,1{Clean,Crunch,Lead,Fuzz}>-Amp Mode
slider3:50<0,100,0.1>-Bass
slider4:50<0,100,0.1>-Mid
slider5:50<0,100,0.1>-Treble
slider6:30<0,100,0.1>-Presence
slider7:75<0,100,0.1>-Master Vol
slider8:0<0,100,0.1>-Room Size (%)
slider9:50<0,100,0.1>-Room Decay (%)
slider10:60<0,100,0.1>-Room Damp (%)
slider11:50<0,100,0.1>-Room Mix (%)
slider12:0<0,2,1{Bedroom,Garage,Basement}>-Room Type
slider13:100<0,100,0.1>-Dry/Wet (%)

@init

  // ============================================================
  // DSP INSTANCES
  // ============================================================
  // Amp tone stack — 3 biquad bands
  bass_eq.lms_bq_init();
  mid_eq.lms_bq_init();
  treb_eq.lms_bq_init();
  pres_eq.lms_bq_init();

  // Cabinet simulation — 2 biquads to shape the speaker response
  cab_lo.lms_bq_init();
  cab_hi.lms_bq_init();

  // DC blocker — essential after asymmetric amp clipping
  dc.lms_dc_init();

  // Tone filter on room output
  room_tone.lms_tone_init();

  // ============================================================
  // ROOM — Schroeder reverb (comb + allpass)
  // 6 comb filters + 4 allpass diffusors, stereo
  // Delays tuned for small room sizes
  // ============================================================
  buf_pos = 0;

  // Comb filter buffers (stereo)
  cb_l0 = buf_pos; buf_pos += 2048;
  cb_l1 = buf_pos; buf_pos += 2048;
  cb_l2 = buf_pos; buf_pos += 2048;
  cb_l3 = buf_pos; buf_pos += 2048;
  cb_l4 = buf_pos; buf_pos += 2048;
  cb_l5 = buf_pos; buf_pos += 2048;

  cb_r0 = buf_pos; buf_pos += 2048;
  cb_r1 = buf_pos; buf_pos += 2048;
  cb_r2 = buf_pos; buf_pos += 2048;
  cb_r3 = buf_pos; buf_pos += 2048;
  cb_r4 = buf_pos; buf_pos += 2048;
  cb_r5 = buf_pos; buf_pos += 2048;

  // Allpass buffers (stereo)
  ap_l0 = buf_pos; buf_pos += 1024;
  ap_l1 = buf_pos; buf_pos += 1024;
  ap_l2 = buf_pos; buf_pos += 1024;
  ap_l3 = buf_pos; buf_pos += 1024;

  ap_r0 = buf_pos; buf_pos += 1024;
  ap_r1 = buf_pos; buf_pos += 1024;
  ap_r2 = buf_pos; buf_pos += 1024;
  ap_r3 = buf_pos; buf_pos += 1024;

  // Comb positions
  cp_l0=0; cp_l1=0; cp_l2=0; cp_l3=0; cp_l4=0; cp_l5=0;
  cp_r0=0; cp_r1=0; cp_r2=0; cp_r3=0; cp_r4=0; cp_r5=0;

  // Allpass positions
  ap_pos_l0=0; ap_pos_l1=0; ap_pos_l2=0; ap_pos_l3=0;
  ap_pos_r0=0; ap_pos_r1=0; ap_pos_r2=0; ap_pos_r3=0;

  // Comb lowpass states (damping)
  clp_l0=0; clp_l1=0; clp_l2=0; clp_l3=0; clp_l4=0; clp_l5=0;
  clp_r0=0; clp_r1=0; clp_r2=0; clp_r3=0; clp_r4=0; clp_r5=0;

  // Room delay bases — mutually prime, short for a bedroom feel
  // Bedroom: tight and boxy. Garage: bigger. Basement: long and muddy.
  room_base0 = 557;  room_base1 = 617;  room_base2 = 691;
  room_base3 = 773;  room_base4 = 839;  room_base5 = 911;

  // Allpass bases
  ap_base0 = 113; ap_base1 = 151; ap_base2 = 167; ap_base3 = 211;

  notice_show = 0;

  // ============================================================
  // BROADCAST SYSTEM — Instance Registry
  // ============================================================
  BC_BASE = 100000;
  BC_MY_TYPE = 9;           // Chris' Bedroom
  BC_SLOT_SIZE = 512;
  BC_MAX_INST = 32;
  BC_PARAM_COUNT = 13;
  BC_MY_REGION = BC_BASE + BC_MY_TYPE * 16384;
  BC_STALE_TIMEOUT = 2;

  bc_my_id == 0 ? bc_my_id = floor(rand() * 1073741824) + 1;
  bc_my_slot = -1;
  bc_follow_slot = -1;
  bc_steal_pending = 0;
  bc_steal_target = 0;
  bc_panel_expanded = 0;
  bc_page = 0;
  bc_steal_mode = 0;
  bc_instance_count = 0;

  BC_STALE_HB = 600000;
  BC_STALE_CT = 600032;
  i = 0;
  loop(BC_MAX_INST,
    BC_STALE_HB[i] = -1;
    BC_STALE_CT[i] = 0;
    i += 1;
  );

  bc_i = 0;
  loop(BC_MAX_INST,
    bc_my_slot < 0 ? (
      sb = BC_MY_REGION + bc_i * BC_SLOT_SIZE;
      sid = gmem[sb + 1];
      (sid == 0 || sid == bc_my_id) ? bc_my_slot = bc_i;
    );
    bc_i += 1;
  );

  bc_my_slot >= 0 ? (
    sb = BC_MY_REGION + bc_my_slot * BC_SLOT_SIZE;
    gmem[sb + 0] = 0;
    gmem[sb + 1] = bc_my_id;
    gmem[sb + 2] = BC_MY_TYPE;
    gmem[sb + 3] = 0;
    gmem[sb + 4] = BC_PARAM_COUNT;
  );

@slider
  in_gain   = slider1 / 100;
  amp_mode  = slider2;
  bass_amt  = (slider3 - 50) / 50;   // -1 to +1
  mid_amt   = (slider4 - 50) / 50;
  treb_amt  = (slider5 - 50) / 50;
  pres_amt  = slider6 / 100;
  master    = slider7 / 100;
  room_size = slider8 / 100;
  room_dec  = slider9 / 100;
  room_damp = slider10 / 100;
  room_mix  = slider11 / 100;
  room_type = slider12;
  dry_wet   = slider13 / 100;

  // Tone stack — amp-style passive tonestack approximation
  bass_eq.lms_bq_set_loshelf(250, bass_amt * 12, 0.707);
  mid_eq.lms_bq_set_peak(800, mid_amt * 8, 1.2);
  treb_eq.lms_bq_set_hishelf(3500, treb_amt * 10, 0.707);
  pres_eq.lms_bq_set_hishelf(6000, pres_amt * 8, 1.5);

  // Cabinet sim — cuts below 100Hz and rolls off above 5kHz (speaker cone)
  cab_lo.lms_bq_set_hp(100, 0.6);
  cab_hi.lms_bq_set_lp(5500, 0.7);

  // Room damping tone
  room_tone.lms_tone_set(400 + (1 - room_damp) * 4000);

@block
  in_gain   = slider1 / 100;
  amp_mode  = slider2;
  bass_amt  = (slider3 - 50) / 50;
  mid_amt   = (slider4 - 50) / 50;
  treb_amt  = (slider5 - 50) / 50;
  pres_amt  = slider6 / 100;
  master    = slider7 / 100;
  room_size = slider8 / 100;
  room_dec  = slider9 / 100;
  room_damp = slider10 / 100;
  room_mix  = slider11 / 100;
  room_type = slider12;
  dry_wet   = slider13 / 100;

  bass_eq.lms_bq_set_loshelf(250, bass_amt * 12, 0.707);
  mid_eq.lms_bq_set_peak(800, mid_amt * 8, 1.2);
  treb_eq.lms_bq_set_hishelf(3500, treb_amt * 10, 0.707);
  pres_eq.lms_bq_set_hishelf(6000, pres_amt * 8, 1.5);
  cab_lo.lms_bq_set_hp(100, 0.6);
  cab_hi.lms_bq_set_lp(5500, 0.7);
  room_tone.lms_tone_set(400 + (1 - room_damp) * 4000);

  // Room type: shift comb delays based on room character
  // Bedroom: tight (base * 0.4), Garage: medium (base * 0.8), Basement: long + muddy (base * 1.3)
  room_type == 0 ? room_scale = 0.4;
  room_type == 1 ? room_scale = 0.8;
  room_type == 2 ? room_scale = 1.3;

  // Comb delay lengths: base * room_scale * size
  size_scale = 0.2 + room_size * 0.8;
  cb_len0 = max(4, floor(room_base0 * room_scale * size_scale));
  cb_len1 = max(4, floor(room_base1 * room_scale * size_scale));
  cb_len2 = max(4, floor(room_base2 * room_scale * size_scale));
  cb_len3 = max(4, floor(room_base3 * room_scale * size_scale));
  cb_len4 = max(4, floor(room_base4 * room_scale * size_scale));
  cb_len5 = max(4, floor(room_base5 * room_scale * size_scale));

  ap_len0 = max(4, floor(ap_base0 * room_scale));
  ap_len1 = max(4, floor(ap_base1 * room_scale));
  ap_len2 = max(4, floor(ap_base2 * room_scale));
  ap_len3 = max(4, floor(ap_base3 * room_scale));

  // Comb feedback = decay + room type boost
  room_type == 2 ? decay_boost = 0.12 : room_type == 1 ? decay_boost = 0.06 : decay_boost = 0.0;
  comb_fb = min(0.95, room_dec * 0.85 + decay_boost);

  // Damping coefficient for comb lowpass
  damp_coeff = 1 - room_damp * 0.8;

  // Allpass diffusion coefficient
  ap_coeff = 0.6;

  // ============================================================
  // BROADCAST
  // ============================================================
  bc_my_slot >= 0 ? (
    sb = BC_MY_REGION + bc_my_slot * BC_SLOT_SIZE;
    gmem[sb + 1] != bc_my_id ? (
      bc_my_id = floor(rand() * 1073741824) + 1;
      bc_my_slot = -1;
      bc_i = 0;
      loop(BC_MAX_INST,
        bc_my_slot < 0 ? (
          tsb = BC_MY_REGION + bc_i * BC_SLOT_SIZE;
          (gmem[tsb + 1] == 0) ? bc_my_slot = bc_i;
        );
        bc_i += 1;
      );
      bc_my_slot >= 0 ? (
        sb = BC_MY_REGION + bc_my_slot * BC_SLOT_SIZE;
        gmem[sb + 0] = 0;
        gmem[sb + 1] = bc_my_id;
        gmem[sb + 2] = BC_MY_TYPE;
        gmem[sb + 3] = bc_following;
        gmem[sb + 4] = BC_PARAM_COUNT;
      );
    );
  );

  bc_my_slot >= 0 && bc_following > 0 ? (
    bc_found_leader = 0;
    bc_scan = 0;
    loop(BC_MAX_INST,
      bc_scan != bc_my_slot ? (
        lsb = BC_MY_REGION + bc_scan * BC_SLOT_SIZE;
        gmem[lsb + 1] == bc_following ? (
          bc_found_leader = 1;
          bc_follow_slot = bc_scan;
          lbase = lsb + 8;
          slider1  = gmem[lbase + 0];
          slider2  = gmem[lbase + 1];
          slider3  = gmem[lbase + 2];
          slider4  = gmem[lbase + 3];
          slider5  = gmem[lbase + 4];
          slider6  = gmem[lbase + 5];
          slider7  = gmem[lbase + 6];
          slider8  = gmem[lbase + 7];
          slider9  = gmem[lbase + 8];
          slider10 = gmem[lbase + 9];
          slider11 = gmem[lbase + 10];
          slider12 = gmem[lbase + 11];
          slider13 = gmem[lbase + 12];
          bc_scan = BC_MAX_INST;
        );
      );
      bc_scan += 1;
    );
    !bc_found_leader ? (
      bc_following = 0;
      bc_follow_slot = -1;
    );
  );

  bc_my_slot >= 0 && bc_steal_pending ? (
    bc_scan = 0;
    loop(BC_MAX_INST,
      lsb = BC_MY_REGION + bc_scan * BC_SLOT_SIZE;
      gmem[lsb + 1] == bc_steal_target ? (
        lbase = lsb + 8;
        slider1  = gmem[lbase + 0];
        slider2  = gmem[lbase + 1];
        slider3  = gmem[lbase + 2];
        slider4  = gmem[lbase + 3];
        slider5  = gmem[lbase + 4];
        slider6  = gmem[lbase + 5];
        slider7  = gmem[lbase + 6];
        slider8  = gmem[lbase + 7];
        slider9  = gmem[lbase + 8];
        slider10 = gmem[lbase + 9];
        slider11 = gmem[lbase + 10];
        slider12 = gmem[lbase + 11];
        slider13 = gmem[lbase + 12];
        bc_scan = BC_MAX_INST;
      );
      bc_scan += 1;
    );
    bc_steal_pending = 0;
    bc_steal_target = 0;
    bc_steal_mode = 0;
  );

  bc_my_slot >= 0 ? (
    sb = BC_MY_REGION + bc_my_slot * BC_SLOT_SIZE;
    gmem[sb + 0] += 1;
    gmem[sb + 3] = bc_following;
    pbase = sb + 8;
    gmem[pbase + 0]  = slider1;
    gmem[pbase + 1]  = slider2;
    gmem[pbase + 2]  = slider3;
    gmem[pbase + 3]  = slider4;
    gmem[pbase + 4]  = slider5;
    gmem[pbase + 5]  = slider6;
    gmem[pbase + 6]  = slider7;
    gmem[pbase + 7]  = slider8;
    gmem[pbase + 8]  = slider9;
    gmem[pbase + 9]  = slider10;
    gmem[pbase + 10] = slider11;
    gmem[pbase + 11] = slider12;
    gmem[pbase + 12] = slider13;
  );

  bc_instance_count = 0;
  bc_scan = 0;
  loop(BC_MAX_INST,
    tsb = BC_MY_REGION + bc_scan * BC_SLOT_SIZE;
    tsid = gmem[tsb + 1];
    tsid > 0 ? (
      bc_scan == bc_my_slot ? (
        bc_instance_count += 1;
      ) : (
        tshb = gmem[tsb + 0];
        tshb == BC_STALE_HB[bc_scan] ? (
          BC_STALE_CT[bc_scan] += samplesblock / srate;
          BC_STALE_CT[bc_scan] > BC_STALE_TIMEOUT ? (
            gmem[tsb + 1] = 0;
            BC_STALE_CT[bc_scan] = 0;
          );
        ) : (
          BC_STALE_HB[bc_scan] = tshb;
          BC_STALE_CT[bc_scan] = 0;
          bc_instance_count += 1;
        );
      );
    );
    bc_scan += 1;
  );

@sample
  dry_l = spl0;
  dry_r = spl1;

  l = spl0;
  r = spl1;

  // ============================================================
  // AMP INPUT STAGE
  // ============================================================
  // Drive into preamp — mono summed then re-spread for guitar realism
  mono = (l + r) * 0.5;
  drive_amt = in_gain * 2;

  amp_mode == 0 ? (
    // Clean — gentle warm tube, barely touches
    amp_l = lms_sat_warm(mono * (1 + drive_amt * 0.5), drive_amt * 0.3, 0.0);
    amp_r = amp_l;
  ) : amp_mode == 1 ? (
    // Crunch — asymmetric tube, some bite
    amp_l = lms_sat_warm(mono * (1 + drive_amt), drive_amt * 0.7, 0.05);
    amp_r = amp_l;
  ) : amp_mode == 2 ? (
    // Lead — hot amp, compressed and saturated
    amp_l = lms_sat_hot(mono * (1 + drive_amt * 1.5), drive_amt * 0.9, 0.08);
    amp_r = amp_l;
  ) : (
    // Fuzz — gated fuzz, full on chaos
    amp_l = lms_sat_fuzz(mono * (1 + drive_amt * 2), drive_amt, 0.05);
    amp_r = amp_l;
  );

  // Add odd harmonics on crunch/lead for that amp breakup texture
  amp_mode >= 1 ? (
    harm_amt = amp_mode == 1 ? 0.15 : amp_mode == 2 ? 0.25 : 0.1;
    amp_l = lms_sat_harmonics(amp_l, 0.0, harm_amt);
    amp_r = lms_sat_harmonics(amp_r, 0.0, harm_amt);
  );

  // DC block after asymmetric clipping
  amp_l = dc.lms_dc_proc_l(amp_l);
  amp_r = dc.lms_dc_proc_r(amp_r);

  // ============================================================
  // TONE STACK
  // ============================================================
  amp_l = bass_eq.lms_bq_proc_l(amp_l);
  amp_r = bass_eq.lms_bq_proc_r(amp_r);

  amp_l = mid_eq.lms_bq_proc_l(amp_l);
  amp_r = mid_eq.lms_bq_proc_r(amp_r);

  amp_l = treb_eq.lms_bq_proc_l(amp_l);
  amp_r = treb_eq.lms_bq_proc_r(amp_r);

  amp_l = pres_eq.lms_bq_proc_l(amp_l);
  amp_r = pres_eq.lms_bq_proc_r(amp_r);

  // ============================================================
  // CABINET SIM
  // Highpass to remove sub-bass boom (no 15" woofers in a guitar cab)
  // Lowpass to remove fizz (speaker cone can't move that fast)
  // ============================================================
  amp_l = cab_lo.lms_bq_proc_l(amp_l);
  amp_r = cab_lo.lms_bq_proc_r(amp_r);
  amp_l = cab_hi.lms_bq_proc_l(amp_l);
  amp_r = cab_hi.lms_bq_proc_r(amp_r);

  // Master volume
  amp_l *= master;
  amp_r *= master;

  // ============================================================
  // ROOM REVERB — Schroeder (6 comb + 4 allpass)
  // Spread L/R slightly for stereo width in the room
  // ============================================================
  room_in_l = amp_l * 0.5;
  room_in_r = amp_r * 0.5;

  // --- COMB FILTERS LEFT ---
  // Each comb: output = delayed + input, new = input + delayed * fb, with lowpass damping
  cb_out_l = 0;

  delayed = cb_l0[cp_l0];
  clp_l0 = delayed * damp_coeff + clp_l0 * (1 - damp_coeff);
  cb_l0[cp_l0] = room_in_l + clp_l0 * comb_fb;
  cb_out_l += delayed;
  cp_l0 += 1; cp_l0 >= cb_len0 ? cp_l0 = 0;

  delayed = cb_l1[cp_l1];
  clp_l1 = delayed * damp_coeff + clp_l1 * (1 - damp_coeff);
  cb_l1[cp_l1] = room_in_l + clp_l1 * comb_fb;
  cb_out_l += delayed;
  cp_l1 += 1; cp_l1 >= cb_len1 ? cp_l1 = 0;

  delayed = cb_l2[cp_l2];
  clp_l2 = delayed * damp_coeff + clp_l2 * (1 - damp_coeff);
  cb_l2[cp_l2] = room_in_l + clp_l2 * comb_fb;
  cb_out_l += delayed;
  cp_l2 += 1; cp_l2 >= cb_len2 ? cp_l2 = 0;

  delayed = cb_l3[cp_l3];
  clp_l3 = delayed * damp_coeff + clp_l3 * (1 - damp_coeff);
  cb_l3[cp_l3] = room_in_l + clp_l3 * comb_fb;
  cb_out_l += delayed;
  cp_l3 += 1; cp_l3 >= cb_len3 ? cp_l3 = 0;

  delayed = cb_l4[cp_l4];
  clp_l4 = delayed * damp_coeff + clp_l4 * (1 - damp_coeff);
  cb_l4[cp_l4] = room_in_l + clp_l4 * comb_fb;
  cb_out_l += delayed;
  cp_l4 += 1; cp_l4 >= cb_len4 ? cp_l4 = 0;

  delayed = cb_l5[cp_l5];
  clp_l5 = delayed * damp_coeff + clp_l5 * (1 - damp_coeff);
  cb_l5[cp_l5] = room_in_l + clp_l5 * comb_fb;
  cb_out_l += delayed;
  cp_l5 += 1; cp_l5 >= cb_len5 ? cp_l5 = 0;

  // --- COMB FILTERS RIGHT ---
  cb_out_r = 0;

  delayed = cb_r0[cp_r0];
  clp_r0 = delayed * damp_coeff + clp_r0 * (1 - damp_coeff);
  cb_r0[cp_r0] = room_in_r + clp_r0 * comb_fb;
  cb_out_r += delayed;
  cp_r0 += 1; cp_r0 >= cb_len0 ? cp_r0 = 0;

  delayed = cb_r1[cp_r1];
  clp_r1 = delayed * damp_coeff + clp_r1 * (1 - damp_coeff);
  cb_r1[cp_r1] = room_in_r + clp_r1 * comb_fb;
  cb_out_r += delayed;
  cp_r1 += 1; cp_r1 >= cb_len1 ? cp_r1 = 0;

  delayed = cb_r2[cp_r2];
  clp_r2 = delayed * damp_coeff + clp_r2 * (1 - damp_coeff);
  cb_r2[cp_r2] = room_in_r + clp_r2 * comb_fb;
  cb_out_r += delayed;
  cp_r2 += 1; cp_r2 >= cb_len2 ? cp_r2 = 0;

  delayed = cb_r3[cp_r3];
  clp_r3 = delayed * damp_coeff + clp_r3 * (1 - damp_coeff);
  cb_r3[cp_r3] = room_in_r + clp_r3 * comb_fb;
  cb_out_r += delayed;
  cp_r3 += 1; cp_r3 >= cb_len3 ? cp_r3 = 0;

  delayed = cb_r4[cp_r4];
  clp_r4 = delayed * damp_coeff + clp_r4 * (1 - damp_coeff);
  cb_r4[cp_r4] = room_in_r + clp_r4 * comb_fb;
  cb_out_r += delayed;
  cp_r4 += 1; cp_r4 >= cb_len4 ? cp_r4 = 0;

  delayed = cb_r5[cp_r5];
  clp_r5 = delayed * damp_coeff + clp_r5 * (1 - damp_coeff);
  cb_r5[cp_r5] = room_in_r + clp_r5 * comb_fb;
  cb_out_r += delayed;
  cp_r5 += 1; cp_r5 >= cb_len5 ? cp_r5 = 0;

  // Scale comb sum
  cb_out_l *= 0.167;
  cb_out_r *= 0.167;

  // --- ALLPASS DIFFUSORS LEFT ---
  cb_out_l = lms_spring_ap(ap_l0, ap_pos_l0, ap_len0, cb_out_l, ap_coeff);
  ap_pos_l0 += 1; ap_pos_l0 >= ap_len0 ? ap_pos_l0 = 0;

  cb_out_l = lms_spring_ap(ap_l1, ap_pos_l1, ap_len1, cb_out_l, ap_coeff);
  ap_pos_l1 += 1; ap_pos_l1 >= ap_len1 ? ap_pos_l1 = 0;

  cb_out_l = lms_spring_ap(ap_l2, ap_pos_l2, ap_len2, cb_out_l, ap_coeff);
  ap_pos_l2 += 1; ap_pos_l2 >= ap_len2 ? ap_pos_l2 = 0;

  cb_out_l = lms_spring_ap(ap_l3, ap_pos_l3, ap_len3, cb_out_l, ap_coeff);
  ap_pos_l3 += 1; ap_pos_l3 >= ap_len3 ? ap_pos_l3 = 0;

  // --- ALLPASS DIFFUSORS RIGHT ---
  cb_out_r = lms_spring_ap(ap_r0, ap_pos_r0, ap_len0, cb_out_r, ap_coeff);
  ap_pos_r0 += 1; ap_pos_r0 >= ap_len0 ? ap_pos_r0 = 0;

  cb_out_r = lms_spring_ap(ap_r1, ap_pos_r1, ap_len1, cb_out_r, ap_coeff);
  ap_pos_r1 += 1; ap_pos_r1 >= ap_len1 ? ap_pos_r1 = 0;

  cb_out_r = lms_spring_ap(ap_r2, ap_pos_r2, ap_len2, cb_out_r, ap_coeff);
  ap_pos_r2 += 1; ap_pos_r2 >= ap_len2 ? ap_pos_r2 = 0;

  cb_out_r = lms_spring_ap(ap_r3, ap_pos_r3, ap_len3, cb_out_r, ap_coeff);
  ap_pos_r3 += 1; ap_pos_r3 >= ap_len3 ? ap_pos_r3 = 0;

  // Room damping tone on reverb tail
  room_l = room_tone.lms_tone_proc_l(cb_out_l);
  room_r = room_tone.lms_tone_proc_r(cb_out_r);

  // Mix amp + room
  wet_l = amp_l * (1 - room_mix) + room_l * room_mix;
  wet_r = amp_r * (1 - room_mix) + room_r * room_mix;

  // Final dry/wet
  spl0 = dry_l * (1 - dry_wet) + wet_l * dry_wet;
  spl1 = dry_r * (1 - dry_wet) + wet_r * dry_wet;

@gfx 580 400
// ============================================================================
//  COLOR CONSTANTS
// ============================================================================
COL_BG_R = 0.05; COL_BG_G = 0.05; COL_BG_B = 0.07;
COL_PANEL_R = 0.08; COL_PANEL_G = 0.08; COL_PANEL_B = 0.11;
COL_PANEL_HI_R = 0.12; COL_PANEL_HI_G = 0.12; COL_PANEL_HI_B = 0.16;
COL_BORDER_R = 0.20; COL_BORDER_G = 0.20; COL_BORDER_B = 0.25;
COL_TITLE_R = 0.95; COL_TITLE_G = 0.78; COL_TITLE_B = 0.35;
COL_SEC_R = 0.55; COL_SEC_G = 0.50; COL_SEC_B = 0.40;
COL_TEXT_R = 0.78; COL_TEXT_G = 0.78; COL_TEXT_B = 0.82;
COL_DIM_R = 0.38; COL_DIM_G = 0.38; COL_DIM_B = 0.42;
COL_ACCENT_R = 0.95; COL_ACCENT_G = 0.45; COL_ACCENT_B = 0.15;
COL_GREEN_R = 0.25; COL_GREEN_G = 0.80; COL_GREEN_B = 0.50;
COL_CYAN_R = 0.20; COL_CYAN_G = 0.60; COL_CYAN_B = 0.85;
COL_BAR_BG_R = 0.12; COL_BAR_BG_G = 0.12; COL_BAR_BG_B = 0.16;

// ============================================================================
//  BACKGROUND
// ============================================================================
gfx_r = COL_BG_R; gfx_g = COL_BG_G; gfx_b = COL_BG_B;
gfx_rect(0, 0, gfx_w, gfx_h);
gfx_r = 0.03; gfx_g = 0.03; gfx_b = 0.05;
gfx_rect(0, 0, gfx_w, 44);
gfx_r = COL_TITLE_R * 0.6; gfx_g = COL_TITLE_G * 0.6; gfx_b = COL_TITLE_B * 0.6;
gfx_rect(0, 44, gfx_w, 2);

// ============================================================================
//  HELPERS
// ============================================================================
function draw_bar(bx, by, bw, bh, val, vmin, vmax, label, show_val) (
  gfx_r = COL_BAR_BG_R; gfx_g = COL_BAR_BG_G; gfx_b = COL_BAR_BG_B;
  gfx_rect(bx, by, bw, bh);
  norm = (val - vmin) / (vmax - vmin);
  norm = max(0, min(1, norm));
  fill_w = norm * bw;
  fill_w > 0 ? (
    gfx_r = COL_CYAN_R * 0.6; gfx_g = COL_CYAN_G * 0.6; gfx_b = COL_CYAN_B * 0.6;
    gfx_rect(bx, by, fill_w, bh);
    gfx_r = COL_CYAN_R * 0.8; gfx_g = COL_CYAN_G * 0.8; gfx_b = COL_CYAN_B * 0.8;
    gfx_rect(bx, by, fill_w, floor(bh / 2));
    gfx_r = COL_CYAN_R; gfx_g = COL_CYAN_G; gfx_b = COL_CYAN_B;
    gfx_rect(bx, by, fill_w, 1);
  );
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_rect(bx, by, bw, 1); gfx_rect(bx, by + bh - 1, bw, 1);
  gfx_rect(bx, by, 1, bh); gfx_rect(bx + bw - 1, by, 1, bh);
  gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
  gfx_setfont(1, "Arial", 12);
  gfx_x = bx + 5; gfx_y = by + floor((bh - 12) / 2);
  gfx_drawstr(label);
  show_val ? (
    gfx_setfont(1, "Arial", 11);
    gfx_x = bx + bw - 40; gfx_y = by + floor((bh - 11) / 2);
    gfx_drawnumber(val, val == floor(val) ? 0 : 1);
  );
  mouse_cap & 1 ? (
    mouse_x >= bx && mouse_x <= bx + bw &&
    mouse_y >= by && mouse_y <= by + bh ? (
      new_norm = (mouse_x - bx) / bw;
      new_norm = max(0, min(1, new_norm));
      val = vmin + new_norm * (vmax - vmin);
    );
  );
  val;
);

function draw_panel(px, py, pw, ph, title) (
  gfx_r = COL_PANEL_R; gfx_g = COL_PANEL_G; gfx_b = COL_PANEL_B;
  gfx_rect(px, py, pw, ph);
  gfx_r = COL_PANEL_HI_R; gfx_g = COL_PANEL_HI_G; gfx_b = COL_PANEL_HI_B;
  gfx_rect(px, py, pw, 22);
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_rect(px, py + 22, pw, 1);
  gfx_r = COL_BORDER_R * 0.7; gfx_g = COL_BORDER_G * 0.7; gfx_b = COL_BORDER_B * 0.7;
  gfx_rect(px, py, pw, 1); gfx_rect(px, py, 1, ph);
  gfx_rect(px + pw - 1, py, 1, ph); gfx_rect(px, py + ph - 1, pw, 1);
  gfx_r = COL_SEC_R; gfx_g = COL_SEC_G; gfx_b = COL_SEC_B;
  gfx_setfont(1, "Arial", 12);
  gfx_x = px + 8; gfx_y = py + 4;
  gfx_drawstr(title);
);

function draw_toggle(tx, ty, is_on, label) (
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_circle(tx + 8, ty + 8, 7, 0);
  is_on ? (
    gfx_r = COL_GREEN_R; gfx_g = COL_GREEN_G; gfx_b = COL_GREEN_B;
    gfx_circle(tx + 8, ty + 8, 5, 1);
  ) : (
    gfx_r = 0.15; gfx_g = 0.15; gfx_b = 0.18;
    gfx_circle(tx + 8, ty + 8, 5, 1);
  );
  gfx_r = is_on ? COL_TEXT_R : COL_DIM_R;
  gfx_g = is_on ? COL_TEXT_G : COL_DIM_G;
  gfx_b = is_on ? COL_TEXT_B : COL_DIM_B;
  gfx_setfont(1, "Arial", 11);
  gfx_x = tx + 20; gfx_y = ty + 1;
  gfx_drawstr(label);
  (mouse_cap & 1) && !(last_cap & 1) &&
    mouse_x >= tx && mouse_x <= tx + 80 &&
    mouse_y >= ty && mouse_y <= ty + 16 ? (
      is_on = 1 - is_on;
  );
  is_on;
);

function draw_mode_sel(mx, my, mw, mh, val, vmax, label, v0, v1, v2, v3) (
  gfx_r = COL_BAR_BG_R; gfx_g = COL_BAR_BG_G; gfx_b = COL_BAR_BG_B;
  gfx_rect(mx, my, mw, mh);
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_rect(mx, my, mw, 1); gfx_rect(mx, my + mh - 1, mw, 1);
  gfx_rect(mx, my, 1, mh); gfx_rect(mx + mw - 1, my, 1, mh);
  gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
  gfx_setfont(1, "Arial", 12);
  gfx_x = mx + 5; gfx_y = my + floor((mh - 12) / 2);
  gfx_drawstr(label);
  gfx_r = COL_ACCENT_R; gfx_g = COL_ACCENT_G; gfx_b = COL_ACCENT_B;
  gfx_x = mx + mw - 72; gfx_y = my + floor((mh - 12) / 2);
  val == 0 ? gfx_drawstr(v0);
  val == 1 ? gfx_drawstr(v1);
  val == 2 ? gfx_drawstr(v2);
  val == 3 ? gfx_drawstr(v3);
  (mouse_cap & 1) && !(last_cap & 1) &&
    mouse_x >= mx && mouse_x <= mx + mw &&
    mouse_y >= my && mouse_y <= my + mh ? (
      val = (val + 1) % (vmax + 1);
  );
  (mouse_cap & 2) && !(last_cap & 2) &&
    mouse_x >= mx && mouse_x <= mx + mw &&
    mouse_y >= my && mouse_y <= my + mh ? (
      val = val - 1; val < 0 ? val = vmax;
  );
  val;
);

// ============================================================================
//  LAYOUT
// ============================================================================
margin = 8;
gap = 6;
bar_h = 18;
bar_sp = 21;
body_y = 50;
col_w = floor((gfx_w - margin * 2 - gap) / 2);

// ============================================================================
//  TITLE
// ============================================================================
gfx_r = COL_TITLE_R; gfx_g = COL_TITLE_G; gfx_b = COL_TITLE_B;
gfx_setfont(1, "Arial", 20);
gfx_x = 12; gfx_y = 10;
gfx_drawstr("LMS - CHRIS' BEDROOM");
gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
gfx_setfont(1, "Arial", 11);
gfx_x = 270; gfx_y = 18;
gfx_drawstr("Amp Sim + Room");

// ============================================================================
//  LEFT COLUMN: AMP
// ============================================================================
c1x = margin;
amp_panel_h = 26 + bar_sp * 7;
draw_panel(c1x, body_y, col_w, amp_panel_h, "AMP");
cy = body_y + 26;

_old = slider1; slider1 = draw_bar(c1x + 4, cy, col_w - 8, bar_h, slider1, 0, 100, "Input Gain", 1);
slider1 != _old ? slider_automate(2^0);
cy += bar_sp;

_old = slider2; slider2 = draw_mode_sel(c1x + 4, cy, col_w - 8, bar_h, slider2, 3, "Mode", "Clean", "Crunch", "Lead", "Fuzz");
slider2 != _old ? slider_automate(2^1);
cy += bar_sp;

_old = slider3; slider3 = draw_bar(c1x + 4, cy, col_w - 8, bar_h, slider3, 0, 100, "Bass", 1);
slider3 != _old ? slider_automate(2^2);
cy += bar_sp;

_old = slider4; slider4 = draw_bar(c1x + 4, cy, col_w - 8, bar_h, slider4, 0, 100, "Mid", 1);
slider4 != _old ? slider_automate(2^3);
cy += bar_sp;

_old = slider5; slider5 = draw_bar(c1x + 4, cy, col_w - 8, bar_h, slider5, 0, 100, "Treble", 1);
slider5 != _old ? slider_automate(2^4);
cy += bar_sp;

_old = slider6; slider6 = draw_bar(c1x + 4, cy, col_w - 8, bar_h, slider6, 0, 100, "Presence", 1);
slider6 != _old ? slider_automate(2^5);
cy += bar_sp;

_old = slider7; slider7 = draw_bar(c1x + 4, cy, col_w - 8, bar_h, slider7, 0, 100, "Master Vol", 1);
slider7 != _old ? slider_automate(2^6);

// ============================================================================
//  RIGHT COLUMN: ROOM
// ============================================================================
c2x = margin + col_w + gap;
room_panel_h = 26 + bar_sp * 6 + 4;
draw_panel(c2x, body_y, col_w, room_panel_h, "BEDROOM");
cy = body_y + 26;

_old = slider12; slider12 = draw_mode_sel(c2x + 4, cy, col_w - 8, bar_h, slider12, 2, "Room", "Bedroom", "Garage", "Basement", "");
slider12 != _old ? slider_automate(2^11);
cy += bar_sp;

_old = slider8; slider8 = draw_bar(c2x + 4, cy, col_w - 8, bar_h, slider8, 0, 100, "Size", 1);
slider8 != _old ? slider_automate(2^7);
cy += bar_sp;

_old = slider9; slider9 = draw_bar(c2x + 4, cy, col_w - 8, bar_h, slider9, 0, 100, "Decay", 1);
slider9 != _old ? slider_automate(2^8);
cy += bar_sp;

_old = slider10; slider10 = draw_bar(c2x + 4, cy, col_w - 8, bar_h, slider10, 0, 100, "Damp", 1);
slider10 != _old ? slider_automate(2^9);
cy += bar_sp;

_old = slider11; slider11 = draw_bar(c2x + 4, cy, col_w - 8, bar_h, slider11, 0, 100, "Room Mix", 1);
slider11 != _old ? slider_automate(2^10);
cy += bar_sp;

_old = slider13; slider13 = draw_bar(c2x + 4, cy, col_w - 8, bar_h, slider13, 0, 100, "Dry/Wet", 1);
slider13 != _old ? slider_automate(2^12);

// ============================================================================
//  BEDROOM VISUALIZER
//  Bird's-eye view of the room with amp and mic positions
// ============================================================================
vis_y = body_y + max(amp_panel_h, room_panel_h) + gap;
vis_h = gfx_h - vis_y - 38;  // leave room for broadcast panel
vis_h = max(40, vis_h);

draw_panel(margin, vis_y, gfx_w - margin * 2, vis_h, "THE ROOM");

room_bx = margin + 8;
room_by = vis_y + 26;
room_bw = gfx_w - margin * 2 - 16;
room_bh = vis_h - 32;

// Room background
gfx_r = 0.04; gfx_g = 0.035; gfx_b = 0.06;
gfx_rect(room_bx, room_by, room_bw, room_bh);

// Room walls — color shifts with room type
room_type == 0 ? (
  // Bedroom: warm yellow walls
  gfx_r = 0.35; gfx_g = 0.28; gfx_b = 0.10;
) : room_type == 1 ? (
  // Garage: cold concrete
  gfx_r = 0.20; gfx_g = 0.22; gfx_b = 0.22;
) : (
  // Basement: damp stone
  gfx_r = 0.15; gfx_g = 0.18; gfx_b = 0.22;
);
gfx_rect(room_bx, room_by, room_bw, 3);
gfx_rect(room_bx, room_by + room_bh - 3, room_bw, 3);
gfx_rect(room_bx, room_by, 3, room_bh);
gfx_rect(room_bx + room_bw - 3, room_by, 3, room_bh);

// Amp — left side of room
amp_vis_x = room_bx + floor(room_bw * 0.15);
amp_vis_y = room_by + floor(room_bh * 0.55);
amp_w = 18; amp_h = 14;

// Amp body
gfx_r = 0.12; gfx_g = 0.10; gfx_b = 0.10;
gfx_rect(amp_vis_x - amp_w/2, amp_vis_y - amp_h/2, amp_w, amp_h);
// Amp grill
gfx_r = 0.25; gfx_g = 0.20; gfx_b = 0.12;
gfx_rect(amp_vis_x - amp_w/2 + 2, amp_vis_y - amp_h/2 + 2, amp_w - 4, amp_h - 4);
// Speaker cone dot
gfx_r = 0.08; gfx_g = 0.06; gfx_b = 0.06;
gfx_circle(amp_vis_x, amp_vis_y, 4, 1);
// Label
gfx_r = COL_DIM_R * 0.7; gfx_g = COL_DIM_G * 0.7; gfx_b = COL_DIM_B * 0.7;
gfx_setfont(1, "Arial", 9);
gfx_x = amp_vis_x - 8; gfx_y = amp_vis_y + amp_h/2 + 3;
gfx_drawstr("AMP");

// Mic — center of room, distance scaled by room size
mic_x = amp_vis_x + floor(room_bw * 0.15) + floor(room_size * room_bw * 0.35);
mic_x = min(room_bx + room_bw - 20, mic_x);
mic_y = amp_vis_y;

// Mic stand
gfx_r = 0.25; gfx_g = 0.25; gfx_b = 0.30;
gfx_line(mic_x, mic_y + 10, mic_x, mic_y - 10);
// Mic capsule
gfx_r = COL_CYAN_R * 0.8; gfx_g = COL_CYAN_G * 0.8; gfx_b = COL_CYAN_B * 0.8;
gfx_circle(mic_x, mic_y - 10, 4, 1);
// Mic label
gfx_r = COL_DIM_R * 0.7; gfx_g = COL_DIM_G * 0.7; gfx_b = COL_DIM_B * 0.7;
gfx_setfont(1, "Arial", 9);
gfx_x = mic_x - 6; gfx_y = mic_y + 14;
gfx_drawstr("MIC");

// Draw sound wave lines from amp to mic (animated with heartbeat)
sb2 = BC_MY_REGION + bc_my_slot * BC_SLOT_SIZE;
wave_phase = bc_my_slot >= 0 ? gmem[sb2 + 0] * 0.08 : 0;
gfx_r = COL_ACCENT_R * 0.4 * (0.5 + in_gain * 0.5);
gfx_g = COL_ACCENT_G * 0.2;
gfx_b = 0.0;
wave_n = 3;
wi = 0;
loop(wave_n,
  wx = amp_vis_x + amp_w/2 + floor((mic_x - amp_vis_x - amp_w/2) * (wi + 1) / (wave_n + 1));
  wy_off = floor(sin(wave_phase + wi * 1.1) * 4 * in_gain);
  gfx_circle(wx, amp_vis_y + wy_off, 2, 1);
  wi += 1;
);

// Room size indicator text
gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
gfx_setfont(1, "Arial", 9);
gfx_x = room_bx + 6; gfx_y = room_by + 4;
room_type == 0 ? gfx_drawstr("BEDROOM");
room_type == 1 ? gfx_drawstr("GARAGE");
room_type == 2 ? gfx_drawstr("BASEMENT");

// ============================================================================
//  INSTANCE MANAGER PANEL
// ============================================================================
bc_rows_per_page = 5;
bc_panel_h = bc_panel_expanded ? (30 + bc_rows_per_page * 14 + 18) : 30;
bc_panel_y = gfx_h - bc_panel_h;

gfx_r = 0.04; gfx_g = 0.04; gfx_b = 0.06;
gfx_rect(0, bc_panel_y, gfx_w, bc_panel_h);
gfx_r = 0.15; gfx_g = 0.15; gfx_b = 0.20;
gfx_rect(0, bc_panel_y, gfx_w, 1);

gfx_setfont(1, "Arial", 11);
gfx_r = 0.95; gfx_g = 0.45; gfx_b = 0.15;
gfx_x = 8; gfx_y = bc_panel_y + 8;
bc_my_slot >= 0 ? (
  gfx_drawstr("I");
  gfx_drawnumber(bc_my_slot + 1, 0);
  gfx_drawstr("/");
  gfx_drawnumber(bc_instance_count, 0);
) : (
  gfx_drawstr("--");
);

bc_following > 0 ? (
  gfx_r = 0.2; gfx_g = 0.8; gfx_b = 0.3;
  gfx_drawstr("  Following: I");
  bc_fs = 0;
  loop(BC_MAX_INST,
    fsb = BC_MY_REGION + bc_fs * BC_SLOT_SIZE;
    gmem[fsb + 1] == bc_following ? (
      gfx_drawnumber(bc_fs + 1, 0);
      bc_fs = BC_MAX_INST;
    );
    bc_fs += 1;
  );
) : (
  gfx_r = 0.3; gfx_g = 0.3; gfx_b = 0.4;
  gfx_drawstr("  Following: --");
);

exp_x = gfx_w - 200; exp_y = bc_panel_y + 4; exp_w = 65; exp_h = 20;
gfx_r = 0.12; gfx_g = 0.12; gfx_b = 0.16;
gfx_rect(exp_x, exp_y, exp_w, exp_h);
gfx_r = 0.5; gfx_g = 0.5; gfx_b = 0.6;
gfx_x = exp_x + 5; gfx_y = exp_y + 4;
bc_panel_expanded ? gfx_drawstr("COLLAPSE") : gfx_drawstr("EXPAND");
(mouse_cap & 1) && !(last_cap & 1) &&
  mouse_x >= exp_x && mouse_x < exp_x + exp_w &&
  mouse_y >= exp_y && mouse_y < exp_y + exp_h ? (
  bc_panel_expanded = !bc_panel_expanded;
  bc_steal_mode = 0;
);

stl_x = gfx_w - 125; stl_y = bc_panel_y + 4; stl_w = 50; stl_h = 20;
bc_steal_mode ? (gfx_r = 0.6; gfx_g = 0.2; gfx_b = 0.1;) : (gfx_r = 0.2; gfx_g = 0.1; gfx_b = 0.1;);
gfx_rect(stl_x, stl_y, stl_w, stl_h);
gfx_r = 0.9; gfx_g = 0.5; gfx_b = 0.2;
gfx_x = stl_x + 6; gfx_y = stl_y + 4;
gfx_drawstr("STEAL");
(mouse_cap & 1) && !(last_cap & 1) &&
  mouse_x >= stl_x && mouse_x < stl_x + stl_w &&
  mouse_y >= stl_y && mouse_y < stl_y + stl_h ? (
  bc_steal_mode = !bc_steal_mode;
  !bc_panel_expanded ? bc_panel_expanded = 1;
);

bc_following > 0 ? (
  unf_x = gfx_w - 65; unf_y = bc_panel_y + 4; unf_w = 55; unf_h = 20;
  gfx_r = 0.1; gfx_g = 0.2; gfx_b = 0.1;
  gfx_rect(unf_x, unf_y, unf_w, unf_h);
  gfx_r = 0.5; gfx_g = 0.9; gfx_b = 0.5;
  gfx_x = unf_x + 4; gfx_y = unf_y + 4;
  gfx_drawstr("UNFLW");
  (mouse_cap & 1) && !(last_cap & 1) &&
    mouse_x >= unf_x && mouse_x < unf_x + unf_w &&
    mouse_y >= unf_y && mouse_y < unf_y + unf_h ? (
    bc_following = 0;
    bc_follow_slot = -1;
  );
);

bc_panel_expanded ? (
  row_y = bc_panel_y + 30;
  row_h = 14;

  bc_my_page = bc_my_slot >= 0 ? floor(bc_my_slot / bc_rows_per_page) : 0;
  bc_page < 0 ? bc_page = 0;

  bc_active_slots = 0;
  bc_si = 0;
  loop(BC_MAX_INST,
    gmem[BC_MY_REGION + bc_si * BC_SLOT_SIZE + 1] > 0 ? bc_active_slots += 1;
    bc_si += 1;
  );
  bc_total_pages = max(1, ceil(bc_active_slots / bc_rows_per_page));
  bc_page >= bc_total_pages ? bc_page = bc_total_pages - 1;

  pg_btn_w = 18; pg_btn_h = 14;
  pg_prev_x = 8; pg_prev_y = bc_panel_y + 30 + bc_rows_per_page * row_h + 2;
  bc_total_pages > 1 ? (
    gfx_r = 0.25; gfx_g = 0.25; gfx_b = 0.32;
    gfx_rect(pg_prev_x, pg_prev_y, pg_btn_w, pg_btn_h);
    gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.8;
    gfx_x = pg_prev_x + 4; gfx_y = pg_prev_y + 2;
    gfx_drawstr("<");
    (mouse_cap & 1) && !(last_cap & 1) &&
      mouse_x >= pg_prev_x && mouse_x < pg_prev_x + pg_btn_w &&
      mouse_y >= pg_prev_y && mouse_y < pg_prev_y + pg_btn_h ? (
      bc_page > 0 ? bc_page -= 1;
    );

    gfx_r = 0.25; gfx_g = 0.25; gfx_b = 0.32;
    gfx_rect(pg_prev_x + pg_btn_w + 2, pg_prev_y, pg_btn_w, pg_btn_h);
    gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.8;
    gfx_x = pg_prev_x + pg_btn_w + 6; gfx_y = pg_prev_y + 2;
    gfx_drawstr(">");
    (mouse_cap & 1) && !(last_cap & 1) &&
      mouse_x >= pg_prev_x + pg_btn_w + 2 && mouse_x < pg_prev_x + pg_btn_w * 2 + 2 &&
      mouse_y >= pg_prev_y && mouse_y < pg_prev_y + pg_btn_h ? (
      bc_page < bc_total_pages - 1 ? bc_page += 1;
    );

    gfx_r = 0.4; gfx_g = 0.4; gfx_b = 0.5;
    gfx_x = pg_prev_x + pg_btn_w * 2 + 8; gfx_y = pg_prev_y + 2;
    gfx_drawnumber(bc_page + 1, 0);
    gfx_drawstr("/");
    gfx_drawnumber(bc_total_pages, 0);

    bc_page != bc_my_page ? (
      you_x = pg_prev_x + pg_btn_w * 2 + 40;
      gfx_r = 0.15; gfx_g = 0.15; gfx_b = 0.20;
      gfx_rect(you_x, pg_prev_y, 30, pg_btn_h);
      gfx_r = 0.95; gfx_g = 0.45; gfx_b = 0.15;
      gfx_x = you_x + 3; gfx_y = pg_prev_y + 2;
      gfx_drawstr("YOU");
      (mouse_cap & 1) && !(last_cap & 1) &&
        mouse_x >= you_x && mouse_x < you_x + 30 &&
        mouse_y >= pg_prev_y && mouse_y < pg_prev_y + pg_btn_h ? (
        bc_page = bc_my_page;
      );
    );
  );

  bc_page_start = bc_page * bc_rows_per_page;
  bc_page_end = bc_page_start + bc_rows_per_page - 1;
  bc_visible = 0;
  bc_s = 0;
  loop(BC_MAX_INST,
    isb = BC_MY_REGION + bc_s * BC_SLOT_SIZE;
    isid = gmem[isb + 1];
    isid > 0 ? (
      bc_visible >= bc_page_start && bc_visible <= bc_page_end ? (
        draw_row_y = row_y + (bc_visible - bc_page_start) * row_h;
        mouse_y >= draw_row_y && mouse_y < draw_row_y + row_h &&
          mouse_x >= 8 && mouse_x < gfx_w - 8 &&
          bc_s != bc_my_slot ? (
          gfx_r = 0.10; gfx_g = 0.10; gfx_b = 0.14;
          gfx_rect(4, draw_row_y, gfx_w - 8, row_h);
        );
        gfx_setfont(1, "Arial", 10);
        bc_s == bc_my_slot ? (
          gfx_r = 0.95; gfx_g = 0.45; gfx_b = 0.15;
        ) : (
          gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.8;
        );
        gfx_x = 12; gfx_y = draw_row_y + 1;
        gfx_drawstr("I");
        gfx_drawnumber(bc_s + 1, 0);
        gfx_drawstr("  ");
        bc_s == bc_my_slot ? (
          gfx_drawstr("[YOU]");
        ) : (
          iwho = gmem[isb + 3];
          bc_has_follower = 0;
          bc_fsc = 0;
          loop(BC_MAX_INST,
            fsb2 = BC_MY_REGION + bc_fsc * BC_SLOT_SIZE;
            gmem[fsb2 + 1] > 0 && gmem[fsb2 + 3] == isid ? bc_has_follower = 1;
            bc_fsc += 1;
          );
          iwho > 0 ? (
            gfx_r = 0.4; gfx_g = 0.6; gfx_b = 0.9;
            gfx_drawstr("[FOLLOWER]");
          ) : bc_has_follower ? (
            gfx_r = 0.95; gfx_g = 0.78; gfx_b = 0.35;
            gfx_drawstr("[LEADER]");
          ) : (
            gfx_r = 0.38; gfx_g = 0.38; gfx_b = 0.45;
            gfx_drawstr("[UNASSIGNED]");
          );
          gfx_r = 0.35; gfx_g = 0.45; gfx_b = 0.35;
          bc_steal_mode ? (
            gfx_drawstr("  click: steal");
          ) : (
            gfx_drawstr("  click: follow");
          );
          (mouse_cap & 1) && !(last_cap & 1) &&
            mouse_y >= draw_row_y && mouse_y < draw_row_y + row_h &&
            mouse_x >= 8 && mouse_x < gfx_w - 8 ? (
            bc_steal_mode ? (
              bc_steal_target = isid;
              bc_steal_pending = 1;
              bc_steal_mode = 0;
            ) : (
              bc_can_follow = 1;
              bc_cursor = isid;
              bc_hops = 0;
              while(bc_cursor > 0 && bc_hops < BC_MAX_INST) (
                bc_cursor == bc_my_id ? (
                  bc_can_follow = 0;
                  bc_cursor = 0;
                ) : (
                  bc_next = 0;
                  bc_cs = 0;
                  loop(BC_MAX_INST,
                    csb = BC_MY_REGION + bc_cs * BC_SLOT_SIZE;
                    gmem[csb + 1] == bc_cursor ? (
                      bc_next = gmem[csb + 3];
                      bc_cs = BC_MAX_INST;
                    );
                    bc_cs += 1;
                  );
                  bc_cursor = bc_next;
                );
                bc_hops += 1;
              );
              bc_can_follow ? bc_following = isid;
            );
          );
        );
      );
      bc_visible += 1;
    );
    bc_s += 1;
  );
);

last_cap = mouse_cap;

// NOTICE button
notice_btn_x = gfx_w - 60;
notice_btn_y = bc_panel_y - 18;
gfx_r = 0.6; gfx_g = 0.5; gfx_b = 0.3;
gfx_rect(notice_btn_x, notice_btn_y, 55, 15);
gfx_r = 0; gfx_g = 0; gfx_b = 0;
gfx_x = notice_btn_x + 4; gfx_y = notice_btn_y + 2;
gfx_drawstr("NOTICE");
(mouse_cap & 1) && mouse_x >= notice_btn_x && mouse_x <= notice_btn_x + 55 && mouse_y >= notice_btn_y && mouse_y <= notice_btn_y + 15 && !notice_clicked ? (
  notice_show = !notice_show;
  notice_clicked = 1;
);
!(mouse_cap & 1) ? notice_clicked = 0;
notice_show ? (
  gfx_r = 0.05; gfx_g = 0.05; gfx_b = 0.05; gfx_a = 0.95;
  gfx_rect(0, 0, gfx_w, gfx_h);
  gfx_a = 1;
  gfx_r = 0.9; gfx_g = 0.8; gfx_b = 0.5;
  gfx_x = 15; gfx_y = 10;
  gfx_drawstr("NOTICE: THEY ARE TRYING TO STEAL YOUR COMPUTER");
  gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.7;
  gfx_x = 15; gfx_y = 30;
  gfx_drawstr("The algorithms in our favorite software are decades old.");
  gfx_x = 15; gfx_y = 45;
  gfx_drawstr("A mathematical model is a truth about the world,");
  gfx_x = 15; gfx_y = 60;
  gfx_drawstr("not a copyrightable product. You do not have to stay");
  gfx_x = 15; gfx_y = 75;
  gfx_drawstr("a slave to subscription software. Install Linux.");
  gfx_x = 15; gfx_y = 90;
  gfx_drawstr("Build your own tools. Believe in yourself.");
  gfx_r = 0.5; gfx_g = 0.7; gfx_b = 1.0;
  gfx_x = 15; gfx_y = 115;
  gfx_drawstr("github.com/LMSBAND  |  instagram.com/LMSSKABAND");
  gfx_r = 0.6; gfx_g = 0.5; gfx_b = 0.3;
  gfx_rect(notice_btn_x, notice_btn_y, 55, 15);
  gfx_r = 0; gfx_g = 0; gfx_b = 0;
  gfx_x = notice_btn_x + 4; gfx_y = notice_btn_y + 2;
  gfx_drawstr("NOTICE");
);

@serialize
file_var(0, bc_following);
file_var(0, bc_my_id);
