desc:LMS DrumbangerDrone
//author: LMS
//version: 0.1.0
//license: GPL-3.0
//
// Satellite plugin for LMS Drumbanger.
// Place on any track to receive triggers and patterns from Drumbanger.
// Modes: MIDI Sequencer, Sidechain, Gate, Trigger
// Built-in performance FX: HP/LP Filter, Flanger, Delay
//
// Requires LMS Drumbanger running on another track.

options:maxmem=1048576
options:gmem=DrumBanger

// ============================================================
// SLIDERS
// ============================================================

// -- Connection --
slider1:0<0,15,1{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16}>Watch Pad
slider2:0<0,3,1{MIDI Seq,Sidechain,Gate,Trigger}>Mode

// -- MIDI settings (for MIDI Seq and Trigger modes) --
slider3:0<0,15,1{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16}>MIDI Channel
slider4:60<0,127,1>Trigger Note (Trigger mode)
slider5:100<0,127,1>Trigger Velocity

// -- Sidechain / Gate --
slider10:0.8<0,1,0.01>Duck Depth (Sidechain)
slider11:10<1,200,1>Attack (ms)
slider12:100<5,1000,1>Release (ms)
slider13:0<0,1,1{Hard,Soft}>Gate Mode

// -- Filter --
slider20:0<0,2,1{Off,Low Pass,High Pass}>Filter Type
slider21:20000<20,20000,1>Filter Cutoff (Hz)
slider22:0.5<0.1,10,0.01>Filter Resonance (Q)
slider23:0<0,1,1{Off,On}>Filter Automate from Steps

// -- Flanger --
slider30:0<0,100,0.1>Flanger Depth (%)
slider31:0.25<0.01,10,0.01>Flanger Rate (Hz)
slider32:0.5<0,0.95,0.01>Flanger Feedback
slider33:0.5<0,1,0.01>Flanger Mix

// -- Delay --
slider40:0<0,100,0.1>Delay Mix (%)
slider41:3<0,5,1{1/16,1/8,1/4,1/2,1/1,1/8D}>Delay Time
slider42:0.4<0,0.95,0.01>Delay Feedback
slider43:4000<200,20000,10>Delay LP (Hz)
slider44:0<0,1,1{Mono,Ping Pong}>Delay Stereo

// -- Output --
slider50:0<-24,24,0.1>Output Gain (dB)
slider51:0.5<0,1,0.01>Dry/Wet Mix

@init

// ---- State ----
last_heartbeat = 0;
connected = 0;
env_level = 0;          // sidechain/gate envelope (0 = open, 1 = fully ducked)
last_step = -1;
note_playing = -1;      // currently sounding MIDI note (-1 = none)

// ---- Filter state (biquad) ----
f_x1l = 0; f_x2l = 0; f_y1l = 0; f_y2l = 0;
f_x1r = 0; f_x2r = 0; f_y1r = 0; f_y2r = 0;
f_a0 = 1; f_a1 = 0; f_a2 = 0; f_b1 = 0; f_b2 = 0;

// ---- Flanger state ----
FLANGE_BUF_L = 100000;
FLANGE_BUF_R = 200000;
FLANGE_BUF_SIZE = 48000;  // 1 second at 48kHz
flange_write_pos = 0;
flange_phase = 0;

// Clear flanger buffers
i = 0;
loop(FLANGE_BUF_SIZE,
  FLANGE_BUF_L[i] = 0;
  FLANGE_BUF_R[i] = 0;
  i += 1;
);

// ---- Delay state ----
DELAY_BUF_L = 300000;
DELAY_BUF_R = 400000;
DELAY_BUF_SIZE = 192000;  // 4 seconds at 48kHz
delay_write_pos = 0;

// Clear delay buffers
i = 0;
loop(DELAY_BUF_SIZE,
  DELAY_BUF_L[i] = 0;
  DELAY_BUF_R[i] = 0;
  i += 1;
);

// ---- Colors ----
COL_BG_R = 0.06; COL_BG_G = 0.06; COL_BG_B = 0.08;
COL_TXT_R = 0.85; COL_TXT_G = 0.85; COL_TXT_B = 0.88;
COL_ACC_R = 0.95; COL_ACC_G = 0.45; COL_ACC_B = 0.15;
COL_STEP_R = 0.30; COL_STEP_G = 0.75; COL_STEP_B = 0.55;
COL_DIM_R = 0.45; COL_DIM_G = 0.45; COL_DIM_B = 0.50;

// ============================================================
// FUNCTIONS
// ============================================================

// ---- Biquad filter coefficient calculation ----
function calc_filter_coeffs(type, fc, q) local(w0, alpha, cosw, sinw, a0_inv) (
  fc = max(20, min(fc, srate * 0.49));
  w0 = 2 * $pi * fc / srate;
  cosw = cos(w0);
  sinw = sin(w0);
  alpha = sinw / (2 * q);

  type == 1 ? (
    // Low Pass
    f_a0 = (1 - cosw) / 2;
    f_a1 = 1 - cosw;
    f_a2 = (1 - cosw) / 2;
    f_b1 = -2 * cosw;
    f_b2 = 1 - alpha;
    a0_inv = 1 / (1 + alpha);
  ) : type == 2 ? (
    // High Pass
    f_a0 = (1 + cosw) / 2;
    f_a1 = -(1 + cosw);
    f_a2 = (1 + cosw) / 2;
    f_b1 = -2 * cosw;
    f_b2 = 1 - alpha;
    a0_inv = 1 / (1 + alpha);
  ) : (
    // Off — passthrough
    f_a0 = 1; f_a1 = 0; f_a2 = 0;
    f_b1 = 0; f_b2 = 0;
    a0_inv = 1;
  );

  f_a0 *= a0_inv;
  f_a1 *= a0_inv;
  f_a2 *= a0_inv;
  f_b1 *= a0_inv;
  f_b2 *= a0_inv;
);

// ---- Biquad process (left channel) ----
function filter_l(x) local(y) (
  y = f_a0 * x + f_a1 * f_x1l + f_a2 * f_x2l - f_b1 * f_y1l - f_b2 * f_y2l;
  f_x2l = f_x1l; f_x1l = x;
  f_y2l = f_y1l; f_y1l = y;
  y;
);

// ---- Biquad process (right channel) ----
function filter_r(x) local(y) (
  y = f_a0 * x + f_a1 * f_x1r + f_a2 * f_x2r - f_b1 * f_y1r - f_b2 * f_y2r;
  f_x2r = f_x1r; f_x1r = x;
  f_y2r = f_y1r; f_y1r = y;
  y;
);

// ---- Delay time from slider to samples ----
function get_delay_samples() local(bpm, beat_len) (
  bpm = gmem[14];
  bpm <= 0 ? bpm = 120;
  beat_len = srate * 60 / bpm;

  slider41 == 0 ? beat_len / 4 :     // 1/16
  slider41 == 1 ? beat_len / 2 :     // 1/8
  slider41 == 2 ? beat_len :         // 1/4
  slider41 == 3 ? beat_len * 2 :     // 1/2
  slider41 == 4 ? beat_len * 4 :     // 1/1
  slider41 == 5 ? beat_len * 0.75 :  // 1/8 dotted
  beat_len / 2;
);

// ============================================================
// @BLOCK — Read Drumbanger state + handle MIDI
// ============================================================
@block

watch_pad = slider1;
mode = slider2;

// ---- Check connection ----
// Drone broadcast lives at gmem[10-19] (gmem[0-9] is sampling service)
heartbeat = gmem[10];
connected = (heartbeat != last_heartbeat);
last_heartbeat = heartbeat;

// ---- Read Drumbanger state ----
db_step = gmem[11];
db_steps_per_measure = gmem[12];
db_pattern = gmem[13];
db_bpm = gmem[14];
db_playing = gmem[15];
db_seq_mode = gmem[16];

// ---- Read trigger for our watched pad ----
pad_triggered = gmem[100 + watch_pad];
pad_active = gmem[120 + watch_pad];

// Consume trigger (Drone reads then clears)
pad_triggered > 0 ? (
  trigger_vel = pad_triggered;
  gmem[100 + watch_pad] = 0;
) : (
  trigger_vel = 0;
);

// ---- Detect step change ----
step_changed = (db_step != last_step) && db_playing;

// ---- Mode: MIDI Sequencer ----
mode == 0 && step_changed && connected ? (
  // Read note data from gmem for current step + watched pad
  step_note = gmem[500 + db_step * 16 + watch_pad];
  step_vel = gmem[200 + db_step * 16 + watch_pad];

  // If no drone note data, fall back to trigger note
  step_note <= 0 && step_vel > 0 ? (
    step_note = slider4;
  );

  midi_ch = slider3;

  // Note off for previous note
  note_playing >= 0 ? (
    midisend(0, 0x80 | midi_ch, note_playing, 0);
    note_playing = -1;
  );

  // Note on for new step
  step_vel > 0 && step_note > 0 ? (
    midisend(0, 0x90 | midi_ch, step_note, min(127, step_vel));
    note_playing = step_note;
  );
);

// ---- Mode: Trigger (single note per pad hit) ----
mode == 3 && trigger_vel > 0 && connected ? (
  midi_ch = slider3;

  // Note off previous
  note_playing >= 0 ? (
    midisend(0, 0x80 | midi_ch, note_playing, 0);
  );

  // Note on
  midisend(0, 0x90 | midi_ch, slider4, min(127, slider5));
  note_playing = slider4;
);

// ---- Stop notes when transport stops ----
!db_playing && note_playing >= 0 ? (
  midisend(0, 0x80 | slider3, note_playing, 0);
  note_playing = -1;
);

last_step = db_step;

// ---- Update filter coefficients ----
calc_filter_coeffs(slider20, slider21, slider22);

// ============================================================
// @SAMPLE — Audio processing
// ============================================================
@sample

in_l = spl0;
in_r = spl1;

// ---- Sidechain / Gate envelope ----
mode == 1 || mode == 2 ? (
  // Envelope target: 1 when pad active (duck/gate), 0 when inactive
  mode == 1 ? (
    // Sidechain: duck when pad triggers
    env_target = pad_active ? slider10 : 0;
  ) : (
    // Gate: pass when pad active, silence when not
    env_target = pad_active ? 0 : 1;
  );

  // Smooth envelope (attack/release in ms → coefficient)
  env_target > env_level ? (
    att_coeff = exp(-1 / (slider11 * 0.001 * srate));
    env_level = att_coeff * env_level + (1 - att_coeff) * env_target;
  ) : (
    rel_coeff = exp(-1 / (slider12 * 0.001 * srate));
    env_level = rel_coeff * env_level + (1 - rel_coeff) * env_target;
  );

  // Apply envelope
  mode == 1 ? (
    // Sidechain: reduce gain
    gain = 1 - env_level;
  ) : (
    // Gate
    slider13 == 0 ? (
      // Hard gate
      gain = env_level < 0.5 ? 1 : 0;
    ) : (
      // Soft gate
      gain = 1 - env_level;
    );
  );

  in_l *= gain;
  in_r *= gain;
);

// ---- Filter ----
slider20 > 0 ? (
  in_l = filter_l(in_l);
  in_r = filter_r(in_r);
);

// ---- Flanger ----
slider30 > 0 ? (
  // Write to buffer
  FLANGE_BUF_L[flange_write_pos] = in_l;
  FLANGE_BUF_R[flange_write_pos] = in_r;

  // LFO → delay time (0.5ms to 5ms range)
  flange_phase += slider31 / srate;
  flange_phase >= 1 ? flange_phase -= 1;
  lfo = (sin(2 * $pi * flange_phase) + 1) * 0.5;

  flange_depth = slider30 / 100;
  flange_delay_samples = (0.0005 + lfo * 0.0045 * flange_depth) * srate;

  // Read from buffer with interpolation
  flange_read = flange_write_pos - flange_delay_samples;
  flange_read < 0 ? flange_read += FLANGE_BUF_SIZE;
  flange_idx = (flange_read | 0);
  flange_frac = flange_read - flange_idx;
  flange_idx2 = (flange_idx + 1) % FLANGE_BUF_SIZE;

  fl_l = FLANGE_BUF_L[flange_idx] + flange_frac * (FLANGE_BUF_L[flange_idx2] - FLANGE_BUF_L[flange_idx]);
  fl_r = FLANGE_BUF_R[flange_idx] + flange_frac * (FLANGE_BUF_R[flange_idx2] - FLANGE_BUF_R[flange_idx]);

  // Feedback
  FLANGE_BUF_L[flange_write_pos] += fl_l * slider32;
  FLANGE_BUF_R[flange_write_pos] += fl_r * slider32;

  // Mix
  flange_mix = slider33;
  in_l = in_l * (1 - flange_mix) + fl_l * flange_mix;
  in_r = in_r * (1 - flange_mix) + fl_r * flange_mix;

  flange_write_pos = (flange_write_pos + 1) % FLANGE_BUF_SIZE;
);

// ---- Delay ----
slider40 > 0 ? (
  delay_samples = get_delay_samples();
  delay_samples = min(delay_samples, DELAY_BUF_SIZE - 1);

  // Read from delay buffer
  delay_read_pos = delay_write_pos - (delay_samples | 0);
  delay_read_pos < 0 ? delay_read_pos += DELAY_BUF_SIZE;

  del_l = DELAY_BUF_L[delay_read_pos];
  del_r = DELAY_BUF_R[delay_read_pos];

  // Simple LP on delay feedback (1-pole)
  delay_lp_coeff = exp(-2 * $pi * slider43 / srate);
  del_l = del_l * (1 - delay_lp_coeff) + delay_prev_l * delay_lp_coeff;
  del_r = del_r * (1 - delay_lp_coeff) + delay_prev_r * delay_lp_coeff;
  delay_prev_l = del_l;
  delay_prev_r = del_r;

  // Write to delay buffer (input + feedback)
  slider44 == 0 ? (
    // Mono delay
    DELAY_BUF_L[delay_write_pos] = in_l + del_l * slider42;
    DELAY_BUF_R[delay_write_pos] = in_r + del_r * slider42;
  ) : (
    // Ping pong: cross-feed L↔R
    DELAY_BUF_L[delay_write_pos] = in_l + del_r * slider42;
    DELAY_BUF_R[delay_write_pos] = in_r + del_l * slider42;
  );

  // Mix
  delay_mix = slider40 / 100;
  in_l = in_l + del_l * delay_mix;
  in_r = in_r + del_r * delay_mix;

  delay_write_pos = (delay_write_pos + 1) % DELAY_BUF_SIZE;
);

// ---- Output gain ----
out_gain = 10 ^ (slider50 / 20);

// ---- Dry/Wet ----
wet = slider51;
spl0 = (spl0 * (1 - wet) + in_l * wet) * out_gain;
spl1 = (spl1 * (1 - wet) + in_r * wet) * out_gain;

// ============================================================
// @GFX — User Interface
// ============================================================
@gfx 500 300

// ---- Background ----
gfx_r = COL_BG_R; gfx_g = COL_BG_G; gfx_b = COL_BG_B;
gfx_rect(0, 0, gfx_w, gfx_h);

margin = 10;
gfx_setfont(1, "Arial", 12);

// ============================================
// HEADER
// ============================================
gfx_setfont(2, "Arial", 16);
gfx_r = COL_ACC_R; gfx_g = COL_ACC_G; gfx_b = COL_ACC_B;
gfx_x = margin; gfx_y = margin;
gfx_drawstr("DRUMBANGER DRONE");

// Connection status
gfx_setfont(1, "Arial", 12);
gfx_x = margin; gfx_y = margin + 24;
connected ? (
  gfx_r = COL_STEP_R; gfx_g = COL_STEP_G; gfx_b = COL_STEP_B;
  gfx_drawstr("LINKED");
) : (
  gfx_r = 0.9; gfx_g = 0.15; gfx_b = 0.1;
  gfx_drawstr("NO SIGNAL");
);

// Pad + Mode info
gfx_r = COL_TXT_R; gfx_g = COL_TXT_G; gfx_b = COL_TXT_B;
gfx_drawstr("  |  Pad: ");
gfx_drawnumber(slider1 + 1, 0);
gfx_drawstr("  |  ");
slider2 == 0 ? gfx_drawstr("MIDI SEQ") :
slider2 == 1 ? gfx_drawstr("SIDECHAIN") :
slider2 == 2 ? gfx_drawstr("GATE") :
gfx_drawstr("TRIGGER");

// ============================================
// STEP DISPLAY (mirrors Drumbanger's current pattern for watched pad)
// ============================================
step_y = margin + 50;
step_w = (gfx_w - margin * 2 - 15 * 3) / 16;
step_h = 24;

connected ? (
  s = 0;
  loop(16,
    sx = margin + s * (step_w + margin / 5);

    // Read step data from gmem
    step_vel = gmem[200 + s * 16 + watch_pad];

    s < db_steps_per_measure ? (
      step_vel > 0 ? (
        gfx_r = COL_STEP_R * (step_vel / 127);
        gfx_g = COL_STEP_G * (step_vel / 127);
        gfx_b = COL_STEP_B * (step_vel / 127);
      ) : (
        gfx_r = 0.10; gfx_g = 0.10; gfx_b = 0.13;
      );
    ) : (
      gfx_r = 0.05; gfx_g = 0.05; gfx_b = 0.06;
    );

    gfx_rect(sx, step_y, step_w, step_h);

    // Playhead
    s == db_step && db_playing ? (
      gfx_r = 1; gfx_g = 1; gfx_b = 1;
      gfx_rect(sx, step_y, step_w, 2);
      gfx_rect(sx, step_y + step_h - 2, step_w, 2);
      gfx_rect(sx, step_y, 2, step_h);
      gfx_rect(sx + step_w - 2, step_y, 2, step_h);
    );

    // Beat markers
    s % 4 == 0 ? (
      gfx_r = 0.3; gfx_g = 0.3; gfx_b = 0.3;
      gfx_rect(sx, step_y + step_h + 2, step_w, 2);
    );

    s += 1;
  );
) : (
  gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
  gfx_x = margin; gfx_y = step_y + 4;
  gfx_drawstr("Waiting for Drumbanger...");
);

// ============================================
// ACTIVITY INDICATOR
// ============================================
ind_y = step_y + step_h + 16;
gfx_r = COL_TXT_R; gfx_g = COL_TXT_G; gfx_b = COL_TXT_B;
gfx_x = margin; gfx_y = ind_y;

pad_active ? (
  gfx_r = COL_ACC_R; gfx_g = COL_ACC_G; gfx_b = COL_ACC_B;
  gfx_drawstr(">>> PAD ACTIVE");
) : (
  gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
  gfx_drawstr("    idle");
);

// Sidechain/Gate envelope display
mode == 1 || mode == 2 ? (
  gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
  gfx_drawstr("    Env: ");
  gfx_drawnumber(env_level * 100, 0);
  gfx_drawstr("%");
);

// MIDI note display
mode == 0 || mode == 3 ? (
  note_playing >= 0 ? (
    gfx_r = COL_STEP_R; gfx_g = COL_STEP_G; gfx_b = COL_STEP_B;
    gfx_drawstr("    Note: ");
    gfx_drawnumber(note_playing, 0);
  );
);

// ============================================
// FX STATUS
// ============================================
fx_y = ind_y + 24;
gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
gfx_x = margin; gfx_y = fx_y;

slider20 > 0 ? (
  gfx_r = COL_STEP_R; gfx_g = COL_STEP_G; gfx_b = COL_STEP_B;
  slider20 == 1 ? gfx_drawstr("LP ") : gfx_drawstr("HP ");
  gfx_drawnumber(slider21, 0);
  gfx_drawstr("Hz  ");
  gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
) : (
  gfx_drawstr("Filter OFF  ");
);

slider30 > 0 ? (
  gfx_r = 0.5; gfx_g = 0.6; gfx_b = 1.0;
  gfx_drawstr("Flange ");
  gfx_drawnumber(slider30, 0);
  gfx_drawstr("%  ");
  gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
) : (
  gfx_drawstr("Flange OFF  ");
);

slider40 > 0 ? (
  gfx_r = 0.8; gfx_g = 0.5; gfx_b = 0.2;
  gfx_drawstr("Delay ");
  gfx_drawnumber(slider40, 0);
  gfx_drawstr("%  ");
  slider44 == 1 ? gfx_drawstr("PP  ");
) : (
  gfx_drawstr("Delay OFF  ");
);

// ============================================
// STATUS BAR
// ============================================
gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
gfx_x = margin; gfx_y = gfx_h - 18;
connected ? (
  db_playing ? gfx_drawstr("▶ ") : gfx_drawstr("■ ");
  gfx_drawstr("BPM: ");
  gfx_drawnumber(db_bpm, 1);
  gfx_drawstr("  Step: ");
  gfx_drawnumber(db_step + 1, 0);
  gfx_drawstr("/");
  gfx_drawnumber(db_steps_per_measure, 0);
  gfx_drawstr("  Pat: ");
  gfx_drawnumber(db_pattern + 1, 0);
  gfx_drawstr("  Bar: ");
  gfx_drawnumber(gmem[17] + 1, 0);
) : (
  gfx_drawstr("No Drumbanger detected — add LMS Drumbanger to any track");
);
