desc:LMS RTW (LMS Reinvents The Wheel)
//tags: channel strip preamp EQ compressor analog
//author: LMS + Claude

options:gmem=DrumBanger

slider1:0<-12,36,0.1>Preamp Drive (dB)
slider2:0<0,2,1{Clean,Warm,Hot}>Saturation Mode
slider3:0<0,1,1{Off,On}>HPF
slider4:80<20,500,1>HPF Freq (Hz)
slider5:0<-18,18,0.5>Low Shelf (dB)
slider6:200<40,1000,1>Low Freq (Hz)
slider7:0<-18,18,0.5>Low-Mid (dB)
slider8:800<200,3000,1>Low-Mid Freq (Hz)
slider9:1.0<0.3,4.0,0.1>Low-Mid Q
slider10:0<-18,18,0.5>Hi-Mid (dB)
slider11:3000<1000,8000,10>Hi-Mid Freq (Hz)
slider12:1.0<0.3,4.0,0.1>Hi-Mid Q
slider13:0<-18,18,0.5>High Shelf (dB)
slider14:8000<2000,16000,100>High Freq (Hz)
slider15:0<0,1,1{Off,On}>Compressor
slider16:-18<-40,0,0.5>Comp Threshold (dB)
slider17:4<0,3,1{2:1,4:1,6:1,10:1}>Comp Ratio
slider18:5<0.1,30,0.1>Comp Attack (ms)
slider19:100<10,1000,5>Comp Release (ms)
slider20:0<-12,12,0.1>Output Gain (dB)

@init
  // Compressor state
  comp_env = 0;
  comp_gr_db = 0;

  // Biquad filter states (L and R for each of 5 bands)
  // HPF
  hp_xl1 = 0; hp_xl2 = 0; hp_yl1 = 0; hp_yl2 = 0;
  hp_xr1 = 0; hp_xr2 = 0; hp_yr1 = 0; hp_yr2 = 0;
  // Low shelf
  ls_xl1 = 0; ls_xl2 = 0; ls_yl1 = 0; ls_yl2 = 0;
  ls_xr1 = 0; ls_xr2 = 0; ls_yr1 = 0; ls_yr2 = 0;
  // Low-mid parametric
  lm_xl1 = 0; lm_xl2 = 0; lm_yl1 = 0; lm_yl2 = 0;
  lm_xr1 = 0; lm_xr2 = 0; lm_yr1 = 0; lm_yr2 = 0;
  // Hi-mid parametric
  hm_xl1 = 0; hm_xl2 = 0; hm_yl1 = 0; hm_yl2 = 0;
  hm_xr1 = 0; hm_xr2 = 0; hm_yr1 = 0; hm_yr2 = 0;
  // High shelf
  hs_xl1 = 0; hs_xl2 = 0; hs_yl1 = 0; hs_yl2 = 0;
  hs_xr1 = 0; hs_xr2 = 0; hs_yr1 = 0; hs_yr2 = 0;

  // Coefficient storage
  hp_b0 = 1; hp_b1 = 0; hp_b2 = 0; hp_a1 = 0; hp_a2 = 0;
  ls_b0 = 1; ls_b1 = 0; ls_b2 = 0; ls_a1 = 0; ls_a2 = 0;
  lm_b0 = 1; lm_b1 = 0; lm_b2 = 0; lm_a1 = 0; lm_a2 = 0;
  hm_b0 = 1; hm_b1 = 0; hm_b2 = 0; hm_a1 = 0; hm_a2 = 0;
  hs_b0 = 1; hs_b1 = 0; hs_b2 = 0; hs_a1 = 0; hs_a2 = 0;

notice_show = 0;

  // ============================================================
  // BROADCAST SYSTEM — Instance Registry
  // ============================================================
  BC_BASE = 100000;
  BC_MY_TYPE = 4;           // Channel Strip
  BC_SLOT_SIZE = 512;
  BC_MAX_INST = 8;
  BC_PARAM_COUNT = 20;
  BC_MY_REGION = BC_BASE + BC_MY_TYPE * 4096;
  BC_STALE_TIMEOUT = 2;     // seconds

  // Generate unique instance ID (only on first init, preserve across transport stop/start)
  bc_my_id == 0 ? bc_my_id = floor(rand() * 1073741824) + 1;
  bc_my_slot = -1;
  // bc_following preserved by @serialize — do NOT zero here
  bc_follow_slot = -1;
  bc_steal_pending = 0;
  bc_steal_target = 0;
  bc_panel_expanded = 0;
  bc_steal_mode = 0;
  bc_instance_count = 0;

  // Stale detection arrays (local memory)
  BC_STALE_HB = 10000;    // last-seen heartbeat per slot
  BC_STALE_CT = 10008;    // stale counter per slot (in seconds)
  i = 0;
  loop(BC_MAX_INST,
    BC_STALE_HB[i] = -1;
    BC_STALE_CT[i] = 0;
    i += 1;
  );

  // Register: find empty or own slot
  bc_i = 0;
  loop(BC_MAX_INST,
    bc_my_slot < 0 ? (
      sb = BC_MY_REGION + bc_i * BC_SLOT_SIZE;
      sid = gmem[sb + 1];
      (sid == 0 || sid == bc_my_id) ? (
        bc_my_slot = bc_i;
      );
    );
    bc_i += 1;
  );

  // Claim the slot
  bc_my_slot >= 0 ? (
    sb = BC_MY_REGION + bc_my_slot * BC_SLOT_SIZE;
    gmem[sb + 0] = 0;
    gmem[sb + 1] = bc_my_id;
    gmem[sb + 2] = BC_MY_TYPE;
    gmem[sb + 3] = 0;
    gmem[sb + 4] = BC_PARAM_COUNT;
  );

@slider
  preamp_gain = 10 ^ (slider1 / 20);
  sat_mode = slider2;
  hpf_on = slider3;
  output_gain = 10 ^ (slider20 / 20);

  // HPF - 2nd order Butterworth
  hpf_on ? (
    w0 = 2 * $pi * slider4 / srate;
    cs = cos(w0); sn = sin(w0);
    alpha = sn / (2 * 0.707);
    a0_inv = 1 / (1 + alpha);
    hp_b0 = (1 + cs) / 2 * a0_inv;
    hp_b1 = -(1 + cs) * a0_inv;
    hp_b2 = (1 + cs) / 2 * a0_inv;
    hp_a1 = -2 * cs * a0_inv;
    hp_a2 = (1 - alpha) * a0_inv;
  );

  // Low shelf
  slider5 != 0 ? (
    a = 10 ^ (slider5 / 40);
    w0 = 2 * $pi * slider6 / srate;
    cs = cos(w0); sn = sin(w0);
    alpha = sn / (2 * 0.707);
    ap1 = a + 1; am1 = a - 1;
    beta = 2 * sqrt(a) * alpha;
    a0_inv = 1 / (ap1 + am1 * cs + beta);
    ls_b0 = a * (ap1 - am1 * cs + beta) * a0_inv;
    ls_b1 = 2 * a * (am1 - ap1 * cs) * a0_inv;
    ls_b2 = a * (ap1 - am1 * cs - beta) * a0_inv;
    ls_a1 = -2 * (am1 + ap1 * cs) * a0_inv;
    ls_a2 = (ap1 + am1 * cs - beta) * a0_inv;
  ) : (
    ls_b0 = 1; ls_b1 = 0; ls_b2 = 0; ls_a1 = 0; ls_a2 = 0;
  );

  // Low-mid parametric
  slider7 != 0 ? (
    a = 10 ^ (slider7 / 20);
    w0 = 2 * $pi * slider8 / srate;
    alpha = sin(w0) / (2 * slider9);
    a0_inv = 1 / (1 + alpha / a);
    lm_b0 = (1 + alpha * a) * a0_inv;
    lm_b1 = (-2 * cos(w0)) * a0_inv;
    lm_b2 = (1 - alpha * a) * a0_inv;
    lm_a1 = lm_b1;
    lm_a2 = (1 - alpha / a) * a0_inv;
  ) : (
    lm_b0 = 1; lm_b1 = 0; lm_b2 = 0; lm_a1 = 0; lm_a2 = 0;
  );

  // Hi-mid parametric
  slider10 != 0 ? (
    a = 10 ^ (slider10 / 20);
    w0 = 2 * $pi * slider11 / srate;
    alpha = sin(w0) / (2 * slider12);
    a0_inv = 1 / (1 + alpha / a);
    hm_b0 = (1 + alpha * a) * a0_inv;
    hm_b1 = (-2 * cos(w0)) * a0_inv;
    hm_b2 = (1 - alpha * a) * a0_inv;
    hm_a1 = hm_b1;
    hm_a2 = (1 - alpha / a) * a0_inv;
  ) : (
    hm_b0 = 1; hm_b1 = 0; hm_b2 = 0; hm_a1 = 0; hm_a2 = 0;
  );

  // High shelf
  slider13 != 0 ? (
    a = 10 ^ (slider13 / 40);
    w0 = 2 * $pi * slider14 / srate;
    cs = cos(w0); sn = sin(w0);
    alpha = sn / (2 * 0.707);
    ap1 = a + 1; am1 = a - 1;
    beta = 2 * sqrt(a) * alpha;
    a0_inv = 1 / (ap1 - am1 * cs + beta);
    hs_b0 = a * (ap1 + am1 * cs + beta) * a0_inv;
    hs_b1 = -2 * a * (am1 + ap1 * cs) * a0_inv;
    hs_b2 = a * (ap1 + am1 * cs - beta) * a0_inv;
    hs_a1 = 2 * (am1 - ap1 * cs) * a0_inv;
    hs_a2 = (ap1 - am1 * cs - beta) * a0_inv;
  ) : (
    hs_b0 = 1; hs_b1 = 0; hs_b2 = 0; hs_a1 = 0; hs_a2 = 0;
  );

  // Compressor
  comp_on = slider15;
  comp_thresh = slider16;
  slider17 == 0 ? comp_ratio = 2;
  slider17 == 1 ? comp_ratio = 4;
  slider17 == 2 ? comp_ratio = 6;
  slider17 == 3 ? comp_ratio = 10;
  comp_att = exp(-1 / (slider18 * 0.001 * srate));
  comp_rel = exp(-1 / (slider19 * 0.001 * srate));

// ============================================================
// @BLOCK — Broadcast, heartbeat, stale-check, follow, steal
// ============================================================
@block
bc_my_slot >= 0 ? (
  sb = BC_MY_REGION + bc_my_slot * BC_SLOT_SIZE;

  // Detect ID collision (track duplication)
  gmem[sb + 1] != bc_my_id ? (
    bc_my_id = floor(rand() * 1073741824) + 1;
    bc_my_slot = -1;
    bc_i = 0;
    loop(BC_MAX_INST,
      bc_my_slot < 0 ? (
        tsb = BC_MY_REGION + bc_i * BC_SLOT_SIZE;
        (gmem[tsb + 1] == 0) ? bc_my_slot = bc_i;
      );
      bc_i += 1;
    );
    bc_my_slot >= 0 ? (
      sb = BC_MY_REGION + bc_my_slot * BC_SLOT_SIZE;
      gmem[sb + 0] = 0;
      gmem[sb + 1] = bc_my_id;
      gmem[sb + 2] = BC_MY_TYPE;
      gmem[sb + 3] = bc_following;
      gmem[sb + 4] = BC_PARAM_COUNT;
    );
  );
);

// Follow mode: copy params from leader
bc_my_slot >= 0 && bc_following > 0 ? (
  bc_found_leader = 0;
  bc_scan = 0;
  loop(BC_MAX_INST,
    bc_scan != bc_my_slot ? (
      lsb = BC_MY_REGION + bc_scan * BC_SLOT_SIZE;
      gmem[lsb + 1] == bc_following ? (
        bc_found_leader = 1;
        bc_follow_slot = bc_scan;
        lbase = lsb + 8;
        // Copy all 20 params from leader
        slider1 = gmem[lbase + 0];
        slider2 = gmem[lbase + 1];
        slider3 = gmem[lbase + 2];
        slider4 = gmem[lbase + 3];
        slider5 = gmem[lbase + 4];
        slider6 = gmem[lbase + 5];
        slider7 = gmem[lbase + 6];
        slider8 = gmem[lbase + 7];
        slider9 = gmem[lbase + 8];
        slider10 = gmem[lbase + 9];
        slider11 = gmem[lbase + 10];
        slider12 = gmem[lbase + 11];
        slider13 = gmem[lbase + 12];
        slider14 = gmem[lbase + 13];
        slider15 = gmem[lbase + 14];
        slider16 = gmem[lbase + 15];
        slider17 = gmem[lbase + 16];
        slider18 = gmem[lbase + 17];
        slider19 = gmem[lbase + 18];
        slider20 = gmem[lbase + 19];
        bc_scan = BC_MAX_INST;
      );
    );
    bc_scan += 1;
  );
  !bc_found_leader ? (
    bc_following = 0;
    bc_follow_slot = -1;
  );
);

// Steal: one-shot copy
bc_my_slot >= 0 && bc_steal_pending ? (
  bc_scan = 0;
  loop(BC_MAX_INST,
    lsb = BC_MY_REGION + bc_scan * BC_SLOT_SIZE;
    gmem[lsb + 1] == bc_steal_target ? (
      lbase = lsb + 8;
      slider1 = gmem[lbase + 0];
      slider2 = gmem[lbase + 1];
      slider3 = gmem[lbase + 2];
      slider4 = gmem[lbase + 3];
      slider5 = gmem[lbase + 4];
      slider6 = gmem[lbase + 5];
      slider7 = gmem[lbase + 6];
      slider8 = gmem[lbase + 7];
      slider9 = gmem[lbase + 8];
      slider10 = gmem[lbase + 9];
      slider11 = gmem[lbase + 10];
      slider12 = gmem[lbase + 11];
      slider13 = gmem[lbase + 12];
      slider14 = gmem[lbase + 13];
      slider15 = gmem[lbase + 14];
      slider16 = gmem[lbase + 15];
      slider17 = gmem[lbase + 16];
      slider18 = gmem[lbase + 17];
      slider19 = gmem[lbase + 18];
      slider20 = gmem[lbase + 19];
      bc_scan = BC_MAX_INST;
    );
    bc_scan += 1;
  );
  bc_steal_pending = 0;
  bc_steal_target = 0;
  bc_steal_mode = 0;
);

// Broadcast our params + heartbeat
bc_my_slot >= 0 ? (
  sb = BC_MY_REGION + bc_my_slot * BC_SLOT_SIZE;
  gmem[sb + 0] += 1;
  gmem[sb + 3] = bc_following;
  pbase = sb + 8;
  gmem[pbase + 0] = slider1;
  gmem[pbase + 1] = slider2;
  gmem[pbase + 2] = slider3;
  gmem[pbase + 3] = slider4;
  gmem[pbase + 4] = slider5;
  gmem[pbase + 5] = slider6;
  gmem[pbase + 6] = slider7;
  gmem[pbase + 7] = slider8;
  gmem[pbase + 8] = slider9;
  gmem[pbase + 9] = slider10;
  gmem[pbase + 10] = slider11;
  gmem[pbase + 11] = slider12;
  gmem[pbase + 12] = slider13;
  gmem[pbase + 13] = slider14;
  gmem[pbase + 14] = slider15;
  gmem[pbase + 15] = slider16;
  gmem[pbase + 16] = slider17;
  gmem[pbase + 17] = slider18;
  gmem[pbase + 18] = slider19;
  gmem[pbase + 19] = slider20;
);

// Stale detection: scan all slots
bc_instance_count = 0;
bc_scan = 0;
loop(BC_MAX_INST,
  tsb = BC_MY_REGION + bc_scan * BC_SLOT_SIZE;
  tsid = gmem[tsb + 1];
  tsid > 0 ? (
    bc_scan == bc_my_slot ? (
      bc_instance_count += 1;
    ) : (
      tshb = gmem[tsb + 0];
      tshb == BC_STALE_HB[bc_scan] ? (
        BC_STALE_CT[bc_scan] += samplesblock / srate;
        BC_STALE_CT[bc_scan] > BC_STALE_TIMEOUT ? (
          gmem[tsb + 1] = 0;
          BC_STALE_CT[bc_scan] = 0;
        );
      ) : (
        BC_STALE_HB[bc_scan] = tshb;
        BC_STALE_CT[bc_scan] = 0;
        bc_instance_count += 1;
      );
    );
  );
  bc_scan += 1;
);

@sample
  l = spl0;
  r = spl1;

  // === PREAMP + SATURATION ===
  l *= preamp_gain;
  r *= preamp_gain;

  sat_mode == 1 ? (
    // Warm: soft saturation (even harmonics, tape-like)
    // Manual tanh: (exp(2x)-1)/(exp(2x)+1)
    x = l * 1.5; e = exp(2*x); l = (e - 1) / (e + 1) / 1.5 * 1.1;
    x = r * 1.5; e = exp(2*x); r = (e - 1) / (e + 1) / 1.5 * 1.1;
  );
  sat_mode == 2 ? (
    // Hot: harder asymmetric clipping (tube-like, adds odd harmonics)
    l > 0 ? (
      x = l * 2.5; e = exp(2*x); l = (e - 1) / (e + 1) / 2.5 * 1.3;
    ) : (
      x = l * 1.8; e = exp(2*x); l = (e - 1) / (e + 1) / 1.8 * 1.1;
    );
    r > 0 ? (
      x = r * 2.5; e = exp(2*x); r = (e - 1) / (e + 1) / 2.5 * 1.3;
    ) : (
      x = r * 1.8; e = exp(2*x); r = (e - 1) / (e + 1) / 1.8 * 1.1;
    );
  );

  // === HPF ===
  hpf_on ? (
    ol = hp_b0 * l + hp_b1 * hp_xl1 + hp_b2 * hp_xl2 - hp_a1 * hp_yl1 - hp_a2 * hp_yl2;
    hp_xl2 = hp_xl1; hp_xl1 = l; hp_yl2 = hp_yl1; hp_yl1 = ol;
    l = ol;
    ol = hp_b0 * r + hp_b1 * hp_xr1 + hp_b2 * hp_xr2 - hp_a1 * hp_yr1 - hp_a2 * hp_yr2;
    hp_xr2 = hp_xr1; hp_xr1 = r; hp_yr2 = hp_yr1; hp_yr1 = ol;
    r = ol;
  );

  // === 4-BAND EQ ===
  // Low shelf
  slider5 != 0 ? (
    ol = ls_b0 * l + ls_b1 * ls_xl1 + ls_b2 * ls_xl2 - ls_a1 * ls_yl1 - ls_a2 * ls_yl2;
    ls_xl2 = ls_xl1; ls_xl1 = l; ls_yl2 = ls_yl1; ls_yl1 = ol;
    l = ol;
    ol = ls_b0 * r + ls_b1 * ls_xr1 + ls_b2 * ls_xr2 - ls_a1 * ls_yr1 - ls_a2 * ls_yr2;
    ls_xr2 = ls_xr1; ls_xr1 = r; ls_yr2 = ls_yr1; ls_yr1 = ol;
    r = ol;
  );

  // Low-mid parametric
  slider7 != 0 ? (
    ol = lm_b0 * l + lm_b1 * lm_xl1 + lm_b2 * lm_xl2 - lm_a1 * lm_yl1 - lm_a2 * lm_yl2;
    lm_xl2 = lm_xl1; lm_xl1 = l; lm_yl2 = lm_yl1; lm_yl1 = ol;
    l = ol;
    ol = lm_b0 * r + lm_b1 * lm_xr1 + lm_b2 * lm_xr2 - lm_a1 * lm_yr1 - lm_a2 * lm_yr2;
    lm_xr2 = lm_xr1; lm_xr1 = r; lm_yr2 = lm_yr1; lm_yr1 = ol;
    r = ol;
  );

  // Hi-mid parametric
  slider10 != 0 ? (
    ol = hm_b0 * l + hm_b1 * hm_xl1 + hm_b2 * hm_xl2 - hm_a1 * hm_yl1 - hm_a2 * hm_yl2;
    hm_xl2 = hm_xl1; hm_xl1 = l; hm_yl2 = hm_yl1; hm_yl1 = ol;
    l = ol;
    ol = hm_b0 * r + hm_b1 * hm_xr1 + hm_b2 * hm_xr2 - hm_a1 * hm_yr1 - hm_a2 * hm_yr2;
    hm_xr2 = hm_xr1; hm_xr1 = r; hm_yr2 = hm_yr1; hm_yr1 = ol;
    r = ol;
  );

  // High shelf
  slider13 != 0 ? (
    ol = hs_b0 * l + hs_b1 * hs_xl1 + hs_b2 * hs_xl2 - hs_a1 * hs_yl1 - hs_a2 * hs_yl2;
    hs_xl2 = hs_xl1; hs_xl1 = l; hs_yl2 = hs_yl1; hs_yl1 = ol;
    l = ol;
    ol = hs_b0 * r + hs_b1 * hs_xr1 + hs_b2 * hs_xr2 - hs_a1 * hs_yr1 - hs_a2 * hs_yr2;
    hs_xr2 = hs_xr1; hs_xr1 = r; hs_yr2 = hs_yr1; hs_yr1 = ol;
    r = ol;
  );

  // === COMPRESSOR ===
  comp_on ? (
    det = max(abs(l), abs(r));
    det_db = det > 0.0000001 ? 20 * log10(det) : -140;
    over = det_db - comp_thresh;
    over > 0 ? (
      target_gr = over - over / comp_ratio;
    ) : (
      target_gr = 0;
    );
    target_gr > comp_env ? (
      comp_env = comp_att * comp_env + (1 - comp_att) * target_gr;
    ) : (
      comp_env = comp_rel * comp_env + (1 - comp_rel) * target_gr;
    );
    gr = 10 ^ (-comp_env / 20);
    comp_gr_db = comp_env;
    l *= gr;
    r *= gr;
  );

  // === OUTPUT ===
  spl0 = l * output_gain;
  spl1 = r * output_gain;

@gfx 500 280
  gfx_r = 0.06; gfx_g = 0.06; gfx_b = 0.09;
  gfx_rect(0, 0, gfx_w, gfx_h);

  gfx_r = 0.8; gfx_g = 0.7; gfx_b = 0.5;
  gfx_x = 10; gfx_y = 8;
  gfx_drawstr("LMS RTW");

  gfx_r = 0.4; gfx_g = 0.4; gfx_b = 0.5;
  gfx_x = 10; gfx_y = 28;
  sat_mode == 0 ? gfx_drawstr("Preamp: Clean");
  sat_mode == 1 ? gfx_drawstr("Preamp: Warm (Tape)");
  sat_mode == 2 ? gfx_drawstr("Preamp: Hot (Tube)");

  // EQ status
  gfx_x = 10; gfx_y = 48;
  gfx_r = 0.5; gfx_g = 0.5; gfx_b = 0.6;
  gfx_drawstr("EQ: ");
  hpf_on || slider5 != 0 || slider7 != 0 || slider10 != 0 || slider13 != 0 ? (
    gfx_r = 0.2; gfx_g = 0.8; gfx_b = 0.4;
    gfx_drawstr("Active");
  ) : (
    gfx_r = 0.3; gfx_g = 0.3; gfx_b = 0.4;
    gfx_drawstr("Flat");
  );

  // EQ band indicators
  gfx_y = 68;
  gfx_r = 0.4; gfx_g = 0.4; gfx_b = 0.5;
  hpf_on ? (
    gfx_x = 10;
    gfx_r = 0.6; gfx_g = 0.4; gfx_b = 0.3;
    gfx_drawstr("HPF ");
  );
  slider5 != 0 ? (
    gfx_x = gfx_x + 5;
    slider5 > 0 ? (gfx_r = 0.3; gfx_g = 0.7; gfx_b = 0.4;) : (gfx_r = 0.7; gfx_g = 0.3; gfx_b = 0.3;);
    gfx_drawstr("LO:");
    gfx_drawnumber(slider5, 1);
    gfx_drawstr(" ");
  );
  slider7 != 0 ? (
    gfx_x = gfx_x + 5;
    slider7 > 0 ? (gfx_r = 0.3; gfx_g = 0.7; gfx_b = 0.4;) : (gfx_r = 0.7; gfx_g = 0.3; gfx_b = 0.3;);
    gfx_drawstr("LM:");
    gfx_drawnumber(slider7, 1);
    gfx_drawstr(" ");
  );
  slider10 != 0 ? (
    gfx_x = gfx_x + 5;
    slider10 > 0 ? (gfx_r = 0.3; gfx_g = 0.7; gfx_b = 0.4;) : (gfx_r = 0.7; gfx_g = 0.3; gfx_b = 0.3;);
    gfx_drawstr("HM:");
    gfx_drawnumber(slider10, 1);
    gfx_drawstr(" ");
  );
  slider13 != 0 ? (
    gfx_x = gfx_x + 5;
    slider13 > 0 ? (gfx_r = 0.3; gfx_g = 0.7; gfx_b = 0.4;) : (gfx_r = 0.7; gfx_g = 0.3; gfx_b = 0.3;);
    gfx_drawstr("HI:");
    gfx_drawnumber(slider13, 1);
  );

  // Comp GR
  gfx_x = 10; gfx_y = 98;
  comp_on ? (
    gfx_r = 0.5; gfx_g = 0.5; gfx_b = 0.6;
    gfx_drawstr("Comp GR: ");
    gfx_r = 1.0; gfx_g = 0.4; gfx_b = 0.2;
    gfx_drawstr("-");
    gfx_drawnumber(comp_gr_db, 1);
    gfx_drawstr(" dB");
    gfx_r = 1.0; gfx_g = 0.3; gfx_b = 0.1;
    gr_width = min(comp_gr_db * 8, gfx_w - 20);
    gr_width > 0 ? gfx_rect(10, 116, gr_width, 6);
  ) : (
    gfx_r = 0.3; gfx_g = 0.3; gfx_b = 0.4;
    gfx_drawstr("Comp: Off");
  );

  // Output level
  gfx_x = 10; gfx_y = 132;
  gfx_r = 0.4; gfx_g = 0.4; gfx_b = 0.5;
  gfx_drawstr("Out: ");
  gfx_r = 0.6; gfx_g = 0.8; gfx_b = 0.9;
  gfx_drawnumber(slider20, 1);
  gfx_drawstr(" dB");
  // ============================================================
  // INSTANCE MANAGER PANEL
  // ============================================================
  bc_panel_h = bc_panel_expanded ? 90 : 30;
  bc_panel_y = gfx_h - bc_panel_h;

  // Panel background
  gfx_r = 0.04; gfx_g = 0.04; gfx_b = 0.06;
  gfx_rect(0, bc_panel_y, gfx_w, bc_panel_h);
  gfx_r = 0.15; gfx_g = 0.15; gfx_b = 0.20;
  gfx_rect(0, bc_panel_y, gfx_w, 1);

  // Instance count
  gfx_setfont(1, "Arial", 11);
  gfx_r = 0.95; gfx_g = 0.45; gfx_b = 0.15;
  gfx_x = 8; gfx_y = bc_panel_y + 8;
  bc_my_slot >= 0 ? (
    gfx_drawstr("I");
    gfx_drawnumber(bc_my_slot + 1, 0);
    gfx_drawstr("/");
    gfx_drawnumber(bc_instance_count, 0);
  ) : (
    gfx_drawstr("--");
  );

  // Follow status
  bc_following > 0 ? (
    gfx_r = 0.2; gfx_g = 0.8; gfx_b = 0.3;
    gfx_drawstr("  Following: I");
    bc_fs = 0;
    loop(BC_MAX_INST,
      fsb = BC_MY_REGION + bc_fs * BC_SLOT_SIZE;
      gmem[fsb + 1] == bc_following ? (
        gfx_drawnumber(bc_fs + 1, 0);
        bc_fs = BC_MAX_INST;
      );
      bc_fs += 1;
    );
  ) : (
    gfx_r = 0.3; gfx_g = 0.3; gfx_b = 0.4;
    gfx_drawstr("  Following: --");
  );

  // EXPAND/COLLAPSE button
  exp_x = gfx_w - 200;
  exp_y = bc_panel_y + 4;
  exp_w = 65;
  exp_h = 20;
  gfx_r = 0.12; gfx_g = 0.12; gfx_b = 0.16;
  gfx_rect(exp_x, exp_y, exp_w, exp_h);
  gfx_r = 0.5; gfx_g = 0.5; gfx_b = 0.6;
  gfx_x = exp_x + 5; gfx_y = exp_y + 4;
  bc_panel_expanded ? gfx_drawstr("COLLAPSE") : gfx_drawstr("EXPAND");
  (mouse_cap & 1) && !(last_cap & 1) &&
    mouse_x >= exp_x && mouse_x < exp_x + exp_w &&
    mouse_y >= exp_y && mouse_y < exp_y + exp_h ? (
    bc_panel_expanded = !bc_panel_expanded;
    bc_steal_mode = 0;
  );

  // STEAL button
  stl_x = gfx_w - 125;
  stl_y = bc_panel_y + 4;
  stl_w = 50;
  stl_h = 20;
  bc_steal_mode ? (
    gfx_r = 0.6; gfx_g = 0.2; gfx_b = 0.1;
  ) : (
    gfx_r = 0.2; gfx_g = 0.1; gfx_b = 0.1;
  );
  gfx_rect(stl_x, stl_y, stl_w, stl_h);
  gfx_r = 0.9; gfx_g = 0.5; gfx_b = 0.2;
  gfx_x = stl_x + 6; gfx_y = stl_y + 4;
  gfx_drawstr("STEAL");
  (mouse_cap & 1) && !(last_cap & 1) &&
    mouse_x >= stl_x && mouse_x < stl_x + stl_w &&
    mouse_y >= stl_y && mouse_y < stl_y + stl_h ? (
    bc_steal_mode = !bc_steal_mode;
    !bc_panel_expanded ? bc_panel_expanded = 1;
  );

  // UNFOLLOW button (only when following)
  bc_following > 0 ? (
    unf_x = gfx_w - 65;
    unf_y = bc_panel_y + 4;
    unf_w = 55;
    unf_h = 20;
    gfx_r = 0.1; gfx_g = 0.2; gfx_b = 0.1;
    gfx_rect(unf_x, unf_y, unf_w, unf_h);
    gfx_r = 0.5; gfx_g = 0.9; gfx_b = 0.5;
    gfx_x = unf_x + 4; gfx_y = unf_y + 4;
    gfx_drawstr("UNFLW");
    (mouse_cap & 1) && !(last_cap & 1) &&
      mouse_x >= unf_x && mouse_x < unf_x + unf_w &&
      mouse_y >= unf_y && mouse_y < unf_y + unf_h ? (
      bc_following = 0;
      bc_follow_slot = -1;
    );
  );

  // Expanded: instance list
  bc_panel_expanded ? (
    row_y = bc_panel_y + 30;
    row_h = 14;

    bc_s = 0;
    loop(BC_MAX_INST,
      isb = BC_MY_REGION + bc_s * BC_SLOT_SIZE;
      isid = gmem[isb + 1];

      isid > 0 ? (
        // Highlight row on hover
        mouse_y >= row_y && mouse_y < row_y + row_h &&
          mouse_x >= 8 && mouse_x < gfx_w - 8 &&
          bc_s != bc_my_slot ? (
          gfx_r = 0.10; gfx_g = 0.10; gfx_b = 0.14;
          gfx_rect(4, row_y, gfx_w - 8, row_h);
        );

        gfx_setfont(1, "Arial", 10);
        bc_s == bc_my_slot ? (
          gfx_r = 0.95; gfx_g = 0.45; gfx_b = 0.15;
        ) : (
          gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.8;
        );
        gfx_x = 12; gfx_y = row_y + 1;
        gfx_drawstr("I");
        gfx_drawnumber(bc_s + 1, 0);
        gfx_drawstr("  ");

        bc_s == bc_my_slot ? (
          gfx_drawstr("[YOU]");
        ) : (
          iwho = gmem[isb + 3];
          iwho > 0 ? (
            gfx_drawstr("[>I");
            iw = 0;
            loop(BC_MAX_INST,
              iwsb = BC_MY_REGION + iw * BC_SLOT_SIZE;
              gmem[iwsb + 1] == iwho ? (
                gfx_drawnumber(iw + 1, 0);
                iw = BC_MAX_INST;
              );
              iw += 1;
            );
            gfx_drawstr("]");
          ) : (
            gfx_drawstr("[LEADER]");
          );
          gfx_r = 0.35; gfx_g = 0.45; gfx_b = 0.35;
          bc_steal_mode ? (
            gfx_drawstr("  click: steal");
          ) : (
            gfx_drawstr("  click: follow");
          );

          // Click handler
          (mouse_cap & 1) && !(last_cap & 1) &&
            mouse_y >= row_y && mouse_y < row_y + row_h &&
            mouse_x >= 8 && mouse_x < gfx_w - 8 ? (
            bc_steal_mode ? (
              bc_steal_target = isid;
              bc_steal_pending = 1;
              bc_steal_mode = 0;
            ) : (
              // Follow — check for cycles first
              bc_can_follow = 1;
              bc_cursor = isid;
              bc_hops = 0;
              while(bc_cursor > 0 && bc_hops < BC_MAX_INST) (
                bc_cursor == bc_my_id ? (
                  bc_can_follow = 0;
                  bc_cursor = 0;
                ) : (
                  bc_next = 0;
                  bc_cs = 0;
                  loop(BC_MAX_INST,
                    csb = BC_MY_REGION + bc_cs * BC_SLOT_SIZE;
                    gmem[csb + 1] == bc_cursor ? (
                      bc_next = gmem[csb + 3];
                      bc_cs = BC_MAX_INST;
                    );
                    bc_cs += 1;
                  );
                  bc_cursor = bc_next;
                );
                bc_hops += 1;
              );
              bc_can_follow ? (
                bc_following = isid;
              );
            );
          );
        );

        row_y += row_h;
      );
      bc_s += 1;
    );
  );

  // Mouse state tracking
  last_cap = mouse_cap;

  // --- NOTICE BUTTON ---
  notice_btn_x = gfx_w - 60;
  notice_btn_y = bc_panel_y - 18;
  gfx_r = 0.6; gfx_g = 0.5; gfx_b = 0.3;
  gfx_rect(notice_btn_x, notice_btn_y, 55, 15);
  gfx_r = 0; gfx_g = 0; gfx_b = 0;
  gfx_x = notice_btn_x + 4; gfx_y = notice_btn_y + 2;
  gfx_drawstr("NOTICE");
  (mouse_cap & 1) && mouse_x >= notice_btn_x && mouse_x <= notice_btn_x + 55 && mouse_y >= notice_btn_y && mouse_y <= notice_btn_y + 15 && !notice_clicked ? (
    notice_show = !notice_show;
    notice_clicked = 1;
  );
  !(mouse_cap & 1) ? notice_clicked = 0;
  notice_show ? (
    gfx_r = 0.05; gfx_g = 0.05; gfx_b = 0.05; gfx_a = 0.95;
    gfx_rect(0, 0, gfx_w, gfx_h);
    gfx_a = 1;
    gfx_r = 0.9; gfx_g = 0.8; gfx_b = 0.5;
    gfx_x = 15; gfx_y = 10;
    gfx_drawstr("NOTICE: THEY ARE TRYING TO STEAL YOUR COMPUTER");
    gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.7;
    gfx_x = 15; gfx_y = 30;
    gfx_drawstr("The algorithms in our favorite software are decades old.");
    gfx_x = 15; gfx_y = 45;
    gfx_drawstr("A mathematical model is a truth about the world,");
    gfx_x = 15; gfx_y = 60;
    gfx_drawstr("not a copyrightable product. You do not have to stay");
    gfx_x = 15; gfx_y = 75;
    gfx_drawstr("a slave to subscription software. Install Linux.");
    gfx_x = 15; gfx_y = 90;
    gfx_drawstr("Build your own tools. Believe in yourself.");
    gfx_r = 0.5; gfx_g = 0.7; gfx_b = 1.0;
    gfx_x = 15; gfx_y = 115;
    gfx_drawstr("github.com/LMSBAND  |  instagram.com/LMSSKABAND");
    gfx_r = 0.4; gfx_g = 0.4; gfx_b = 0.4;
    gfx_x = 15; gfx_y = 140;
    gfx_r = 0.6; gfx_g = 0.5; gfx_b = 0.3;
    gfx_rect(notice_btn_x, notice_btn_y, 55, 15);
    gfx_r = 0; gfx_g = 0; gfx_b = 0;
    gfx_x = notice_btn_x + 4; gfx_y = notice_btn_y + 2;
    gfx_drawstr("NOTICE");
  );

// ============================================================
// @SERIALIZE — Persist follow state
// ============================================================
@serialize
file_var(0, bc_following);
file_var(0, bc_my_id);
