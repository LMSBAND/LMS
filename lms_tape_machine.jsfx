desc:LMS Tape Machine
//tags: delay echo tape saturation distortion analog
//author: LMS + Claude
filename:0,shakebot_logo.png


import lms_core.jsfx-inc
options:gmem=DrumBanger

// --- SATURATION SECTION ---
slider1:0<0,1,1{Off,On}>-Sat Enable
slider2:0<0,100,0.1>-Drive (%)
slider3:0<0,4,1{Warm Tube,Hot Tube,Tape,Rectifier,Fuzz}>-Sat Mode
slider4:0<0,100,0.1>-Even Harmonics (%)
slider5:50<0,100,0.1>-Odd Harmonics (%)
slider6:0<0,100,0.1>-Bias (%)
slider7:0<0,3,1{Pre Delay,Dry Only,Wet Only,Final Stage}>-Sat Routing

// --- DELAY SECTION ---
slider8:1<0,1,1{Off,On}>-Delay Enable
slider9:0<0,6,1{Head 1,Head 2,Head 3,Heads 1+2,Heads 1+3,Heads 2+3,All Heads}>-Head Mode
slider10:300<50,1000,1>-Repeat Rate (ms)
slider11:40<0,100,0.1>-Intensity (%)
slider12:80<0,100,0.1>-Echo Volume (%)
slider13:30<0,100,1>-Wow & Flutter (%)
slider14:30<0,100,1>-Tape Age (%)

// --- TONE & MIX ---
slider15:50<0,100,1>-Bass (%)
slider16:50<0,100,1>-Treble (%)
slider17:20000<20,20000,1>-Tone (Hz)
slider18:0<0,100,1>-Spring Reverb (%)
slider19:0<-12,12,0.1>-Output Gain (dB)
slider20:50<0,100,1>-Dry/Wet (%)

@init
  // === Delay buffer - max 2 seconds ===
  buf_max = floor(srate * 2);
  buf_l = 0;
  buf_r = buf_max;
  wpos = 0;

  memset(buf_l, 0, buf_max);
  memset(buf_r, 0, buf_max);

  // Feedback lowpass state
  fb_lp_l = 0; fb_lp_r = 0;

  // Feedback signal
  fb_l = 0; fb_r = 0;

  // Wow/flutter LFO phases
  wow_phase = 0;
  flutter_phase = 0;

  // Tape reel animation
  reel_angle = 0;

  // === Spring reverb buffers (6 allpass + 2 comb delays) ===
  sp_base = buf_max * 2 + 100;
  sp_ap1_len = 113;  sp_ap1_buf = sp_base;              sp_ap1_pos = 0;
  sp_ap2_len = 337;  sp_ap2_buf = sp_ap1_buf + sp_ap1_len; sp_ap2_pos = 0;
  sp_ap3_len = 547;  sp_ap3_buf = sp_ap2_buf + sp_ap2_len; sp_ap3_pos = 0;
  sp_ap4_len = 751;  sp_ap4_buf = sp_ap3_buf + sp_ap3_len; sp_ap4_pos = 0;
  sp_ap5_len = 1153; sp_ap5_buf = sp_ap4_buf + sp_ap4_len; sp_ap5_pos = 0;
  sp_ap6_len = 1597; sp_ap6_buf = sp_ap5_buf + sp_ap5_len; sp_ap6_pos = 0;
  sp_cm1_len = floor(srate * 0.035);
  sp_cm2_len = floor(srate * 0.043);
  sp_cm1_buf = sp_ap6_buf + sp_ap6_len; sp_cm1_pos = 0;
  sp_cm2_buf = sp_cm1_buf + sp_cm1_len; sp_cm2_pos = 0;
  memset(sp_base, 0, sp_cm2_buf + sp_cm2_len - sp_base);
  sp_lp_l = 0; sp_lp_r = 0;
  sp_damp_coeff = exp(-2 * $pi * 4000 / srate);

  // === Shared DSP instances ===
  dc.lms_dc_init_freq(220);
  tone.lms_tone_init();
  sat_l.lms_sat_warm_init();
  sat_r.lms_sat_warm_init();

  // === Tape saturation (feedback loop character) — unique to tape machine ===
  function tape_char(x, age)
    local(drive, b)
  (
    drive = 1 + age * 3;
    b = x * drive;
    b > 0 ? (
      b = lms_tanh(b);
    ) : (
      b = lms_tanh(b * 0.85) * 1.18;
    );
    b / drive * (1 + age * 0.5);
  );

  // === Apply saturation to a stereo pair ===
  function apply_sat(l, r) (
    sat_mode == 0 ? (
      sat_out_l = sat_l.lms_sat_warm(l, sat_drive, sat_bias);
      sat_out_r = sat_r.lms_sat_warm(r, sat_drive, sat_bias);
    ) : sat_mode == 1 ? (
      sat_out_l = sat_l.lms_sat_hot(l, sat_drive, sat_bias);
      sat_out_r = sat_r.lms_sat_hot(r, sat_drive, sat_bias);
    ) : sat_mode == 2 ? (
      sat_out_l = sat_l.lms_sat_tape(l, sat_drive, sat_bias);
      sat_out_r = sat_r.lms_sat_tape(r, sat_drive, sat_bias);
    ) : sat_mode == 3 ? (
      sat_out_l = sat_l.lms_sat_rect(l, sat_drive, sat_bias);
      sat_out_r = sat_r.lms_sat_rect(r, sat_drive, sat_bias);
    ) : (
      sat_out_l = sat_l.lms_sat_fuzz(l, sat_drive, sat_bias);
      sat_out_r = sat_r.lms_sat_fuzz(r, sat_drive, sat_bias);
    );

    // Harmonics
    (sat_even > 0 || sat_odd > 0) ? (
      sat_out_l = lms_sat_harmonics(sat_out_l, sat_even, sat_odd);
      sat_out_r = lms_sat_harmonics(sat_out_r, sat_even, sat_odd);
    );

    // Tone control
    sat_out_l = tone.lms_tone_proc_l(sat_out_l);
    sat_out_r = tone.lms_tone_proc_r(sat_out_r);
  );

notice_show = 0;

  // ============================================================
  // BROADCAST SYSTEM — Instance Registry
  // ============================================================
  BC_BASE = 100000;
  BC_MY_TYPE = 9;           // Tape Machine
  BC_SLOT_SIZE = 512;
  BC_MAX_INST = 32;
  BC_PARAM_COUNT = 20;
  BC_MY_REGION = BC_BASE + BC_MY_TYPE * 16384;
  BC_STALE_TIMEOUT = 2;

  // Generate unique instance ID (only on first init, preserve across transport stop/start)
  bc_my_id == 0 ? bc_my_id = floor(rand() * 1073741824) + 1;
  bc_my_slot = -1;
  // bc_following preserved by @serialize — do NOT zero here
  bc_follow_slot = -1;
  bc_steal_pending = 0;
  bc_steal_target = 0;
  bc_panel_expanded = 0;
  bc_page = 0;
  bc_steal_mode = 0;
  bc_instance_count = 0;

  BC_STALE_HB = 500000;
  BC_STALE_CT = 500032;
  i = 0;
  loop(BC_MAX_INST,
    BC_STALE_HB[i] = -1;
    BC_STALE_CT[i] = 0;
    i += 1;
  );

  bc_i = 0;
  loop(BC_MAX_INST,
    bc_my_slot < 0 ? (
      sb = BC_MY_REGION + bc_i * BC_SLOT_SIZE;
      sid = gmem[sb + 1];
      (sid == 0 || sid == bc_my_id) ? (
        bc_my_slot = bc_i;
      );
    );
    bc_i += 1;
  );

  bc_my_slot >= 0 ? (
    sb = BC_MY_REGION + bc_my_slot * BC_SLOT_SIZE;
    gmem[sb + 0] = 0;
    gmem[sb + 1] = bc_my_id;
    gmem[sb + 2] = BC_MY_TYPE;
    gmem[sb + 3] = 0;
    gmem[sb + 4] = BC_PARAM_COUNT;
  );

@slider
  // Saturation params
  sat_on = slider1;
  sat_drive = slider2 / 100;
  sat_mode = slider3;
  sat_even = slider4 / 100;
  sat_odd = slider5 / 100;
  sat_bias = slider6 / 100;
  sat_routing = slider7;

  // Delay params
  delay_on = slider8;
  head_mode = slider9;
  delay_ms = slider10;
  intensity = slider11 / 100;
  echo_vol = slider12 / 100;
  wf_amount = slider13 / 100;
  tape_age = slider14 / 100;

  // Tone & mix
  bass = slider15 / 100;
  treble = slider16 / 100;
  tone.lms_tone_set(slider17);
  spring_mix = slider18 / 100;
  out_gain = 10 ^ (slider19 / 20);
  dry_wet = slider20 / 100;

  // Delay setup
  delay_base = delay_ms / 1000 * srate;
  head1_delay = delay_base;
  head2_delay = delay_base * 1.5;
  head3_delay = delay_base * 2.0;

  h1_on = (head_mode == 0 || head_mode == 3 || head_mode == 4 || head_mode == 6) ? 1 : 0;
  h2_on = (head_mode == 1 || head_mode == 3 || head_mode == 5 || head_mode == 6) ? 1 : 0;
  h3_on = (head_mode == 2 || head_mode == 4 || head_mode == 5 || head_mode == 6) ? 1 : 0;
  num_heads = h1_on + h2_on + h3_on;
  num_heads < 1 ? num_heads = 1;

  // Feedback lowpass
  fb_lp_freq = 800 + treble * 8000 - tape_age * 3000;
  fb_lp_freq = max(fb_lp_freq, 400);
  fb_lp_freq = min(fb_lp_freq, 12000);
  fb_lp_coeff = exp(-2 * $pi * fb_lp_freq / srate);

  // Bass highpass
  bass_hp_freq = 60 + (1 - bass) * 400;
  bass_hp_coeff = exp(-2 * $pi * bass_hp_freq / srate);

// ============================================================
// @BLOCK — Broadcast, heartbeat, stale-check, follow, steal
// ============================================================
@block
// ---- Recalculate from sliders (GFX changes don't trigger @slider) ----
// Saturation params
sat_on = slider1;
sat_drive = slider2 / 100;
sat_mode = slider3;
sat_even = slider4 / 100;
sat_odd = slider5 / 100;
sat_bias = slider6 / 100;
sat_routing = slider7;

// Delay params
delay_on = slider8;
head_mode = slider9;
delay_ms = slider10;
intensity = slider11 / 100;
echo_vol = slider12 / 100;
wf_amount = slider13 / 100;
tape_age = slider14 / 100;

// Tone & mix
bass = slider15 / 100;
treble = slider16 / 100;
tone.lms_tone_set(slider17);
spring_mix = slider18 / 100;
out_gain = 10 ^ (slider19 / 20);
dry_wet = slider20 / 100;

// Delay setup
delay_base = delay_ms / 1000 * srate;
head1_delay = delay_base;
head2_delay = delay_base * 1.5;
head3_delay = delay_base * 2.0;

h1_on = (head_mode == 0 || head_mode == 3 || head_mode == 4 || head_mode == 6) ? 1 : 0;
h2_on = (head_mode == 1 || head_mode == 3 || head_mode == 5 || head_mode == 6) ? 1 : 0;
h3_on = (head_mode == 2 || head_mode == 4 || head_mode == 5 || head_mode == 6) ? 1 : 0;
num_heads = h1_on + h2_on + h3_on;
num_heads < 1 ? num_heads = 1;

// Feedback lowpass
fb_lp_freq = 800 + treble * 8000 - tape_age * 3000;
fb_lp_freq = max(fb_lp_freq, 400);
fb_lp_freq = min(fb_lp_freq, 12000);
fb_lp_coeff = exp(-2 * $pi * fb_lp_freq / srate);

// Bass highpass
bass_hp_freq = 60 + (1 - bass) * 400;
bass_hp_coeff = exp(-2 * $pi * bass_hp_freq / srate);

bc_my_slot >= 0 ? (
  sb = BC_MY_REGION + bc_my_slot * BC_SLOT_SIZE;
  gmem[sb + 1] != bc_my_id ? (
    bc_my_id = floor(rand() * 1073741824) + 1;
    bc_my_slot = -1;
    bc_i = 0;
    loop(BC_MAX_INST,
      bc_my_slot < 0 ? (
        tsb = BC_MY_REGION + bc_i * BC_SLOT_SIZE;
        (gmem[tsb + 1] == 0) ? bc_my_slot = bc_i;
      );
      bc_i += 1;
    );
    bc_my_slot >= 0 ? (
      sb = BC_MY_REGION + bc_my_slot * BC_SLOT_SIZE;
      gmem[sb + 0] = 0;
      gmem[sb + 1] = bc_my_id;
      gmem[sb + 2] = BC_MY_TYPE;
      gmem[sb + 3] = bc_following;
      gmem[sb + 4] = BC_PARAM_COUNT;
    );
  );
);

bc_my_slot >= 0 && bc_following > 0 ? (
  bc_found_leader = 0;
  bc_scan = 0;
  loop(BC_MAX_INST,
    bc_scan != bc_my_slot ? (
      lsb = BC_MY_REGION + bc_scan * BC_SLOT_SIZE;
      gmem[lsb + 1] == bc_following ? (
        bc_found_leader = 1;
        bc_follow_slot = bc_scan;
        lbase = lsb + 8;
        slider1 = gmem[lbase + 0];
        slider2 = gmem[lbase + 1];
        slider3 = gmem[lbase + 2];
        slider4 = gmem[lbase + 3];
        slider5 = gmem[lbase + 4];
        slider6 = gmem[lbase + 5];
        slider7 = gmem[lbase + 6];
        slider8 = gmem[lbase + 7];
        slider9 = gmem[lbase + 8];
        slider10 = gmem[lbase + 9];
        slider11 = gmem[lbase + 10];
        slider12 = gmem[lbase + 11];
        slider13 = gmem[lbase + 12];
        slider14 = gmem[lbase + 13];
        slider15 = gmem[lbase + 14];
        slider16 = gmem[lbase + 15];
        slider17 = gmem[lbase + 16];
        slider18 = gmem[lbase + 17];
        slider19 = gmem[lbase + 18];
        slider20 = gmem[lbase + 19];
        bc_scan = BC_MAX_INST;
      );
    );
    bc_scan += 1;
  );
  !bc_found_leader ? (
    bc_following = 0;
    bc_follow_slot = -1;
  );
);

bc_my_slot >= 0 && bc_steal_pending ? (
  bc_scan = 0;
  loop(BC_MAX_INST,
    lsb = BC_MY_REGION + bc_scan * BC_SLOT_SIZE;
    gmem[lsb + 1] == bc_steal_target ? (
      lbase = lsb + 8;
      slider1 = gmem[lbase + 0];
      slider2 = gmem[lbase + 1];
      slider3 = gmem[lbase + 2];
      slider4 = gmem[lbase + 3];
      slider5 = gmem[lbase + 4];
      slider6 = gmem[lbase + 5];
      slider7 = gmem[lbase + 6];
      slider8 = gmem[lbase + 7];
      slider9 = gmem[lbase + 8];
      slider10 = gmem[lbase + 9];
      slider11 = gmem[lbase + 10];
      slider12 = gmem[lbase + 11];
      slider13 = gmem[lbase + 12];
      slider14 = gmem[lbase + 13];
      slider15 = gmem[lbase + 14];
      slider16 = gmem[lbase + 15];
      slider17 = gmem[lbase + 16];
      slider18 = gmem[lbase + 17];
      slider19 = gmem[lbase + 18];
      slider20 = gmem[lbase + 19];
      bc_scan = BC_MAX_INST;
    );
    bc_scan += 1;
  );
  bc_steal_pending = 0;
  bc_steal_target = 0;
  bc_steal_mode = 0;
);

bc_my_slot >= 0 ? (
  sb = BC_MY_REGION + bc_my_slot * BC_SLOT_SIZE;
  gmem[sb + 0] += 1;
  gmem[sb + 3] = bc_following;
  pbase = sb + 8;
  gmem[pbase + 0] = slider1;
  gmem[pbase + 1] = slider2;
  gmem[pbase + 2] = slider3;
  gmem[pbase + 3] = slider4;
  gmem[pbase + 4] = slider5;
  gmem[pbase + 5] = slider6;
  gmem[pbase + 6] = slider7;
  gmem[pbase + 7] = slider8;
  gmem[pbase + 8] = slider9;
  gmem[pbase + 9] = slider10;
  gmem[pbase + 10] = slider11;
  gmem[pbase + 11] = slider12;
  gmem[pbase + 12] = slider13;
  gmem[pbase + 13] = slider14;
  gmem[pbase + 14] = slider15;
  gmem[pbase + 15] = slider16;
  gmem[pbase + 16] = slider17;
  gmem[pbase + 17] = slider18;
  gmem[pbase + 18] = slider19;
  gmem[pbase + 19] = slider20;
);

bc_instance_count = 0;
bc_scan = 0;
loop(BC_MAX_INST,
  tsb = BC_MY_REGION + bc_scan * BC_SLOT_SIZE;
  tsid = gmem[tsb + 1];
  tsid > 0 ? (
    bc_scan == bc_my_slot ? (
      bc_instance_count += 1;
    ) : (
      tshb = gmem[tsb + 0];
      tshb == BC_STALE_HB[bc_scan] ? (
        BC_STALE_CT[bc_scan] += samplesblock / srate;
        BC_STALE_CT[bc_scan] > BC_STALE_TIMEOUT ? (
          gmem[tsb + 1] = 0;
          BC_STALE_CT[bc_scan] = 0;
        );
      ) : (
        BC_STALE_HB[bc_scan] = tshb;
        BC_STALE_CT[bc_scan] = 0;
        bc_instance_count += 1;
      );
    );
  );
  bc_scan += 1;
);

@sample
  dry_l = spl0;
  dry_r = spl1;

  proc_l = spl0;
  proc_r = spl1;

  // === PRE-DELAY SATURATION ===
  (sat_on && sat_routing == 0) ? (
    apply_sat(proc_l, proc_r);
    proc_l = sat_out_l;
    proc_r = sat_out_r;
  );

  // === DRY ONLY SATURATION (saturate dry path, delay gets clean input) ===
  (sat_on && sat_routing == 1) ? (
    apply_sat(dry_l, dry_r);
    dry_l = sat_out_l;
    dry_r = sat_out_r;
  );

  // === DELAY SECTION ===
  delay_on ? (
    // Wow & Flutter modulation
    wow_phase += 0.5 / srate;
    wow_phase >= 1 ? wow_phase -= 1;
    flutter_phase += 6.3 / srate;
    flutter_phase >= 1 ? flutter_phase -= 1;

    wow_val = wow_phase < 0.5 ? (wow_phase * 4 - 1) : (3 - wow_phase * 4);
    flutter_val = sin(2 * $pi * flutter_phase);

    wow_mod = wow_val * wf_amount * 3.0 * srate / 1000;
    flutter_mod = flutter_val * wf_amount * 0.5 * srate / 1000;
    total_mod = wow_mod + flutter_mod;

    // Write to delay buffer (input + feedback with tape character)
    tape_in_l = proc_l + fb_l * intensity;
    tape_in_r = proc_r + fb_r * intensity;

    tape_age > 0.01 ? (
      tape_in_l = tape_char(tape_in_l, tape_age);
      tape_in_r = tape_char(tape_in_r, tape_age);
    );

    buf_l[wpos] = tape_in_l;
    buf_r[wpos] = tape_in_r;

    // Read from heads
    wet_l = 0; wet_r = 0;

    h1_on ? (
      rd = wpos - head1_delay - total_mod;
      rd < 0 ? rd += buf_max;
      rd >= buf_max ? rd -= buf_max;
      wet_l += lms_interp_cubic(buf_l, rd, buf_max);
      wet_r += lms_interp_cubic(buf_r, rd, buf_max);
    );

    h2_on ? (
      rd = wpos - head2_delay - total_mod;
      rd < 0 ? rd += buf_max;
      rd >= buf_max ? rd -= buf_max;
      wet_l += lms_interp_cubic(buf_l, rd, buf_max);
      wet_r += lms_interp_cubic(buf_r, rd, buf_max);
    );

    h3_on ? (
      rd = wpos - head3_delay - total_mod;
      rd < 0 ? rd += buf_max;
      rd >= buf_max ? rd -= buf_max;
      wet_l += lms_interp_cubic(buf_l, rd, buf_max);
      wet_r += lms_interp_cubic(buf_r, rd, buf_max);
    );

    wet_l /= num_heads;
    wet_r /= num_heads;

    // Feedback path: lowpass
    fb_lp_l = fb_lp_l * fb_lp_coeff + wet_l * (1 - fb_lp_coeff);
    fb_lp_r = fb_lp_r * fb_lp_coeff + wet_r * (1 - fb_lp_coeff);
    fb_l = fb_lp_l;
    fb_r = fb_lp_r;

    // Bass cut on wet
    bass < 0.99 ? (
      wet_l = wet_l - (wet_l * bass_hp_coeff + fb_lp_l * (1 - bass_hp_coeff)) * (1 - bass);
      wet_r = wet_r - (wet_r * bass_hp_coeff + fb_lp_r * (1 - bass_hp_coeff)) * (1 - bass);
    );

    // Echo volume
    wet_l *= echo_vol;
    wet_r *= echo_vol;

    // Spring Reverb (post echo)
    spring_mix > 0 ? (
      sp_in = (wet_l + wet_r) * 0.5;

      sp_in = lms_spring_ap(sp_ap1_buf, sp_ap1_pos, sp_ap1_len, sp_in, 0.6);
      sp_ap1_pos += 1; sp_ap1_pos >= sp_ap1_len ? sp_ap1_pos = 0;
      sp_in = lms_spring_ap(sp_ap2_buf, sp_ap2_pos, sp_ap2_len, sp_in, 0.6);
      sp_ap2_pos += 1; sp_ap2_pos >= sp_ap2_len ? sp_ap2_pos = 0;
      sp_in = lms_spring_ap(sp_ap3_buf, sp_ap3_pos, sp_ap3_len, sp_in, 0.55);
      sp_ap3_pos += 1; sp_ap3_pos >= sp_ap3_len ? sp_ap3_pos = 0;
      sp_in = lms_spring_ap(sp_ap4_buf, sp_ap4_pos, sp_ap4_len, sp_in, 0.55);
      sp_ap4_pos += 1; sp_ap4_pos >= sp_ap4_len ? sp_ap4_pos = 0;
      sp_in = lms_spring_ap(sp_ap5_buf, sp_ap5_pos, sp_ap5_len, sp_in, 0.5);
      sp_ap5_pos += 1; sp_ap5_pos >= sp_ap5_len ? sp_ap5_pos = 0;
      sp_in = lms_spring_ap(sp_ap6_buf, sp_ap6_pos, sp_ap6_len, sp_in, 0.5);
      sp_ap6_pos += 1; sp_ap6_pos >= sp_ap6_len ? sp_ap6_pos = 0;

      cm1_out = sp_cm1_buf[sp_cm1_pos];
      cm2_out = sp_cm2_buf[sp_cm2_pos];

      sp_lp_l = sp_lp_l * sp_damp_coeff + cm1_out * (1 - sp_damp_coeff);
      sp_lp_r = sp_lp_r * sp_damp_coeff + cm2_out * (1 - sp_damp_coeff);

      sp_cm1_buf[sp_cm1_pos] = sp_in + sp_lp_l * 0.45;
      sp_cm2_buf[sp_cm2_pos] = sp_in + sp_lp_r * 0.40;
      sp_cm1_pos += 1; sp_cm1_pos >= sp_cm1_len ? sp_cm1_pos = 0;
      sp_cm2_pos += 1; sp_cm2_pos >= sp_cm2_len ? sp_cm2_pos = 0;

      sp_out_l = cm1_out * 0.6 + cm2_out * 0.4;
      sp_out_r = cm1_out * 0.4 + cm2_out * 0.6;

      wet_l += sp_out_l * spring_mix;
      wet_r += sp_out_r * spring_mix;
    );

    // Advance write position
    wpos += 1;
    wpos >= buf_max ? wpos = 0;
  ) : (
    // Delay off: no wet signal from delay
    wet_l = 0;
    wet_r = 0;
  );

  // === WET ONLY SATURATION ===
  (sat_on && sat_routing == 2) ? (
    apply_sat(wet_l, wet_r);
    wet_l = sat_out_l;
    wet_r = sat_out_r;
  );

  // === Dry/Wet mix ===
  out_l = dry_l * (1 - dry_wet) + wet_l * dry_wet;
  out_r = dry_r * (1 - dry_wet) + wet_r * dry_wet;

  // === FINAL STAGE SATURATION (blended signal) ===
  (sat_on && sat_routing == 3) ? (
    apply_sat(out_l, out_r);
    out_l = sat_out_l;
    out_r = sat_out_r;
  );

  // === Output gain ===
  out_l *= out_gain;
  out_r *= out_gain;

  // === DC blocker ===
  out_l = dc.lms_dc_proc_l(out_l);
  out_r = dc.lms_dc_proc_r(out_r);

  spl0 = out_l;
  spl1 = out_r;

@gfx 580 480

// ============================================================================
//  SCALING — compute scale factor from actual window size vs nominal
// ============================================================================
gfx_ext_retina > 0 ? gfx_ext_retina = 1;
S = gfx_w / 580;
S < 0.5 ? S = 0.5;

// Scaled font sizes
F_TITLE = max(10, floor(22 * S));
F_LABEL = max(8, floor(12 * S));
F_SMALL = max(7, floor(11 * S));
F_TINY  = max(7, floor(10 * S));
// ============================================================================
//  COLOR CONSTANTS
// ============================================================================
COL_BG_R = 0.05; COL_BG_G = 0.05; COL_BG_B = 0.07;
COL_PANEL_R = 0.08; COL_PANEL_G = 0.08; COL_PANEL_B = 0.11;
COL_PANEL_HI_R = 0.12; COL_PANEL_HI_G = 0.12; COL_PANEL_HI_B = 0.16;
COL_BORDER_R = 0.20; COL_BORDER_G = 0.20; COL_BORDER_B = 0.25;
COL_TITLE_R = 0.95; COL_TITLE_G = 0.78; COL_TITLE_B = 0.35;
COL_SEC_R = 0.55; COL_SEC_G = 0.50; COL_SEC_B = 0.40;
COL_TEXT_R = 0.78; COL_TEXT_G = 0.78; COL_TEXT_B = 0.82;
COL_DIM_R = 0.38; COL_DIM_G = 0.38; COL_DIM_B = 0.42;
COL_ACCENT_R = 0.95; COL_ACCENT_G = 0.45; COL_ACCENT_B = 0.15;
COL_GREEN_R = 0.25; COL_GREEN_G = 0.80; COL_GREEN_B = 0.50;
COL_CYAN_R = 0.20; COL_CYAN_G = 0.60; COL_CYAN_B = 0.85;
COL_BAR_BG_R = 0.12; COL_BAR_BG_G = 0.12; COL_BAR_BG_B = 0.16;

// ============================================================================
//  BACKGROUND
// ============================================================================
hdr_h = floor(44 * S);
gfx_r = COL_BG_R; gfx_g = COL_BG_G; gfx_b = COL_BG_B;
gfx_rect(0, 0, gfx_w, gfx_h);
gfx_r = 0.03; gfx_g = 0.03; gfx_b = 0.05;
gfx_rect(0, 0, gfx_w, hdr_h);
gfx_r = COL_TITLE_R * 0.6; gfx_g = COL_TITLE_G * 0.6; gfx_b = COL_TITLE_B * 0.6;
gfx_rect(0, hdr_h, gfx_w, max(1, floor(2 * S)));

// ============================================================================
//  HELPER: draw_bar
// ============================================================================
function draw_bar(bx, by, bw, bh, val, vmin, vmax, label, show_val) (
  gfx_r = COL_BAR_BG_R; gfx_g = COL_BAR_BG_G; gfx_b = COL_BAR_BG_B;
  gfx_rect(bx, by, bw, bh);
  norm = (val - vmin) / (vmax - vmin);
  norm = max(0, min(1, norm));
  fill_w = norm * bw;
  fill_w > 0 ? (
    gfx_r = COL_CYAN_R * 0.6; gfx_g = COL_CYAN_G * 0.6; gfx_b = COL_CYAN_B * 0.6;
    gfx_rect(bx, by, fill_w, bh);
    gfx_r = COL_CYAN_R * 0.8; gfx_g = COL_CYAN_G * 0.8; gfx_b = COL_CYAN_B * 0.8;
    gfx_rect(bx, by, fill_w, floor(bh / 2));
    gfx_r = COL_CYAN_R; gfx_g = COL_CYAN_G; gfx_b = COL_CYAN_B;
    gfx_rect(bx, by, fill_w, 1);
  );
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_rect(bx, by, bw, 1); gfx_rect(bx, by + bh - 1, bw, 1);
  gfx_rect(bx, by, 1, bh); gfx_rect(bx + bw - 1, by, 1, bh);
  gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
  gfx_setfont(1, "Arial", F_LABEL);
  gfx_x = bx + floor(5 * S); gfx_y = by + floor((bh - F_LABEL) / 2);
  gfx_drawstr(label);
  show_val ? (
    gfx_setfont(1, "Arial", F_SMALL);
    gfx_x = bx + bw - floor(40 * S); gfx_y = by + floor((bh - F_SMALL) / 2);
    gfx_drawnumber(val, val == floor(val) ? 0 : 1);
  );
  mouse_cap & 1 ? (
    mouse_x >= bx && mouse_x <= bx + bw &&
    mouse_y >= by && mouse_y <= by + bh ? (
      new_norm = (mouse_x - bx) / bw;
      new_norm = max(0, min(1, new_norm));
      val = vmin + new_norm * (vmax - vmin);
    );
  );
  val;
);

// ============================================================================
//  HELPER: draw_panel
// ============================================================================
function draw_panel(px, py, pw, ph, title) (
  gfx_r = COL_PANEL_R; gfx_g = COL_PANEL_G; gfx_b = COL_PANEL_B;
  gfx_rect(px, py, pw, ph);
  gfx_r = COL_PANEL_HI_R; gfx_g = COL_PANEL_HI_G; gfx_b = COL_PANEL_HI_B;
  gfx_rect(px, py, pw, floor(22 * S));
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_rect(px, py + floor(22 * S), pw, 1);
  gfx_r = COL_BORDER_R * 0.7; gfx_g = COL_BORDER_G * 0.7; gfx_b = COL_BORDER_B * 0.7;
  gfx_rect(px, py, pw, 1); gfx_rect(px, py, 1, ph);
  gfx_rect(px + pw - 1, py, 1, ph); gfx_rect(px, py + ph - 1, pw, 1);
  gfx_r = COL_SEC_R; gfx_g = COL_SEC_G; gfx_b = COL_SEC_B;
  gfx_setfont(1, "Arial", F_LABEL);
  gfx_x = px + floor(8 * S); gfx_y = py + floor(4 * S);
  gfx_drawstr(title);
);

// ============================================================================
//  HELPER: draw_toggle
// ============================================================================
function draw_toggle(tx, ty, is_on, label) (
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_circle(tx + floor(8 * S), ty + floor(8 * S), floor(7 * S), 0);
  is_on ? (
    gfx_r = COL_GREEN_R; gfx_g = COL_GREEN_G; gfx_b = COL_GREEN_B;
    gfx_circle(tx + floor(8 * S), ty + floor(8 * S), floor(5 * S), 1);
  ) : (
    gfx_r = 0.15; gfx_g = 0.15; gfx_b = 0.18;
    gfx_circle(tx + floor(8 * S), ty + floor(8 * S), floor(5 * S), 1);
  );
  gfx_r = is_on ? COL_TEXT_R : COL_DIM_R;
  gfx_g = is_on ? COL_TEXT_G : COL_DIM_G;
  gfx_b = is_on ? COL_TEXT_B : COL_DIM_B;
  gfx_setfont(1, "Arial", F_SMALL);
  gfx_x = tx + floor(20 * S); gfx_y = ty + floor(1 * S);
  gfx_drawstr(label);
  (mouse_cap & 1) && !(last_cap & 1) &&
    mouse_x >= tx && mouse_x <= tx + floor(80 * S) &&
    mouse_y >= ty && mouse_y <= ty + floor(16 * S) ? (
      is_on = 1 - is_on;
  );
  is_on;
);

// ============================================================================
//  HELPER: draw_mode_sel — clickable mode selector (display string version)
// ============================================================================
function draw_mode_sel_str(mx, my, mw, mh, val, vmax, label, val_str) (
  gfx_r = COL_BAR_BG_R; gfx_g = COL_BAR_BG_G; gfx_b = COL_BAR_BG_B;
  gfx_rect(mx, my, mw, mh);
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_rect(mx, my, mw, 1); gfx_rect(mx, my + mh - 1, mw, 1);
  gfx_rect(mx, my, 1, mh); gfx_rect(mx + mw - 1, my, 1, mh);
  gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
  gfx_setfont(1, "Arial", F_LABEL);
  gfx_x = mx + floor(5 * S); gfx_y = my + floor((mh - F_LABEL) / 2);
  gfx_drawstr(label);
  gfx_r = COL_ACCENT_R; gfx_g = COL_ACCENT_G; gfx_b = COL_ACCENT_B;
  gfx_x = mx + mw - floor(72 * S); gfx_y = my + floor((mh - F_LABEL) / 2);
  gfx_drawstr(val_str);
  (mouse_cap & 1) && !(last_cap & 1) &&
    mouse_x >= mx && mouse_x <= mx + mw &&
    mouse_y >= my && mouse_y <= my + mh ? (
      val = (val + 1) % (vmax + 1);
  );
  (mouse_cap & 2) && !(last_cap & 2) &&
    mouse_x >= mx && mouse_x <= mx + mw &&
    mouse_y >= my && mouse_y <= my + mh ? (
      val = val - 1; val < 0 ? val = vmax;
  );
  val;
);

// ============================================================================
//  LAYOUT
// ============================================================================
margin = floor(8 * S);
gap = floor(6 * S);
bar_h = floor(18 * S);
bar_sp = floor(21 * S);
col_w = floor((gfx_w - margin * 2 - gap * 2) / 3);
pad = floor(4 * S);
pad2 = pad * 2;
gr_bar_h = max(2, floor(6 * S));
body_y = floor(50 * S);
panel_h = 186;
vis_y = body_y + panel_h + 8;

// ============================================================================
//  LOGO + TITLE
// ============================================================================
gfx_getimgdim(0, logo_img_w, logo_img_h);
logo_img_w > 0 ? (
  logo_h = floor(32 * S);
  logo_w = floor(logo_h * (logo_img_w / logo_img_h));
  logo_x = floor(6 * S);
  logo_y = floor(((hdr_h - logo_h)) / 2);
  gfx_blit(0, 1, 0, 0, 0, logo_img_w, logo_img_h, logo_x, logo_y, logo_w, logo_h);
) : (
  logo_w = 0;
  logo_x = 0;
);
gfx_r = COL_TITLE_R; gfx_g = COL_TITLE_G; gfx_b = COL_TITLE_B;
gfx_setfont(1, "Arial", F_TITLE);
gfx_x = logo_x + logo_w + floor(8 * S); gfx_y = floor(10 * S);
gfx_drawstr("LMS TAPE MACHINE");

// ============================================================================
//  COLUMN 1: SATURATION
// ============================================================================
c1x = margin;
draw_panel(c1x, body_y, col_w, panel_h, "SATURATION");
cy = body_y + floor(26 * S);
_old = slider1; slider1 = draw_toggle(c1x + pad2, cy + floor(2 * S), slider1, "Sat Enable");
slider1 != _old ? slider_automate(2^0);
cy += bar_sp;
_old = slider2; slider2 = draw_bar(c1x + pad, cy, col_w - pad2, bar_h, slider2, 0, 100, "Drive", 1);
slider2 != _old ? slider_automate(2^1);
cy += bar_sp;
// Sat Mode selector (5 modes: 0-4)
sat_mode_str = "Warm Tube";
slider3 == 1 ? sat_mode_str = "Hot Tube";
slider3 == 2 ? sat_mode_str = "Tape";
slider3 == 3 ? sat_mode_str = "Rectifier";
slider3 == 4 ? sat_mode_str = "Fuzz";
_old = slider3; slider3 = draw_mode_sel_str(c1x + pad, cy, col_w - pad2, bar_h, slider3, 4, "Mode", sat_mode_str);
slider3 != _old ? slider_automate(2^2);
cy += bar_sp;
_old = slider4; slider4 = draw_bar(c1x + pad, cy, col_w - pad2, bar_h, slider4, 0, 100, "Even", 1);
slider4 != _old ? slider_automate(2^3);
cy += bar_sp;
_old = slider5; slider5 = draw_bar(c1x + pad, cy, col_w - pad2, bar_h, slider5, 0, 100, "Odd", 1);
slider5 != _old ? slider_automate(2^4);
cy += bar_sp;
_old = slider6; slider6 = draw_bar(c1x + pad, cy, col_w - pad2, bar_h, slider6, 0, 100, "Bias", 1);
slider6 != _old ? slider_automate(2^5);
cy += bar_sp;
// Sat Routing selector (4 modes: 0-3)
routing_str = "Pre Delay";
slider7 == 1 ? routing_str = "Dry Only";
slider7 == 2 ? routing_str = "Wet Only";
slider7 == 3 ? routing_str = "Final";
_old = slider7; slider7 = draw_mode_sel_str(c1x + pad, cy, col_w - pad2, bar_h, slider7, 3, "Route", routing_str);
slider7 != _old ? slider_automate(2^6);

// ============================================================================
//  COLUMN 2: DELAY
// ============================================================================
c2x = margin + col_w + gap;
draw_panel(c2x, body_y, col_w, panel_h, "DELAY");
cy = body_y + floor(26 * S);
_old = slider8; slider8 = draw_toggle(c2x + pad2, cy + floor(2 * S), slider8, "Delay Enable");
slider8 != _old ? slider_automate(2^7);
cy += bar_sp;
// Head Mode selector (7 modes: 0-6)
head_str = "Head 1";
slider9 == 1 ? head_str = "Head 2";
slider9 == 2 ? head_str = "Head 3";
slider9 == 3 ? head_str = "Hd 1+2";
slider9 == 4 ? head_str = "Hd 1+3";
slider9 == 5 ? head_str = "Hd 2+3";
slider9 == 6 ? head_str = "All Hd";
_old = slider9; slider9 = draw_mode_sel_str(c2x + pad, cy, col_w - pad2, bar_h, slider9, 6, "Head", head_str);
slider9 != _old ? slider_automate(2^8);
cy += bar_sp;
_old = slider10; slider10 = draw_bar(c2x + pad, cy, col_w - pad2, bar_h, slider10, 50, 1000, "Rate ms", 1);
slider10 != _old ? slider_automate(2^9);
cy += bar_sp;
_old = slider11; slider11 = draw_bar(c2x + pad, cy, col_w - pad2, bar_h, slider11, 0, 100, "Intens", 1);
slider11 != _old ? slider_automate(2^10);
cy += bar_sp;
_old = slider12; slider12 = draw_bar(c2x + pad, cy, col_w - pad2, bar_h, slider12, 0, 100, "Echo Vol", 1);
slider12 != _old ? slider_automate(2^11);
cy += bar_sp;
_old = slider13; slider13 = draw_bar(c2x + pad, cy, col_w - pad2, bar_h, slider13, 0, 100, "W&F", 1);
slider13 != _old ? slider_automate(2^12);
cy += bar_sp;
_old = slider14; slider14 = draw_bar(c2x + pad, cy, col_w - pad2, bar_h, slider14, 0, 100, "Age", 1);
slider14 != _old ? slider_automate(2^13);

// ============================================================================
//  COLUMN 3: TONE / MIX
// ============================================================================
c3x = margin + (col_w + gap) * 2;
draw_panel(c3x, body_y, col_w, panel_h, "TONE / MIX");
cy = body_y + floor(26 * S);
_old = slider15; slider15 = draw_bar(c3x + pad, cy, col_w - pad2, bar_h, slider15, 0, 100, "Bass", 1);
slider15 != _old ? slider_automate(2^14);
cy += bar_sp;
_old = slider16; slider16 = draw_bar(c3x + pad, cy, col_w - pad2, bar_h, slider16, 0, 100, "Treble", 1);
slider16 != _old ? slider_automate(2^15);
cy += bar_sp;
_old = slider17; slider17 = draw_bar(c3x + pad, cy, col_w - pad2, bar_h, slider17, 20, 20000, "Tone Hz", 1);
slider17 != _old ? slider_automate(2^16);
cy += bar_sp;
_old = slider18; slider18 = draw_bar(c3x + pad, cy, col_w - pad2, bar_h, slider18, 0, 100, "Spring", 1);
slider18 != _old ? slider_automate(2^17);
cy += bar_sp;
_old = slider19; slider19 = draw_bar(c3x + pad, cy, col_w - pad2, bar_h, slider19, -12, 12, "Output", 1);
slider19 != _old ? slider_automate(2^18);
cy += bar_sp;
_old = slider20; slider20 = draw_bar(c3x + pad, cy, col_w - pad2, bar_h, slider20, 0, 100, "Dry/Wet", 1);
slider20 != _old ? slider_automate(2^19);

// ============================================================================
//  VISUALIZATION AREA (below the three columns)
// ============================================================================
vis_h = gfx_h - vis_y - 40;

// --- Tape reels (only when delay is on) ---
delay_on ? (
  reel_angle += 0.02 + intensity * 0.03;
  reel_angle >= 2 * $pi ? reel_angle -= 2 * $pi;

  // Position reels in the visualization area
  sat_on ? (
    // When both are on, reels on left half, curve on right half
    reel_cx1 = margin + col_w * 0.45;
    reel_cx2 = margin + col_w * 1.15;
  ) : (
    // Reels centered across full width
    reel_cx1 = gfx_w * 0.3;
    reel_cx2 = gfx_w * 0.7;
  );
  reel_cy = vis_y + vis_h * 0.55;
  reel_r = min(vis_h * 0.38, 40);

  // Left reel
  gfx_r = 0.14; gfx_g = 0.14; gfx_b = 0.18;
  gfx_circle(reel_cx1, reel_cy, reel_r, 1);
  gfx_r = 0.08; gfx_g = 0.08; gfx_b = 0.10;
  gfx_circle(reel_cx1, reel_cy, reel_r * 0.4, 1);
  gfx_r = COL_CYAN_R; gfx_g = COL_CYAN_G; gfx_b = COL_CYAN_B;
  i = 0;
  loop(3,
    a = reel_angle + i * 2 * $pi / 3;
    gfx_line(reel_cx1, reel_cy,
             reel_cx1 + cos(a) * reel_r * 0.85,
             reel_cy + sin(a) * reel_r * 0.85);
    i += 1;
  );

  // Right reel
  gfx_r = 0.14; gfx_g = 0.14; gfx_b = 0.18;
  gfx_circle(reel_cx2, reel_cy, reel_r, 1);
  gfx_r = 0.08; gfx_g = 0.08; gfx_b = 0.10;
  gfx_circle(reel_cx2, reel_cy, reel_r * 0.4, 1);
  gfx_r = COL_CYAN_R; gfx_g = COL_CYAN_G; gfx_b = COL_CYAN_B;
  i = 0;
  loop(3,
    a = -reel_angle + i * 2 * $pi / 3;
    gfx_line(reel_cx2, reel_cy,
             reel_cx2 + cos(a) * reel_r * 0.85,
             reel_cy + sin(a) * reel_r * 0.85);
    i += 1;
  );

  // Tape path between reels
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  tape_y = reel_cy - reel_r - 5;
  gfx_line(reel_cx1, tape_y, reel_cx2, tape_y);

  // Head indicators
  head_y = tape_y - 12;
  head_spacing = (reel_cx2 - reel_cx1) / 4;

  h1_on ? ( gfx_r = COL_GREEN_R; gfx_g = COL_GREEN_G; gfx_b = COL_GREEN_B; )
        : ( gfx_r = 0.15; gfx_g = 0.15; gfx_b = 0.18; );
  hx = reel_cx1 + head_spacing;
  gfx_rect(hx - 4, head_y - 6, 8, 12);
  gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
  gfx_x = hx - 2; gfx_y = head_y - 18;
  gfx_setfont(1, "Arial", F_TINY);
  gfx_drawstr("1");

  h2_on ? ( gfx_r = COL_GREEN_R; gfx_g = COL_GREEN_G; gfx_b = COL_GREEN_B; )
        : ( gfx_r = 0.15; gfx_g = 0.15; gfx_b = 0.18; );
  hx = reel_cx1 + head_spacing * 2;
  gfx_rect(hx - 4, head_y - 6, 8, 12);
  gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
  gfx_x = hx - 2; gfx_y = head_y - 18;
  gfx_drawstr("2");

  h3_on ? ( gfx_r = COL_GREEN_R; gfx_g = COL_GREEN_G; gfx_b = COL_GREEN_B; )
        : ( gfx_r = 0.15; gfx_g = 0.15; gfx_b = 0.18; );
  hx = reel_cx1 + head_spacing * 3;
  gfx_rect(hx - 4, head_y - 6, 8, 12);
  gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
  gfx_x = hx - 2; gfx_y = head_y - 18;
  gfx_drawstr("3");
);

// --- Transfer curve (when sat is on) ---
sat_on ? (
  delay_on ? (
    // When both on, curve on right half
    tc_x = c3x + 10;
    tc_w = col_w - 20;
  ) : (
    // Curve centered
    tc_x = gfx_w / 2 - 50;
    tc_w = 100;
  );
  tc_y = vis_y + 4;
  tc_h = vis_h - 8;

  // Box background
  gfx_r = COL_PANEL_R; gfx_g = COL_PANEL_G; gfx_b = COL_PANEL_B;
  gfx_rect(tc_x, tc_y, tc_w, tc_h);

  // Center lines
  gfx_r = COL_BORDER_R * 0.6; gfx_g = COL_BORDER_G * 0.6; gfx_b = COL_BORDER_B * 0.6;
  gfx_line(tc_x, tc_y + tc_h/2, tc_x + tc_w, tc_y + tc_h/2);
  gfx_line(tc_x + tc_w/2, tc_y, tc_x + tc_w/2, tc_y + tc_h);

  // Diagonal reference
  gfx_r = COL_BORDER_R * 0.5; gfx_g = COL_BORDER_G * 0.5; gfx_b = COL_BORDER_B * 0.5;
  gfx_line(tc_x, tc_y + tc_h, tc_x + tc_w, tc_y);

  // Curve
  gfx_r = COL_ACCENT_R; gfx_g = COL_ACCENT_G; gfx_b = COL_ACCENT_B;
  i = 0;
  loop(50,
    in = (i / 49) * 2 - 1;

    sat_mode == 0 ? out = lms_tanh(in * (1 + sat_drive) * 1.2) * 0.85;
    sat_mode == 1 ? out = lms_tanh(in * (1 + sat_drive * 2) * 1.8) * 0.75;
    sat_mode == 2 ? out = lms_tanh(in * (1 + sat_drive * 1.5) * 0.8) * 0.95;
    sat_mode == 3 ? out = lms_tanh(in * (1 + sat_drive * 3) * 2.0) * 0.70;
    sat_mode == 4 ? out = lms_tanh(in * (1 + sat_drive * 4) * 2.5) * 0.60;

    out = max(-1, min(1, out));

    px = tc_x + (in + 1) * 0.5 * tc_w;
    py = tc_y + tc_h - (out + 1) * 0.5 * tc_h;

    i == 0 ? (
      gfx_x = px; gfx_y = py;
    ) : (
      gfx_lineto(px, py);
    );

    i += 1;
  );

  // Drive meter (small, next to curve)
  gfx_r = COL_BAR_BG_R; gfx_g = COL_BAR_BG_G; gfx_b = COL_BAR_BG_B;
  gfx_rect(tc_x - 12, tc_y, 8, tc_h);
  fill_h = sat_drive * tc_h;
  sat_drive < 0.5 ? (
    gfx_r = COL_GREEN_R; gfx_g = COL_GREEN_G; gfx_b = COL_GREEN_B;
  ) : sat_drive < 0.8 ? (
    gfx_r = COL_TITLE_R; gfx_g = COL_TITLE_G; gfx_b = COL_TITLE_B;
  ) : (
    gfx_r = COL_ACCENT_R; gfx_g = COL_ACCENT_G * 0.4; gfx_b = 0.1;
  );
  gfx_rect(tc_x - 12, tc_y + tc_h - fill_h, 8, fill_h);
);
  // ============================================================
  // INSTANCE MANAGER PANEL
  // ============================================================
  bc_rows_per_page = 5;
  bc_row_h = floor(14 * S);
  bc_bar_h = floor(30 * S);
  bc_btn_h = floor(20 * S);
  bc_panel_h = bc_panel_expanded ? (bc_bar_h + bc_rows_per_page * bc_row_h + floor(18 * S)) : bc_bar_h;
  bc_panel_y = gfx_h - bc_panel_h;

  gfx_r = 0.04; gfx_g = 0.04; gfx_b = 0.06;
  gfx_rect(0, bc_panel_y, gfx_w, bc_panel_h);
  gfx_r = 0.15; gfx_g = 0.15; gfx_b = 0.20;
  gfx_rect(0, bc_panel_y, gfx_w, 1);

  gfx_setfont(1, "Arial", F_SMALL);
  gfx_r = 0.95; gfx_g = 0.45; gfx_b = 0.15;
  gfx_x = floor(8 * S); gfx_y = bc_panel_y + floor(8 * S);
  bc_my_slot >= 0 ? (
    gfx_drawstr("I");
    gfx_drawnumber(bc_my_slot + 1, 0);
    gfx_drawstr("/");
    gfx_drawnumber(bc_instance_count, 0);
  ) : (
    gfx_drawstr("--");
  );

  bc_following > 0 ? (
    gfx_r = 0.2; gfx_g = 0.8; gfx_b = 0.3;
    gfx_drawstr("  Following: I");
    bc_fs = 0;
    loop(BC_MAX_INST,
      fsb = BC_MY_REGION + bc_fs * BC_SLOT_SIZE;
      gmem[fsb + 1] == bc_following ? (
        gfx_drawnumber(bc_fs + 1, 0);
        bc_fs = BC_MAX_INST;
      );
      bc_fs += 1;
    );
  ) : (
    gfx_r = 0.3; gfx_g = 0.3; gfx_b = 0.4;
    gfx_drawstr("  Following: --");
  );

  exp_x = gfx_w - floor(200 * S);
  exp_y = bc_panel_y + floor(4 * S);
  exp_w = floor(65 * S);
  exp_h = floor(20 * S);
  gfx_r = 0.12; gfx_g = 0.12; gfx_b = 0.16;
  gfx_rect(exp_x, exp_y, exp_w, exp_h);
  gfx_r = 0.5; gfx_g = 0.5; gfx_b = 0.6;
  gfx_x = exp_x + floor(5 * S); gfx_y = exp_y + floor(4 * S);
  bc_panel_expanded ? gfx_drawstr("COLLAPSE") : gfx_drawstr("EXPAND");
  (mouse_cap & 1) && !(last_cap & 1) &&
    mouse_x >= exp_x && mouse_x < exp_x + exp_w &&
    mouse_y >= exp_y && mouse_y < exp_y + exp_h ? (
    bc_panel_expanded = !bc_panel_expanded;
    bc_steal_mode = 0;
  );

  stl_x = gfx_w - floor(125 * S);
  stl_y = bc_panel_y + floor(4 * S);
  stl_w = floor(50 * S);
  stl_h = floor(20 * S);
  bc_steal_mode ? (
    gfx_r = 0.6; gfx_g = 0.2; gfx_b = 0.1;
  ) : (
    gfx_r = 0.2; gfx_g = 0.1; gfx_b = 0.1;
  );
  gfx_rect(stl_x, stl_y, stl_w, stl_h);
  gfx_r = 0.9; gfx_g = 0.5; gfx_b = 0.2;
  gfx_x = stl_x + floor(6 * S); gfx_y = stl_y + floor(4 * S);
  gfx_drawstr("STEAL");
  (mouse_cap & 1) && !(last_cap & 1) &&
    mouse_x >= stl_x && mouse_x < stl_x + stl_w &&
    mouse_y >= stl_y && mouse_y < stl_y + stl_h ? (
    bc_steal_mode = !bc_steal_mode;
    !bc_panel_expanded ? bc_panel_expanded = 1;
  );

  bc_following > 0 ? (
    unf_x = gfx_w - floor(65 * S);
    unf_y = bc_panel_y + floor(4 * S);
    unf_w = floor(55 * S);
    unf_h = floor(20 * S);
    gfx_r = 0.1; gfx_g = 0.2; gfx_b = 0.1;
    gfx_rect(unf_x, unf_y, unf_w, unf_h);
    gfx_r = 0.5; gfx_g = 0.9; gfx_b = 0.5;
    gfx_x = unf_x + floor(4 * S); gfx_y = unf_y + floor(4 * S);
    gfx_drawstr("UNFLW");
    (mouse_cap & 1) && !(last_cap & 1) &&
      mouse_x >= unf_x && mouse_x < unf_x + unf_w &&
      mouse_y >= unf_y && mouse_y < unf_y + unf_h ? (
      bc_following = 0;
      bc_follow_slot = -1;
    );
  );

  bc_panel_expanded ? (
    row_y = bc_panel_y + bc_bar_h;
    row_h = bc_row_h;

    // Page nav — auto-scroll to show YOU on expand
    bc_my_page = bc_my_slot >= 0 ? floor(bc_my_slot / bc_rows_per_page) : 0;
    bc_page < 0 ? bc_page = 0;

    // Count active slots for page count
    bc_active_slots = 0;
    bc_si = 0;
    loop(BC_MAX_INST,
      gmem[BC_MY_REGION + bc_si * BC_SLOT_SIZE + 1] > 0 ? bc_active_slots += 1;
      bc_si += 1;
    );
    bc_total_pages = max(1, ceil(bc_active_slots / bc_rows_per_page));
    bc_page >= bc_total_pages ? bc_page = bc_total_pages - 1;

    // Prev page button
    pg_btn_w = floor(18 * S); pg_btn_h = floor(14 * S);
    pg_prev_x = floor(8 * S); pg_prev_y = bc_panel_y + bc_bar_h + bc_rows_per_page * row_h + floor(2 * S);
    bc_total_pages > 1 ? (
      gfx_r = 0.25; gfx_g = 0.25; gfx_b = 0.32;
      gfx_rect(pg_prev_x, pg_prev_y, pg_btn_w, pg_btn_h);
      gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.8;
      gfx_x = pg_prev_x + floor(4 * S); gfx_y = pg_prev_y + floor(2 * S);
      gfx_drawstr("<");
      (mouse_cap & 1) && !(last_cap & 1) &&
        mouse_x >= pg_prev_x && mouse_x < pg_prev_x + pg_btn_w &&
        mouse_y >= pg_prev_y && mouse_y < pg_prev_y + pg_btn_h ? (
        bc_page > 0 ? bc_page -= 1;
      );

      gfx_r = 0.25; gfx_g = 0.25; gfx_b = 0.32;
      gfx_rect(pg_prev_x + pg_btn_w + 2, pg_prev_y, pg_btn_w, pg_btn_h);
      gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.8;
      gfx_x = pg_prev_x + pg_btn_w + floor(6 * S); gfx_y = pg_prev_y + floor(2 * S);
      gfx_drawstr(">");
      (mouse_cap & 1) && !(last_cap & 1) &&
        mouse_x >= pg_prev_x + pg_btn_w + 2 && mouse_x < pg_prev_x + pg_btn_w * 2 + 2 &&
        mouse_y >= pg_prev_y && mouse_y < pg_prev_y + pg_btn_h ? (
        bc_page < bc_total_pages - 1 ? bc_page += 1;
      );

      // Page indicator
      gfx_r = 0.4; gfx_g = 0.4; gfx_b = 0.5;
      gfx_x = pg_prev_x + pg_btn_w * 2 + floor(8 * S); gfx_y = pg_prev_y + floor(2 * S);
      gfx_drawnumber(bc_page + 1, 0);
      gfx_drawstr("/");
      gfx_drawnumber(bc_total_pages, 0);

      // YOU button — jump to your page
      bc_page != bc_my_page ? (
        you_x = pg_prev_x + pg_btn_w * 2 + floor(40 * S);
        gfx_r = 0.15; gfx_g = 0.15; gfx_b = 0.20;
        gfx_rect(you_x, pg_prev_y, floor(30 * S), pg_btn_h);
        gfx_r = 0.95; gfx_g = 0.45; gfx_b = 0.15;
        gfx_x = you_x + floor(3 * S); gfx_y = pg_prev_y + floor(2 * S);
        gfx_drawstr("YOU");
        (mouse_cap & 1) && !(last_cap & 1) &&
          mouse_x >= you_x && mouse_x < you_x + floor(30 * S) &&
          mouse_y >= pg_prev_y && mouse_y < pg_prev_y + pg_btn_h ? (
          bc_page = bc_my_page;
        );
      );
    );

    // Draw rows for current page
    bc_page_start = bc_page * bc_rows_per_page;
    bc_page_end = bc_page_start + bc_rows_per_page - 1;
    bc_visible = 0;
    bc_s = 0;
    loop(BC_MAX_INST,
      isb = BC_MY_REGION + bc_s * BC_SLOT_SIZE;
      isid = gmem[isb + 1];

      isid > 0 ? (
        bc_visible >= bc_page_start && bc_visible <= bc_page_end ? (
          draw_row_y = row_y + (bc_visible - bc_page_start) * row_h;

          mouse_y >= draw_row_y && mouse_y < draw_row_y + row_h &&
            mouse_x >= floor(8 * S) && mouse_x < gfx_w - floor(8 * S) &&
            bc_s != bc_my_slot ? (
            gfx_r = 0.10; gfx_g = 0.10; gfx_b = 0.14;
            gfx_rect(floor(4 * S), draw_row_y, gfx_w - floor(8 * S), row_h);
          );

          gfx_setfont(1, "Arial", F_TINY);
          bc_s == bc_my_slot ? (
            gfx_r = 0.95; gfx_g = 0.45; gfx_b = 0.15;
          ) : (
            gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.8;
          );
          gfx_x = floor(12 * S); gfx_y = draw_row_y + floor(1 * S);
          gfx_drawstr("I");
          gfx_drawnumber(bc_s + 1, 0);
          gfx_drawstr("  ");

          bc_s == bc_my_slot ? (
            gfx_drawstr("[YOU]");
          ) : (
            iwho = gmem[isb + 3];
            // Check if anyone is following this instance
            bc_has_follower = 0;
            bc_fsc = 0;
            loop(BC_MAX_INST,
              fsb2 = BC_MY_REGION + bc_fsc * BC_SLOT_SIZE;
              gmem[fsb2 + 1] > 0 && gmem[fsb2 + 3] == isid ? bc_has_follower = 1;
              bc_fsc += 1;
            );
            iwho > 0 ? (
              // This instance is following someone — FOLLOWER
              gfx_r = 0.4; gfx_g = 0.6; gfx_b = 0.9;
              gfx_drawstr("[FOLLOWER]");
            ) : bc_has_follower ? (
              // Someone is following this instance — LEADER
              gfx_r = 0.95; gfx_g = 0.78; gfx_b = 0.35;
              gfx_drawstr("[LEADER]");
            ) : (
              // Nobody following, not following anyone — UNASSIGNED
              gfx_r = 0.38; gfx_g = 0.38; gfx_b = 0.45;
              gfx_drawstr("[UNASSIGNED]");
            );
            gfx_r = 0.35; gfx_g = 0.45; gfx_b = 0.35;
            bc_steal_mode ? (
              gfx_drawstr("  click: steal");
            ) : (
              gfx_drawstr("  click: follow");
            );
            (mouse_cap & 1) && !(last_cap & 1) &&
              mouse_y >= draw_row_y && mouse_y < draw_row_y + row_h &&
              mouse_x >= floor(8 * S) && mouse_x < gfx_w - floor(8 * S) ? (
              bc_steal_mode ? (
                bc_steal_target = isid;
                bc_steal_pending = 1;
                bc_steal_mode = 0;
              ) : (
                bc_can_follow = 1;
                bc_cursor = isid;
                bc_hops = 0;
                while(bc_cursor > 0 && bc_hops < BC_MAX_INST) (
                  bc_cursor == bc_my_id ? (
                    bc_can_follow = 0;
                    bc_cursor = 0;
                  ) : (
                    bc_next = 0;
                    bc_cs = 0;
                    loop(BC_MAX_INST,
                      csb = BC_MY_REGION + bc_cs * BC_SLOT_SIZE;
                      gmem[csb + 1] == bc_cursor ? (
                        bc_next = gmem[csb + 3];
                        bc_cs = BC_MAX_INST;
                      );
                      bc_cs += 1;
                    );
                    bc_cursor = bc_next;
                  );
                  bc_hops += 1;
                );
                bc_can_follow ? (
                  bc_following = isid;
                );
              );
            );
          );
        );
        bc_visible += 1;
      );
      bc_s += 1;
    );
  );

  last_cap = mouse_cap;

  // --- BUY + NOTICE BUTTONS ---
  notice_btn_x = gfx_w - floor(60 * S);
  notice_btn_y = bc_panel_y - floor(18 * S);
  buy_btn_x = notice_btn_x - floor(50 * S);
  buy_btn_y = notice_btn_y;
  gfx_r = 0.6; gfx_g = 0.5; gfx_b = 0.3;
  gfx_rect(buy_btn_x, buy_btn_y, floor(45 * S), floor(15 * S));
  gfx_r = 0; gfx_g = 0; gfx_b = 0;
  gfx_x = buy_btn_x + floor(4 * S); gfx_y = buy_btn_y + floor(2 * S);
  gfx_drawstr("BUY");
  (mouse_cap & 1) && mouse_x >= buy_btn_x && mouse_x <= buy_btn_x + floor(45 * S) && mouse_y >= buy_btn_y && mouse_y <= buy_btn_y + floor(15 * S) && !buy_clicked ? (
    buy_show = !buy_show; buy_show ? notice_show = 0;
    buy_clicked = 1;
  );
  !(mouse_cap & 1) ? buy_clicked = 0;
  gfx_r = 0.6; gfx_g = 0.5; gfx_b = 0.3;
  gfx_rect(notice_btn_x, notice_btn_y, floor(55 * S), floor(15 * S));
  gfx_r = 0; gfx_g = 0; gfx_b = 0;
  gfx_x = notice_btn_x + floor(4 * S); gfx_y = notice_btn_y + floor(2 * S);
  gfx_drawstr("NOTICE");
  (mouse_cap & 1) && mouse_x >= notice_btn_x && mouse_x <= notice_btn_x + floor(55 * S) && mouse_y >= notice_btn_y && mouse_y <= notice_btn_y + floor(15 * S) && !notice_clicked ? (
    notice_show = !notice_show; notice_show ? buy_show = 0;
    notice_clicked = 1;
  );
  !(mouse_cap & 1) ? notice_clicked = 0;
  buy_show ? (
    gfx_r = 0.05; gfx_g = 0.05; gfx_b = 0.05; gfx_a = 0.95;
    gfx_rect(0, 0, gfx_w, gfx_h); gfx_a = 1;
    gfx_r = 0.9; gfx_g = 0.8; gfx_b = 0.5;
    gfx_x = floor(15 * S); gfx_y = floor(10 * S);
    gfx_drawstr("SUPPORT LMS");
    gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.7;
    gfx_x = floor(15 * S); gfx_y = floor(35 * S);
    gfx_drawstr("These plugins are offered for free use by anyone not able to afford it.");
    gfx_x = floor(15 * S); gfx_y = floor(50 * S);
    gfx_drawstr("No need to prove anything to us. But if you can afford to buy this suite,");
    gfx_x = floor(15 * S); gfx_y = floor(65 * S);
    gfx_drawstr("we would sure appreciate it. 50 dollars gets you every update and every");
    gfx_x = floor(15 * S); gfx_y = floor(80 * S);
    gfx_drawstr("plugin added to this suite forever. Its in its baby stages and these will");
    gfx_x = floor(15 * S); gfx_y = floor(95 * S);
    gfx_drawstr("only get doper over time. We also offer 6 months installments. But if you");
    gfx_x = floor(15 * S); gfx_y = floor(110 * S);
    gfx_drawstr("dont have the money, dont sweat it, you can use as much and as long as");
    gfx_x = floor(15 * S); gfx_y = floor(125 * S);
    gfx_drawstr("you like. Hail Satan. - LMS");
    gfx_r = 0.5; gfx_g = 0.7; gfx_b = 1.0;
    gfx_x = floor(15 * S); gfx_y = floor(150 * S);
    gfx_drawstr("bryanleaf.gumroad.com/l/zzgmzx");
    gfx_r = 0.6; gfx_g = 0.5; gfx_b = 0.3;
    gfx_rect(buy_btn_x, buy_btn_y, floor(45 * S), floor(15 * S));
    gfx_rect(notice_btn_x, notice_btn_y, floor(55 * S), floor(15 * S));
    gfx_r = 0; gfx_g = 0; gfx_b = 0;
    gfx_x = buy_btn_x + floor(4 * S); gfx_y = buy_btn_y + floor(2 * S);
    gfx_drawstr("BUY");
    gfx_x = notice_btn_x + floor(4 * S); gfx_y = notice_btn_y + floor(2 * S);
    gfx_drawstr("NOTICE");
  );
  notice_show ? (
    gfx_r = 0.05; gfx_g = 0.05; gfx_b = 0.05; gfx_a = 0.95;
    gfx_rect(0, 0, gfx_w, gfx_h); gfx_a = 1;
    gfx_r = 0.9; gfx_g = 0.8; gfx_b = 0.5;
    gfx_x = floor(15 * S); gfx_y = floor(10 * S);
    gfx_drawstr("NOTICE: THEY ARE TRYING TO STEAL YOUR COMPUTER");
    gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.7;
    gfx_x = floor(15 * S); gfx_y = floor(30 * S);
    gfx_drawstr("The algorithms in our favorite software are decades old.");
    gfx_x = floor(15 * S); gfx_y = floor(45 * S);
    gfx_drawstr("A mathematical model is a truth about the world,");
    gfx_x = floor(15 * S); gfx_y = floor(60 * S);
    gfx_drawstr("not a copyrightable product. You do not have to stay");
    gfx_x = floor(15 * S); gfx_y = floor(75 * S);
    gfx_drawstr("a slave to subscription software. Install Linux.");
    gfx_x = floor(15 * S); gfx_y = floor(90 * S);
    gfx_drawstr("Build your own tools. Believe in yourself.");
    gfx_r = 0.5; gfx_g = 0.7; gfx_b = 1.0;
    gfx_x = floor(15 * S); gfx_y = floor(115 * S);
    gfx_drawstr("github.com/LMSBAND  |  instagram.com/LMSSKABAND");
    gfx_r = 0.6; gfx_g = 0.5; gfx_b = 0.3;
    gfx_rect(buy_btn_x, buy_btn_y, floor(45 * S), floor(15 * S));
    gfx_rect(notice_btn_x, notice_btn_y, floor(55 * S), floor(15 * S));
    gfx_r = 0; gfx_g = 0; gfx_b = 0;
    gfx_x = buy_btn_x + floor(4 * S); gfx_y = buy_btn_y + floor(2 * S);
    gfx_drawstr("BUY");
    gfx_x = notice_btn_x + floor(4 * S); gfx_y = notice_btn_y + floor(2 * S);
    gfx_drawstr("NOTICE");
  );

// ============================================================
// @SERIALIZE — Persist follow state
// ============================================================
@serialize
file_var(0, bc_following);
file_var(0, bc_my_id);
