desc:PEQ4U
//tags: equalizer passive analog tube
//author: LMS + Claude

options:gmem=DrumBanger

// Classic Passive EQ emulation
// - Low boost + cut interact (slightly offset frequencies = the magic dip-and-bump)
// - High boost with bandwidth control
// - High cut (gentle rolloff)
// - Tube saturation stage

slider1:0<0,10,0.1>Low Boost
slider2:0<0,10,0.1>Low Atten
slider3:2<0,3,1{20,30,60,100}>Low Freq
slider4:0<0,10,0.1>High Boost
slider5:5<1,10,1>High Boost BW (Broad-Sharp)
slider6:0<0,10,0.1>High Atten (Cut)
slider7:2<0,4,1{3k,4k,5k,8k,10k,12k,16k}>High Boost Freq
slider8:0<0,1,1{Off,On}>Tube Saturation
slider9:0<-12,12,0.1>Output (dB)

@init
// Biquad filter states (L and R for each band)
// Low boost: 0-3 = L state, 4-7 = R state
// Low cut: 8-15
// High boost: 16-23
// High cut: 24-31

// Low boost filter state
lb_xl1 = 0; lb_xl2 = 0; lb_yl1 = 0; lb_yl2 = 0;
lb_xr1 = 0; lb_xr2 = 0; lb_yr1 = 0; lb_yr2 = 0;

// Low cut filter state
lc_xl1 = 0; lc_xl2 = 0; lc_yl1 = 0; lc_yl2 = 0;
lc_xr1 = 0; lc_xr2 = 0; lc_yr1 = 0; lc_yr2 = 0;

// High boost filter state
hb_xl1 = 0; hb_xl2 = 0; hb_yl1 = 0; hb_yl2 = 0;
hb_xr1 = 0; hb_xr2 = 0; hb_yr1 = 0; hb_yr2 = 0;

// High cut filter state
hc_xl1 = 0; hc_xl2 = 0; hc_yl1 = 0; hc_yl2 = 0;
hc_xr1 = 0; hc_xr2 = 0; hc_yr1 = 0; hc_yr2 = 0;

// Filter coefficients
lb_b0 = 1; lb_b1 = 0; lb_b2 = 0; lb_a1 = 0; lb_a2 = 0;
lc_b0 = 1; lc_b1 = 0; lc_b2 = 0; lc_a1 = 0; lc_a2 = 0;
hb_b0 = 1; hb_b1 = 0; hb_b2 = 0; hb_a1 = 0; hb_a2 = 0;
hc_b0 = 1; hc_b1 = 0; hc_b2 = 0; hc_a1 = 0; hc_a2 = 0;

notice_show = 0;

  // ============================================================
  // BROADCAST SYSTEM — Instance Registry
  // ============================================================
  BC_BASE = 100000;
  BC_MY_TYPE = 6;           // Passive EQ
  BC_SLOT_SIZE = 512;
  BC_MAX_INST = 8;
  BC_PARAM_COUNT = 9;
  BC_MY_REGION = BC_BASE + BC_MY_TYPE * 4096;
  BC_STALE_TIMEOUT = 2;

  // Generate unique instance ID (only on first init, preserve across transport stop/start)
  bc_my_id == 0 ? bc_my_id = floor(rand() * 1073741824) + 1;
  bc_my_slot = -1;
  // bc_following preserved by @serialize — do NOT zero here
  bc_follow_slot = -1;
  bc_steal_pending = 0;
  bc_steal_target = 0;
  bc_panel_expanded = 0;
  bc_steal_mode = 0;
  bc_instance_count = 0;

  BC_STALE_HB = 10000;
  BC_STALE_CT = 10008;
  i = 0;
  loop(BC_MAX_INST,
    BC_STALE_HB[i] = -1;
    BC_STALE_CT[i] = 0;
    i += 1;
  );

  bc_i = 0;
  loop(BC_MAX_INST,
    bc_my_slot < 0 ? (
      sb = BC_MY_REGION + bc_i * BC_SLOT_SIZE;
      sid = gmem[sb + 1];
      (sid == 0 || sid == bc_my_id) ? (
        bc_my_slot = bc_i;
      );
    );
    bc_i += 1;
  );

  bc_my_slot >= 0 ? (
    sb = BC_MY_REGION + bc_my_slot * BC_SLOT_SIZE;
    gmem[sb + 0] = 0;
    gmem[sb + 1] = bc_my_id;
    gmem[sb + 2] = BC_MY_TYPE;
    gmem[sb + 3] = 0;
    gmem[sb + 4] = BC_PARAM_COUNT;
  );

@slider
  // === LOW FREQUENCY SELECTION ===
  slider3 == 0 ? low_freq = 20;
  slider3 == 1 ? low_freq = 30;
  slider3 == 2 ? low_freq = 60;
  slider3 == 3 ? low_freq = 100;

  // === HIGH FREQUENCY SELECTION ===
  slider7 == 0 ? high_freq = 3000;
  slider7 == 1 ? high_freq = 4000;
  slider7 == 2 ? high_freq = 5000;
  slider7 == 3 ? high_freq = 8000;
  slider7 == 4 ? high_freq = 10000;
  slider7 == 5 ? high_freq = 12000;
  slider7 == 6 ? high_freq = 16000;

  low_boost_amt = slider1;
  low_cut_amt = slider2;
  high_boost_amt = slider4;
  high_bw = slider5;
  high_cut_amt = slider6;
  tube_on = slider8;
  out_gain = 10 ^ (slider9 / 20);

  // === LOW BOOST (low shelf, broad Q) ===
  // passive EQ boost is broad and gentle
  low_boost_amt > 0 ? (
    gain_db = low_boost_amt * 1.8;  // up to ~18dB
    A = 10 ^ (gain_db / 40);
    w0 = 2 * $pi * low_freq / srate;
    cs = cos(w0); sn = sin(w0);
    // Broad Q for boost (passive-style)
    alpha = sn / (2 * 0.4);
    a0_inv = 1 / ((A + 1) + (A - 1) * cs + 2 * sqrt(A) * alpha);
    lb_b0 = A * ((A + 1) - (A - 1) * cs + 2 * sqrt(A) * alpha) * a0_inv;
    lb_b1 = 2 * A * ((A - 1) - (A + 1) * cs) * a0_inv;
    lb_b2 = A * ((A + 1) - (A - 1) * cs - 2 * sqrt(A) * alpha) * a0_inv;
    lb_a1 = -2 * ((A - 1) + (A + 1) * cs) * a0_inv;
    lb_a2 = ((A + 1) + (A - 1) * cs - 2 * sqrt(A) * alpha) * a0_inv;
  ) : (
    lb_b0 = 1; lb_b1 = 0; lb_b2 = 0; lb_a1 = 0; lb_a2 = 0;
  );

  // === LOW CUT (low shelf cut, slightly higher freq + narrower Q) ===
  // The magic: cut frequency is offset ~1.5x higher than boost
  // This creates the classic passive EQ "dip then bump" curve
  low_cut_amt > 0 ? (
    gain_db = -low_cut_amt * 1.8;
    A = 10 ^ (gain_db / 40);
    cut_freq = low_freq * 1.5;  // offset higher
    w0 = 2 * $pi * cut_freq / srate;
    cs = cos(w0); sn = sin(w0);
    // Narrower Q for cut
    alpha = sn / (2 * 0.7);
    a0_inv = 1 / ((A + 1) + (A - 1) * cs + 2 * sqrt(A) * alpha);
    lc_b0 = A * ((A + 1) - (A - 1) * cs + 2 * sqrt(A) * alpha) * a0_inv;
    lc_b1 = 2 * A * ((A - 1) - (A + 1) * cs) * a0_inv;
    lc_b2 = A * ((A + 1) - (A - 1) * cs - 2 * sqrt(A) * alpha) * a0_inv;
    lc_a1 = -2 * ((A - 1) + (A + 1) * cs) * a0_inv;
    lc_a2 = ((A + 1) + (A - 1) * cs - 2 * sqrt(A) * alpha) * a0_inv;
  ) : (
    lc_b0 = 1; lc_b1 = 0; lc_b2 = 0; lc_a1 = 0; lc_a2 = 0;
  );

  // === HIGH BOOST (peaking EQ with variable bandwidth) ===
  high_boost_amt > 0 ? (
    gain_db = high_boost_amt * 1.5;  // up to ~15dB
    A = 10 ^ (gain_db / 40);
    w0 = 2 * $pi * high_freq / srate;
    cs = cos(w0); sn = sin(w0);
    // BW slider: 1=broad (low Q), 10=sharp (high Q)
    Q = 0.3 + (high_bw - 1) * 0.3;  // Q from 0.3 to 3.0
    alpha = sn / (2 * Q);
    a0_inv = 1 / (1 + alpha / A);
    hb_b0 = (1 + alpha * A) * a0_inv;
    hb_b1 = -2 * cs * a0_inv;
    hb_b2 = (1 - alpha * A) * a0_inv;
    hb_a1 = -2 * cs * a0_inv;
    hb_a2 = (1 - alpha / A) * a0_inv;
  ) : (
    hb_b0 = 1; hb_b1 = 0; hb_b2 = 0; hb_a1 = 0; hb_a2 = 0;
  );

  // === HIGH CUT (low-pass shelf rolloff) ===
  high_cut_amt > 0 ? (
    gain_db = -high_cut_amt * 1.5;
    A = 10 ^ (gain_db / 40);
    // Cut at 10k-20k range, gentle rolloff
    hc_freq = 10000;
    w0 = 2 * $pi * hc_freq / srate;
    cs = cos(w0); sn = sin(w0);
    alpha = sn / (2 * 0.5);
    // High shelf (cutting)
    a0_inv = 1 / ((A + 1) - (A - 1) * cs + 2 * sqrt(A) * alpha);
    hc_b0 = A * ((A + 1) + (A - 1) * cs + 2 * sqrt(A) * alpha) * a0_inv;
    hc_b1 = -2 * A * ((A - 1) + (A + 1) * cs) * a0_inv;
    hc_b2 = A * ((A + 1) + (A - 1) * cs - 2 * sqrt(A) * alpha) * a0_inv;
    hc_a1 = 2 * ((A - 1) - (A + 1) * cs) * a0_inv;
    hc_a2 = ((A + 1) - (A - 1) * cs - 2 * sqrt(A) * alpha) * a0_inv;
  ) : (
    hc_b0 = 1; hc_b1 = 0; hc_b2 = 0; hc_a1 = 0; hc_a2 = 0;
  );

// ============================================================
// @BLOCK — Broadcast, heartbeat, stale-check, follow, steal
// ============================================================
@block
bc_my_slot >= 0 ? (
  sb = BC_MY_REGION + bc_my_slot * BC_SLOT_SIZE;
  gmem[sb + 1] != bc_my_id ? (
    bc_my_id = floor(rand() * 1073741824) + 1;
    bc_my_slot = -1;
    bc_i = 0;
    loop(BC_MAX_INST,
      bc_my_slot < 0 ? (
        tsb = BC_MY_REGION + bc_i * BC_SLOT_SIZE;
        (gmem[tsb + 1] == 0) ? bc_my_slot = bc_i;
      );
      bc_i += 1;
    );
    bc_my_slot >= 0 ? (
      sb = BC_MY_REGION + bc_my_slot * BC_SLOT_SIZE;
      gmem[sb + 0] = 0;
      gmem[sb + 1] = bc_my_id;
      gmem[sb + 2] = BC_MY_TYPE;
      gmem[sb + 3] = bc_following;
      gmem[sb + 4] = BC_PARAM_COUNT;
    );
  );
);

bc_my_slot >= 0 && bc_following > 0 ? (
  bc_found_leader = 0;
  bc_scan = 0;
  loop(BC_MAX_INST,
    bc_scan != bc_my_slot ? (
      lsb = BC_MY_REGION + bc_scan * BC_SLOT_SIZE;
      gmem[lsb + 1] == bc_following ? (
        bc_found_leader = 1;
        bc_follow_slot = bc_scan;
        lbase = lsb + 8;
        slider1 = gmem[lbase + 0];
        slider2 = gmem[lbase + 1];
        slider3 = gmem[lbase + 2];
        slider4 = gmem[lbase + 3];
        slider5 = gmem[lbase + 4];
        slider6 = gmem[lbase + 5];
        slider7 = gmem[lbase + 6];
        slider8 = gmem[lbase + 7];
        slider9 = gmem[lbase + 8];
        bc_scan = BC_MAX_INST;
      );
    );
    bc_scan += 1;
  );
  !bc_found_leader ? (
    bc_following = 0;
    bc_follow_slot = -1;
  );
);

bc_my_slot >= 0 && bc_steal_pending ? (
  bc_scan = 0;
  loop(BC_MAX_INST,
    lsb = BC_MY_REGION + bc_scan * BC_SLOT_SIZE;
    gmem[lsb + 1] == bc_steal_target ? (
      lbase = lsb + 8;
      slider1 = gmem[lbase + 0];
      slider2 = gmem[lbase + 1];
      slider3 = gmem[lbase + 2];
      slider4 = gmem[lbase + 3];
      slider5 = gmem[lbase + 4];
      slider6 = gmem[lbase + 5];
      slider7 = gmem[lbase + 6];
      slider8 = gmem[lbase + 7];
      slider9 = gmem[lbase + 8];
      bc_scan = BC_MAX_INST;
    );
    bc_scan += 1;
  );
  bc_steal_pending = 0;
  bc_steal_target = 0;
  bc_steal_mode = 0;
);

bc_my_slot >= 0 ? (
  sb = BC_MY_REGION + bc_my_slot * BC_SLOT_SIZE;
  gmem[sb + 0] += 1;
  gmem[sb + 3] = bc_following;
  pbase = sb + 8;
  gmem[pbase + 0] = slider1;
  gmem[pbase + 1] = slider2;
  gmem[pbase + 2] = slider3;
  gmem[pbase + 3] = slider4;
  gmem[pbase + 4] = slider5;
  gmem[pbase + 5] = slider6;
  gmem[pbase + 6] = slider7;
  gmem[pbase + 7] = slider8;
  gmem[pbase + 8] = slider9;
);

bc_instance_count = 0;
bc_scan = 0;
loop(BC_MAX_INST,
  tsb = BC_MY_REGION + bc_scan * BC_SLOT_SIZE;
  tsid = gmem[tsb + 1];
  tsid > 0 ? (
    bc_scan == bc_my_slot ? (
      bc_instance_count += 1;
    ) : (
      tshb = gmem[tsb + 0];
      tshb == BC_STALE_HB[bc_scan] ? (
        BC_STALE_CT[bc_scan] += samplesblock / srate;
        BC_STALE_CT[bc_scan] > BC_STALE_TIMEOUT ? (
          gmem[tsb + 1] = 0;
          BC_STALE_CT[bc_scan] = 0;
        );
      ) : (
        BC_STALE_HB[bc_scan] = tshb;
        BC_STALE_CT[bc_scan] = 0;
        bc_instance_count += 1;
      );
    );
  );
  bc_scan += 1;
);

@sample
  l = spl0;
  r = spl1;

  // === LOW BOOST ===
  low_boost_amt > 0 ? (
    ol = lb_b0 * l + lb_b1 * lb_xl1 + lb_b2 * lb_xl2 - lb_a1 * lb_yl1 - lb_a2 * lb_yl2;
    lb_xl2 = lb_xl1; lb_xl1 = l; lb_yl2 = lb_yl1; lb_yl1 = ol; l = ol;
    ol = lb_b0 * r + lb_b1 * lb_xr1 + lb_b2 * lb_xr2 - lb_a1 * lb_yr1 - lb_a2 * lb_yr2;
    lb_xr2 = lb_xr1; lb_xr1 = r; lb_yr2 = lb_yr1; lb_yr1 = ol; r = ol;
  );

  // === LOW CUT ===
  low_cut_amt > 0 ? (
    ol = lc_b0 * l + lc_b1 * lc_xl1 + lc_b2 * lc_xl2 - lc_a1 * lc_yl1 - lc_a2 * lc_yl2;
    lc_xl2 = lc_xl1; lc_xl1 = l; lc_yl2 = lc_yl1; lc_yl1 = ol; l = ol;
    ol = lc_b0 * r + lc_b1 * lc_xr1 + lc_b2 * lc_xr2 - lc_a1 * lc_yr1 - lc_a2 * lc_yr2;
    lc_xr2 = lc_xr1; lc_xr1 = r; lc_yr2 = lc_yr1; lc_yr1 = ol; r = ol;
  );

  // === HIGH BOOST ===
  high_boost_amt > 0 ? (
    ol = hb_b0 * l + hb_b1 * hb_xl1 + hb_b2 * hb_xl2 - hb_a1 * hb_yl1 - hb_a2 * hb_yl2;
    hb_xl2 = hb_xl1; hb_xl1 = l; hb_yl2 = hb_yl1; hb_yl1 = ol; l = ol;
    ol = hb_b0 * r + hb_b1 * hb_xr1 + hb_b2 * hb_xr2 - hb_a1 * hb_yr1 - hb_a2 * hb_yr2;
    hb_xr2 = hb_xr1; hb_xr1 = r; hb_yr2 = hb_yr1; hb_yr1 = ol; r = ol;
  );

  // === HIGH CUT ===
  high_cut_amt > 0 ? (
    ol = hc_b0 * l + hc_b1 * hc_xl1 + hc_b2 * hc_xl2 - hc_a1 * hc_yl1 - hc_a2 * hc_yl2;
    hc_xl2 = hc_xl1; hc_xl1 = l; hc_yl2 = hc_yl1; hc_yl1 = ol; l = ol;
    ol = hc_b0 * r + hc_b1 * hc_xr1 + hc_b2 * hc_xr2 - hc_a1 * hc_yr1 - hc_a2 * hc_yr2;
    hc_xr2 = hc_xr1; hc_xr1 = r; hc_yr2 = hc_yr1; hc_yr1 = ol; r = ol;
  );

  // === TUBE SATURATION ===
  tube_on ? (
    // Gentle tube-like even harmonic saturation
    // Asymmetric soft clip for even harmonics
    drive = 1.5;
    x = l * drive; e = exp(2*x); t1 = (e - 1) / (e + 1);
    x = l * l * 0.3; e = exp(2*x); t2 = (e - 1) / (e + 1);
    l = (t1 + t2 * 0.15) / 1.15;

    x = r * drive; e = exp(2*x); t1 = (e - 1) / (e + 1);
    x = r * r * 0.3; e = exp(2*x); t2 = (e - 1) / (e + 1);
    r = (t1 + t2 * 0.15) / 1.15;
  );

  // === OUTPUT ===
  spl0 = l * out_gain;
  spl1 = r * out_gain;

@gfx 500 310
// ============================================================================
//  COLOR CONSTANTS
// ============================================================================
COL_BG_R = 0.05; COL_BG_G = 0.05; COL_BG_B = 0.07;
COL_PANEL_R = 0.08; COL_PANEL_G = 0.08; COL_PANEL_B = 0.11;
COL_PANEL_HI_R = 0.12; COL_PANEL_HI_G = 0.12; COL_PANEL_HI_B = 0.16;
COL_BORDER_R = 0.20; COL_BORDER_G = 0.20; COL_BORDER_B = 0.25;
COL_TITLE_R = 0.95; COL_TITLE_G = 0.78; COL_TITLE_B = 0.35;
COL_SEC_R = 0.55; COL_SEC_G = 0.50; COL_SEC_B = 0.40;
COL_TEXT_R = 0.78; COL_TEXT_G = 0.78; COL_TEXT_B = 0.82;
COL_DIM_R = 0.38; COL_DIM_G = 0.38; COL_DIM_B = 0.42;
COL_ACCENT_R = 0.95; COL_ACCENT_G = 0.45; COL_ACCENT_B = 0.15;
COL_GREEN_R = 0.25; COL_GREEN_G = 0.80; COL_GREEN_B = 0.50;
COL_CYAN_R = 0.20; COL_CYAN_G = 0.60; COL_CYAN_B = 0.85;
COL_BAR_BG_R = 0.12; COL_BAR_BG_G = 0.12; COL_BAR_BG_B = 0.16;

// ============================================================================
//  BACKGROUND
// ============================================================================
gfx_r = COL_BG_R; gfx_g = COL_BG_G; gfx_b = COL_BG_B;
gfx_rect(0, 0, gfx_w, gfx_h);
gfx_r = 0.03; gfx_g = 0.03; gfx_b = 0.05;
gfx_rect(0, 0, gfx_w, 44);
gfx_r = COL_TITLE_R * 0.6; gfx_g = COL_TITLE_G * 0.6; gfx_b = COL_TITLE_B * 0.6;
gfx_rect(0, 44, gfx_w, 2);

// ============================================================================
//  HELPER: draw_bar
// ============================================================================
function draw_bar(bx, by, bw, bh, val, vmin, vmax, label, show_val) (
  gfx_r = COL_BAR_BG_R; gfx_g = COL_BAR_BG_G; gfx_b = COL_BAR_BG_B;
  gfx_rect(bx, by, bw, bh);
  norm = (val - vmin) / (vmax - vmin);
  norm = max(0, min(1, norm));
  fill_w = norm * bw;
  fill_w > 0 ? (
    gfx_r = COL_CYAN_R * 0.6; gfx_g = COL_CYAN_G * 0.6; gfx_b = COL_CYAN_B * 0.6;
    gfx_rect(bx, by, fill_w, bh);
    gfx_r = COL_CYAN_R * 0.8; gfx_g = COL_CYAN_G * 0.8; gfx_b = COL_CYAN_B * 0.8;
    gfx_rect(bx, by, fill_w, floor(bh / 2));
    gfx_r = COL_CYAN_R; gfx_g = COL_CYAN_G; gfx_b = COL_CYAN_B;
    gfx_rect(bx, by, fill_w, 1);
  );
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_rect(bx, by, bw, 1); gfx_rect(bx, by + bh - 1, bw, 1);
  gfx_rect(bx, by, 1, bh); gfx_rect(bx + bw - 1, by, 1, bh);
  gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
  gfx_setfont(1, "Arial", 12);
  gfx_x = bx + 5; gfx_y = by + floor((bh - 12) / 2);
  gfx_drawstr(label);
  show_val ? (
    gfx_setfont(1, "Arial", 11);
    gfx_x = bx + bw - 40; gfx_y = by + floor((bh - 11) / 2);
    gfx_drawnumber(val, val == floor(val) ? 0 : 1);
  );
  mouse_cap & 1 ? (
    mouse_x >= bx && mouse_x <= bx + bw &&
    mouse_y >= by && mouse_y <= by + bh ? (
      new_norm = (mouse_x - bx) / bw;
      new_norm = max(0, min(1, new_norm));
      val = vmin + new_norm * (vmax - vmin);
    );
  );
  val;
);

// ============================================================================
//  HELPER: draw_panel
// ============================================================================
function draw_panel(px, py, pw, ph, title) (
  gfx_r = COL_PANEL_R; gfx_g = COL_PANEL_G; gfx_b = COL_PANEL_B;
  gfx_rect(px, py, pw, ph);
  gfx_r = COL_PANEL_HI_R; gfx_g = COL_PANEL_HI_G; gfx_b = COL_PANEL_HI_B;
  gfx_rect(px, py, pw, 22);
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_rect(px, py + 22, pw, 1);
  gfx_r = COL_BORDER_R * 0.7; gfx_g = COL_BORDER_G * 0.7; gfx_b = COL_BORDER_B * 0.7;
  gfx_rect(px, py, pw, 1); gfx_rect(px, py, 1, ph);
  gfx_rect(px + pw - 1, py, 1, ph); gfx_rect(px, py + ph - 1, pw, 1);
  gfx_r = COL_SEC_R; gfx_g = COL_SEC_G; gfx_b = COL_SEC_B;
  gfx_setfont(1, "Arial", 12);
  gfx_x = px + 8; gfx_y = py + 4;
  gfx_drawstr(title);
);

// ============================================================================
//  HELPER: draw_toggle
// ============================================================================
function draw_toggle(tx, ty, is_on, label) (
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_circle(tx + 8, ty + 8, 7, 0);
  is_on ? (
    gfx_r = COL_GREEN_R; gfx_g = COL_GREEN_G; gfx_b = COL_GREEN_B;
    gfx_circle(tx + 8, ty + 8, 5, 1);
  ) : (
    gfx_r = 0.15; gfx_g = 0.15; gfx_b = 0.18;
    gfx_circle(tx + 8, ty + 8, 5, 1);
  );
  gfx_r = is_on ? COL_TEXT_R : COL_DIM_R;
  gfx_g = is_on ? COL_TEXT_G : COL_DIM_G;
  gfx_b = is_on ? COL_TEXT_B : COL_DIM_B;
  gfx_setfont(1, "Arial", 11);
  gfx_x = tx + 20; gfx_y = ty + 1;
  gfx_drawstr(label);
  (mouse_cap & 1) && !(last_cap & 1) &&
    mouse_x >= tx && mouse_x <= tx + 80 &&
    mouse_y >= ty && mouse_y <= ty + 16 ? (
      is_on = 1 - is_on;
  );
  is_on;
);

// ============================================================================
//  HELPER: draw_mode_sel — clickable mode selector (4 values)
// ============================================================================
function draw_mode_sel(mx, my, mw, mh, val, vmax, label, v0, v1, v2, v3) (
  gfx_r = COL_BAR_BG_R; gfx_g = COL_BAR_BG_G; gfx_b = COL_BAR_BG_B;
  gfx_rect(mx, my, mw, mh);
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_rect(mx, my, mw, 1); gfx_rect(mx, my + mh - 1, mw, 1);
  gfx_rect(mx, my, 1, mh); gfx_rect(mx + mw - 1, my, 1, mh);
  gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
  gfx_setfont(1, "Arial", 12);
  gfx_x = mx + 5; gfx_y = my + floor((mh - 12) / 2);
  gfx_drawstr(label);
  gfx_r = COL_ACCENT_R; gfx_g = COL_ACCENT_G; gfx_b = COL_ACCENT_B;
  gfx_x = mx + mw - 72; gfx_y = my + floor((mh - 12) / 2);
  val == 0 ? gfx_drawstr(v0);
  val == 1 ? gfx_drawstr(v1);
  val == 2 ? gfx_drawstr(v2);
  val == 3 ? gfx_drawstr(v3);
  (mouse_cap & 1) && !(last_cap & 1) &&
    mouse_x >= mx && mouse_x <= mx + mw &&
    mouse_y >= my && mouse_y <= my + mh ? (
      val = (val + 1) % (vmax + 1);
  );
  (mouse_cap & 2) && !(last_cap & 2) &&
    mouse_x >= mx && mouse_x <= mx + mw &&
    mouse_y >= my && mouse_y <= my + mh ? (
      val = val - 1; val < 0 ? val = vmax;
  );
  val;
);

// ============================================================================
//  HELPER: draw_freq_sel — clickable frequency selector (7 values)
// ============================================================================
function draw_freq_sel(mx, my, mw, mh, val, label) (
  gfx_r = COL_BAR_BG_R; gfx_g = COL_BAR_BG_G; gfx_b = COL_BAR_BG_B;
  gfx_rect(mx, my, mw, mh);
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_rect(mx, my, mw, 1); gfx_rect(mx, my + mh - 1, mw, 1);
  gfx_rect(mx, my, 1, mh); gfx_rect(mx + mw - 1, my, 1, mh);
  gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
  gfx_setfont(1, "Arial", 12);
  gfx_x = mx + 5; gfx_y = my + floor((mh - 12) / 2);
  gfx_drawstr(label);
  gfx_r = COL_ACCENT_R; gfx_g = COL_ACCENT_G; gfx_b = COL_ACCENT_B;
  gfx_x = mx + mw - 72; gfx_y = my + floor((mh - 12) / 2);
  val == 0 ? gfx_drawstr("3kHz");
  val == 1 ? gfx_drawstr("4kHz");
  val == 2 ? gfx_drawstr("5kHz");
  val == 3 ? gfx_drawstr("8kHz");
  val == 4 ? gfx_drawstr("10kHz");
  val == 5 ? gfx_drawstr("12kHz");
  val == 6 ? gfx_drawstr("16kHz");
  (mouse_cap & 1) && !(last_cap & 1) &&
    mouse_x >= mx && mouse_x <= mx + mw &&
    mouse_y >= my && mouse_y <= my + mh ? (
      val = (val + 1) % 7;
  );
  (mouse_cap & 2) && !(last_cap & 2) &&
    mouse_x >= mx && mouse_x <= mx + mw &&
    mouse_y >= my && mouse_y <= my + mh ? (
      val = val - 1; val < 0 ? val = 6;
  );
  val;
);

// ============================================================================
//  LAYOUT
// ============================================================================
margin = 8;
gap = 6;
bar_h = 18;
bar_sp = 21;
col_w = floor((gfx_w - margin * 2 - gap) / 2);
body_y = 50;

// ============================================================================
//  TITLE
// ============================================================================
gfx_r = COL_TITLE_R; gfx_g = COL_TITLE_G; gfx_b = COL_TITLE_B;
gfx_setfont(1, "Arial", 22);
gfx_x = 12; gfx_y = 10;
gfx_drawstr("PEQ4U");
gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
gfx_setfont(1, "Arial", 11);
gfx_x = 100; gfx_y = 18;
gfx_drawstr("Passive Equalizer");

// ============================================================================
//  COLUMN 1: LOW SECTION (3 controls)
// ============================================================================
c1x = margin;
panel_h = 26 + bar_sp * 4 + 4;
draw_panel(c1x, body_y, col_w, panel_h, "LOW");
cy = body_y + 26;
slider1 = draw_bar(c1x + 4, cy, col_w - 8, bar_h, slider1, 0, 10, "Lo Boost", 1);
cy += bar_sp;
slider2 = draw_bar(c1x + 4, cy, col_w - 8, bar_h, slider2, 0, 10, "Lo Atten", 1);
cy += bar_sp;
slider3 = draw_mode_sel(c1x + 4, cy, col_w - 8, bar_h, slider3, 3, "Lo Freq", "20Hz", "30Hz", "60Hz", "100Hz");

// ============================================================================
//  COLUMN 2: HIGH SECTION (4 controls)
// ============================================================================
c2x = margin + col_w + gap;
draw_panel(c2x, body_y, col_w, panel_h, "HIGH");
cy = body_y + 26;
slider4 = draw_bar(c2x + 4, cy, col_w - 8, bar_h, slider4, 0, 10, "Hi Boost", 1);
cy += bar_sp;
slider5 = draw_bar(c2x + 4, cy, col_w - 8, bar_h, slider5, 1, 10, "Hi BW", 1);
cy += bar_sp;
slider6 = draw_bar(c2x + 4, cy, col_w - 8, bar_h, slider6, 0, 10, "Hi Atten", 1);
cy += bar_sp;
slider7 = draw_freq_sel(c2x + 4, cy, col_w - 8, bar_h, slider7, "Hi Freq");

// ============================================================================
//  BOTTOM ROW: TUBE TOGGLE + OUTPUT
// ============================================================================
bot_y = body_y + panel_h + 6;
draw_panel(margin, bot_y, gfx_w - margin * 2, 50, "OUTPUT");
slider8 = draw_toggle(margin + 8, bot_y + 26, slider8, "Tube Saturation");
slider9 = draw_bar(margin + 160, bot_y + 26, gfx_w - margin * 2 - 164, bar_h, slider9, -12, 12, "Output dB", 1);
  // ============================================================
  // INSTANCE MANAGER PANEL
  // ============================================================
  bc_panel_h = bc_panel_expanded ? 90 : 30;
  bc_panel_y = gfx_h - bc_panel_h;

  gfx_r = 0.04; gfx_g = 0.04; gfx_b = 0.06;
  gfx_rect(0, bc_panel_y, gfx_w, bc_panel_h);
  gfx_r = 0.15; gfx_g = 0.15; gfx_b = 0.20;
  gfx_rect(0, bc_panel_y, gfx_w, 1);

  gfx_setfont(1, "Arial", 11);
  gfx_r = 0.95; gfx_g = 0.45; gfx_b = 0.15;
  gfx_x = 8; gfx_y = bc_panel_y + 8;
  bc_my_slot >= 0 ? (
    gfx_drawstr("I");
    gfx_drawnumber(bc_my_slot + 1, 0);
    gfx_drawstr("/");
    gfx_drawnumber(bc_instance_count, 0);
  ) : (
    gfx_drawstr("--");
  );

  bc_following > 0 ? (
    gfx_r = 0.2; gfx_g = 0.8; gfx_b = 0.3;
    gfx_drawstr("  Following: I");
    bc_fs = 0;
    loop(BC_MAX_INST,
      fsb = BC_MY_REGION + bc_fs * BC_SLOT_SIZE;
      gmem[fsb + 1] == bc_following ? (
        gfx_drawnumber(bc_fs + 1, 0);
        bc_fs = BC_MAX_INST;
      );
      bc_fs += 1;
    );
  ) : (
    gfx_r = 0.3; gfx_g = 0.3; gfx_b = 0.4;
    gfx_drawstr("  Following: --");
  );

  exp_x = gfx_w - 200;
  exp_y = bc_panel_y + 4;
  exp_w = 65;
  exp_h = 20;
  gfx_r = 0.12; gfx_g = 0.12; gfx_b = 0.16;
  gfx_rect(exp_x, exp_y, exp_w, exp_h);
  gfx_r = 0.5; gfx_g = 0.5; gfx_b = 0.6;
  gfx_x = exp_x + 5; gfx_y = exp_y + 4;
  bc_panel_expanded ? gfx_drawstr("COLLAPSE") : gfx_drawstr("EXPAND");
  (mouse_cap & 1) && !(last_cap & 1) &&
    mouse_x >= exp_x && mouse_x < exp_x + exp_w &&
    mouse_y >= exp_y && mouse_y < exp_y + exp_h ? (
    bc_panel_expanded = !bc_panel_expanded;
    bc_steal_mode = 0;
  );

  stl_x = gfx_w - 125;
  stl_y = bc_panel_y + 4;
  stl_w = 50;
  stl_h = 20;
  bc_steal_mode ? (
    gfx_r = 0.6; gfx_g = 0.2; gfx_b = 0.1;
  ) : (
    gfx_r = 0.2; gfx_g = 0.1; gfx_b = 0.1;
  );
  gfx_rect(stl_x, stl_y, stl_w, stl_h);
  gfx_r = 0.9; gfx_g = 0.5; gfx_b = 0.2;
  gfx_x = stl_x + 6; gfx_y = stl_y + 4;
  gfx_drawstr("STEAL");
  (mouse_cap & 1) && !(last_cap & 1) &&
    mouse_x >= stl_x && mouse_x < stl_x + stl_w &&
    mouse_y >= stl_y && mouse_y < stl_y + stl_h ? (
    bc_steal_mode = !bc_steal_mode;
    !bc_panel_expanded ? bc_panel_expanded = 1;
  );

  bc_following > 0 ? (
    unf_x = gfx_w - 65;
    unf_y = bc_panel_y + 4;
    unf_w = 55;
    unf_h = 20;
    gfx_r = 0.1; gfx_g = 0.2; gfx_b = 0.1;
    gfx_rect(unf_x, unf_y, unf_w, unf_h);
    gfx_r = 0.5; gfx_g = 0.9; gfx_b = 0.5;
    gfx_x = unf_x + 4; gfx_y = unf_y + 4;
    gfx_drawstr("UNFLW");
    (mouse_cap & 1) && !(last_cap & 1) &&
      mouse_x >= unf_x && mouse_x < unf_x + unf_w &&
      mouse_y >= unf_y && mouse_y < unf_y + unf_h ? (
      bc_following = 0;
      bc_follow_slot = -1;
    );
  );

  bc_panel_expanded ? (
    row_y = bc_panel_y + 30;
    row_h = 14;
    bc_s = 0;
    loop(BC_MAX_INST,
      isb = BC_MY_REGION + bc_s * BC_SLOT_SIZE;
      isid = gmem[isb + 1];
      isid > 0 ? (
        mouse_y >= row_y && mouse_y < row_y + row_h &&
          mouse_x >= 8 && mouse_x < gfx_w - 8 &&
          bc_s != bc_my_slot ? (
          gfx_r = 0.10; gfx_g = 0.10; gfx_b = 0.14;
          gfx_rect(4, row_y, gfx_w - 8, row_h);
        );
        gfx_setfont(1, "Arial", 10);
        bc_s == bc_my_slot ? (
          gfx_r = 0.95; gfx_g = 0.45; gfx_b = 0.15;
        ) : (
          gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.8;
        );
        gfx_x = 12; gfx_y = row_y + 1;
        gfx_drawstr("I");
        gfx_drawnumber(bc_s + 1, 0);
        gfx_drawstr("  ");
        bc_s == bc_my_slot ? (
          gfx_drawstr("[YOU]");
        ) : (
          iwho = gmem[isb + 3];
          iwho > 0 ? (
            gfx_drawstr("[>I");
            iw = 0;
            loop(BC_MAX_INST,
              iwsb = BC_MY_REGION + iw * BC_SLOT_SIZE;
              gmem[iwsb + 1] == iwho ? (
                gfx_drawnumber(iw + 1, 0);
                iw = BC_MAX_INST;
              );
              iw += 1;
            );
            gfx_drawstr("]");
          ) : (
            gfx_drawstr("[LEADER]");
          );
          gfx_r = 0.35; gfx_g = 0.45; gfx_b = 0.35;
          bc_steal_mode ? (
            gfx_drawstr("  click: steal");
          ) : (
            gfx_drawstr("  click: follow");
          );
          (mouse_cap & 1) && !(last_cap & 1) &&
            mouse_y >= row_y && mouse_y < row_y + row_h &&
            mouse_x >= 8 && mouse_x < gfx_w - 8 ? (
            bc_steal_mode ? (
              bc_steal_target = isid;
              bc_steal_pending = 1;
              bc_steal_mode = 0;
            ) : (
              bc_can_follow = 1;
              bc_cursor = isid;
              bc_hops = 0;
              while(bc_cursor > 0 && bc_hops < BC_MAX_INST) (
                bc_cursor == bc_my_id ? (
                  bc_can_follow = 0;
                  bc_cursor = 0;
                ) : (
                  bc_next = 0;
                  bc_cs = 0;
                  loop(BC_MAX_INST,
                    csb = BC_MY_REGION + bc_cs * BC_SLOT_SIZE;
                    gmem[csb + 1] == bc_cursor ? (
                      bc_next = gmem[csb + 3];
                      bc_cs = BC_MAX_INST;
                    );
                    bc_cs += 1;
                  );
                  bc_cursor = bc_next;
                );
                bc_hops += 1;
              );
              bc_can_follow ? (
                bc_following = isid;
              );
            );
          );
        );
        row_y += row_h;
      );
      bc_s += 1;
    );
  );

  last_cap = mouse_cap;

  // --- NOTICE BUTTON ---
  notice_btn_x = gfx_w - 60;
  notice_btn_y = bc_panel_y - 18;
  gfx_r = 0.6; gfx_g = 0.5; gfx_b = 0.3;
  gfx_rect(notice_btn_x, notice_btn_y, 55, 15);
  gfx_r = 0; gfx_g = 0; gfx_b = 0;
  gfx_x = notice_btn_x + 4; gfx_y = notice_btn_y + 2;
  gfx_drawstr("NOTICE");
  (mouse_cap & 1) && mouse_x >= notice_btn_x && mouse_x <= notice_btn_x + 55 && mouse_y >= notice_btn_y && mouse_y <= notice_btn_y + 15 && !notice_clicked ? (
    notice_show = !notice_show;
    notice_clicked = 1;
  );
  !(mouse_cap & 1) ? notice_clicked = 0;
  notice_show ? (
    gfx_r = 0.05; gfx_g = 0.05; gfx_b = 0.05; gfx_a = 0.95;
    gfx_rect(0, 0, gfx_w, gfx_h);
    gfx_a = 1;
    gfx_r = 0.9; gfx_g = 0.8; gfx_b = 0.5;
    gfx_x = 15; gfx_y = 10;
    gfx_drawstr("NOTICE: THEY ARE TRYING TO STEAL YOUR COMPUTER");
    gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.7;
    gfx_x = 15; gfx_y = 30;
    gfx_drawstr("The algorithms in our favorite software are decades old.");
    gfx_x = 15; gfx_y = 45;
    gfx_drawstr("A mathematical model is a truth about the world,");
    gfx_x = 15; gfx_y = 60;
    gfx_drawstr("not a copyrightable product. You do not have to stay");
    gfx_x = 15; gfx_y = 75;
    gfx_drawstr("a slave to subscription software. Install Linux.");
    gfx_x = 15; gfx_y = 90;
    gfx_drawstr("Build your own tools. Believe in yourself.");
    gfx_r = 0.5; gfx_g = 0.7; gfx_b = 1.0;
    gfx_x = 15; gfx_y = 115;
    gfx_drawstr("github.com/LMSBAND  |  instagram.com/LMSSKABAND");
    gfx_r = 0.4; gfx_g = 0.4; gfx_b = 0.4;
    gfx_x = 15; gfx_y = 140;
    gfx_r = 0.6; gfx_g = 0.5; gfx_b = 0.3;
    gfx_rect(notice_btn_x, notice_btn_y, 55, 15);
    gfx_r = 0; gfx_g = 0; gfx_b = 0;
    gfx_x = notice_btn_x + 4; gfx_y = notice_btn_y + 2;
    gfx_drawstr("NOTICE");
  );

// ============================================================
// @SERIALIZE — Persist follow state
// ============================================================
@serialize
file_var(0, bc_following);
file_var(0, bc_my_id);
