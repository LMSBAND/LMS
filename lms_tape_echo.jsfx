desc:HENGE DELAY
//tags: delay echo tape analog
//author: LMS + Claude

options:gmem=DrumBanger

slider1:0<0,6,1{Head 1,Head 2,Head 3,Heads 1+2,Heads 1+3,Heads 2+3,All Heads}>-Mode
slider2:300<50,1000,1>-Repeat Rate (ms)
slider3:40<0,100,0.1>-Intensity (%)
slider4:80<0,100,0.1>-Echo Volume (%)
slider5:50<0,100,1>-Bass (%)
slider6:50<0,100,1>-Treble (%)
slider7:30<0,100,1>-Wow & Flutter (%)
slider8:30<0,100,1>-Tape Age (%)
slider9:0<0,100,1>-Spring Reverb (%)
slider10:50<0,100,1>-Dry/Wet (%)

@init
  // Delay buffer - max 2 seconds
  buf_max = floor(srate * 2);
  buf_l = 0;
  buf_r = buf_max;
  wpos = 0;

  memset(buf_l, 0, buf_max);
  memset(buf_r, 0, buf_max);

  // Feedback lowpass state
  fb_lp_l = 0; fb_lp_r = 0;

  // Feedback signal (persists between samples)
  fb_l = 0; fb_r = 0;

  // Wow/flutter LFO phases
  wow_phase = 0;
  flutter_phase = 0;

  // Tape reel animation
  reel_angle = 0;

  // Spring reverb buffers (6 allpass + 2 comb delays)
  // Allpass delays - prime-ish numbers for diffusion
  sp_base = buf_max * 2 + 100;
  sp_ap1_len = 113;  sp_ap1_buf = sp_base;              sp_ap1_pos = 0;
  sp_ap2_len = 337;  sp_ap2_buf = sp_ap1_buf + sp_ap1_len; sp_ap2_pos = 0;
  sp_ap3_len = 547;  sp_ap3_buf = sp_ap2_buf + sp_ap2_len; sp_ap3_pos = 0;
  sp_ap4_len = 751;  sp_ap4_buf = sp_ap3_buf + sp_ap3_len; sp_ap4_pos = 0;
  sp_ap5_len = 1153; sp_ap5_buf = sp_ap4_buf + sp_ap4_len; sp_ap5_pos = 0;
  sp_ap6_len = 1597; sp_ap6_buf = sp_ap5_buf + sp_ap5_len; sp_ap6_pos = 0;
  // Comb delays for the spring bounce character
  sp_cm1_len = floor(srate * 0.035);  // ~35ms spring transit
  sp_cm2_len = floor(srate * 0.043);  // slightly offset
  sp_cm1_buf = sp_ap6_buf + sp_ap6_len; sp_cm1_pos = 0;
  sp_cm2_buf = sp_cm1_buf + sp_cm1_len; sp_cm2_pos = 0;
  // Clear spring buffers
  memset(sp_base, 0, sp_cm2_buf + sp_cm2_len - sp_base);
  // Spring lowpass state
  sp_lp_l = 0; sp_lp_r = 0;
  // Spring damping
  sp_damp_coeff = exp(-2 * $pi * 4000 / srate);

  // tanh approximation
  function tanh(x) local(e2x) (
    x > 10 ? 1 : x < -10 ? -1 : (
      e2x = exp(2 * x);
      (e2x - 1) / (e2x + 1);
    );
  );

  // Cubic interpolation read from delay buffer
  function buf_read_cubic(buf, pos, bmax)
    local(p0, p1, p2, p3, x0, x1, x2, x3, a, b, c, d, frac, idx)
  (
    idx = floor(pos);
    frac = pos - idx;

    p0 = idx - 1; p0 < 0 ? p0 += bmax;
    p1 = idx;     p1 >= bmax ? p1 -= bmax;
    p2 = idx + 1; p2 >= bmax ? p2 -= bmax;
    p3 = idx + 2; p3 >= bmax ? p3 -= bmax;

    x0 = buf[p0]; x1 = buf[p1]; x2 = buf[p2]; x3 = buf[p3];

    // Cubic Hermite interpolation
    a = -0.5*x0 + 1.5*x1 - 1.5*x2 + 0.5*x3;
    b = x0 - 2.5*x1 + 2*x2 - 0.5*x3;
    c = -0.5*x0 + 0.5*x2;
    d = x1;

    ((a * frac + b) * frac + c) * frac + d;
  );

  // Spring allpass filter
  function spring_ap(buf, pos, len, input, coeff)
    local(delayed, output)
  (
    delayed = buf[pos];
    output = -input * coeff + delayed;
    buf[pos] = input + delayed * coeff;
    output;
  );

  // Tape saturation (asymmetric, like real tape)
  function tape_sat(x, age)
    local(drive, b)
  (
    drive = 1 + age * 3;
    b = x * drive;
    b > 0 ? (
      b = this.tanh(b);
    ) : (
      b = this.tanh(b * 0.85) * 1.18;
    );
    b / drive * (1 + age * 0.5); // compensate gain, slight warmth boost
  );

notice_show = 0;

  // ============================================================
  // BROADCAST SYSTEM — Instance Registry
  // ============================================================
  BC_BASE = 100000;
  BC_MY_TYPE = 8;           // Henge Delay
  BC_SLOT_SIZE = 512;
  BC_MAX_INST = 8;
  BC_PARAM_COUNT = 10;
  BC_MY_REGION = BC_BASE + BC_MY_TYPE * 4096;
  BC_STALE_TIMEOUT = 2;

  // Generate unique instance ID (only on first init, preserve across transport stop/start)
  bc_my_id == 0 ? bc_my_id = floor(rand() * 1073741824) + 1;
  bc_my_slot = -1;
  // bc_following preserved by @serialize — do NOT zero here
  bc_follow_slot = -1;
  bc_steal_pending = 0;
  bc_steal_target = 0;
  bc_panel_expanded = 0;
  bc_steal_mode = 0;
  bc_instance_count = 0;

  BC_STALE_HB = 500000;
  BC_STALE_CT = 500008;
  i = 0;
  loop(BC_MAX_INST,
    BC_STALE_HB[i] = -1;
    BC_STALE_CT[i] = 0;
    i += 1;
  );

  bc_i = 0;
  loop(BC_MAX_INST,
    bc_my_slot < 0 ? (
      sb = BC_MY_REGION + bc_i * BC_SLOT_SIZE;
      sid = gmem[sb + 1];
      (sid == 0 || sid == bc_my_id) ? (
        bc_my_slot = bc_i;
      );
    );
    bc_i += 1;
  );

  bc_my_slot >= 0 ? (
    sb = BC_MY_REGION + bc_my_slot * BC_SLOT_SIZE;
    gmem[sb + 0] = 0;
    gmem[sb + 1] = bc_my_id;
    gmem[sb + 2] = BC_MY_TYPE;
    gmem[sb + 3] = 0;
    gmem[sb + 4] = BC_PARAM_COUNT;
  );

@slider
  mode = slider1;
  delay_ms = slider2;
  intensity = slider3 / 100;
  echo_vol = slider4 / 100;
  bass = slider5 / 100;
  treble = slider6 / 100;
  wf_amount = slider7 / 100;
  tape_age = slider8 / 100;
  spring_mix = slider9 / 100;
  dry_wet = slider10 / 100;

  // Base delay in samples (Head 1)
  delay_base = delay_ms / 1000 * srate;

  // Head positions (classic spacing ratios)
  head1_delay = delay_base;
  head2_delay = delay_base * 1.5;
  head3_delay = delay_base * 2.0;

  // Which heads are active
  h1_on = (mode == 0 || mode == 3 || mode == 4 || mode == 6) ? 1 : 0;
  h2_on = (mode == 1 || mode == 3 || mode == 5 || mode == 6) ? 1 : 0;
  h3_on = (mode == 2 || mode == 4 || mode == 5 || mode == 6) ? 1 : 0;
  num_heads = h1_on + h2_on + h3_on;
  num_heads < 1 ? num_heads = 1;

  // Feedback lowpass cutoff (treble + tape age darken it)
  fb_lp_freq = 800 + treble * 8000 - tape_age * 3000;
  fb_lp_freq = max(fb_lp_freq, 400);
  fb_lp_freq = min(fb_lp_freq, 12000);
  fb_lp_coeff = exp(-2 * $pi * fb_lp_freq / srate);

  // Bass tone: simple one-pole highpass amount (less bass = more highpass)
  bass_hp_freq = 60 + (1 - bass) * 400;
  bass_hp_coeff = exp(-2 * $pi * bass_hp_freq / srate);

// ============================================================
// @BLOCK — Broadcast, heartbeat, stale-check, follow, steal
// ============================================================
@block
bc_my_slot >= 0 ? (
  sb = BC_MY_REGION + bc_my_slot * BC_SLOT_SIZE;
  gmem[sb + 1] != bc_my_id ? (
    bc_my_id = floor(rand() * 1073741824) + 1;
    bc_my_slot = -1;
    bc_i = 0;
    loop(BC_MAX_INST,
      bc_my_slot < 0 ? (
        tsb = BC_MY_REGION + bc_i * BC_SLOT_SIZE;
        (gmem[tsb + 1] == 0) ? bc_my_slot = bc_i;
      );
      bc_i += 1;
    );
    bc_my_slot >= 0 ? (
      sb = BC_MY_REGION + bc_my_slot * BC_SLOT_SIZE;
      gmem[sb + 0] = 0;
      gmem[sb + 1] = bc_my_id;
      gmem[sb + 2] = BC_MY_TYPE;
      gmem[sb + 3] = bc_following;
      gmem[sb + 4] = BC_PARAM_COUNT;
    );
  );
);

bc_my_slot >= 0 && bc_following > 0 ? (
  bc_found_leader = 0;
  bc_scan = 0;
  loop(BC_MAX_INST,
    bc_scan != bc_my_slot ? (
      lsb = BC_MY_REGION + bc_scan * BC_SLOT_SIZE;
      gmem[lsb + 1] == bc_following ? (
        bc_found_leader = 1;
        bc_follow_slot = bc_scan;
        lbase = lsb + 8;
        slider1 = gmem[lbase + 0];
        slider2 = gmem[lbase + 1];
        slider3 = gmem[lbase + 2];
        slider4 = gmem[lbase + 3];
        slider5 = gmem[lbase + 4];
        slider6 = gmem[lbase + 5];
        slider7 = gmem[lbase + 6];
        slider8 = gmem[lbase + 7];
        slider9 = gmem[lbase + 8];
        slider10 = gmem[lbase + 9];
        bc_scan = BC_MAX_INST;
      );
    );
    bc_scan += 1;
  );
  !bc_found_leader ? (
    bc_following = 0;
    bc_follow_slot = -1;
  );
);

bc_my_slot >= 0 && bc_steal_pending ? (
  bc_scan = 0;
  loop(BC_MAX_INST,
    lsb = BC_MY_REGION + bc_scan * BC_SLOT_SIZE;
    gmem[lsb + 1] == bc_steal_target ? (
      lbase = lsb + 8;
      slider1 = gmem[lbase + 0];
      slider2 = gmem[lbase + 1];
      slider3 = gmem[lbase + 2];
      slider4 = gmem[lbase + 3];
      slider5 = gmem[lbase + 4];
      slider6 = gmem[lbase + 5];
      slider7 = gmem[lbase + 6];
      slider8 = gmem[lbase + 7];
      slider9 = gmem[lbase + 8];
      slider10 = gmem[lbase + 9];
      bc_scan = BC_MAX_INST;
    );
    bc_scan += 1;
  );
  bc_steal_pending = 0;
  bc_steal_target = 0;
  bc_steal_mode = 0;
);

bc_my_slot >= 0 ? (
  sb = BC_MY_REGION + bc_my_slot * BC_SLOT_SIZE;
  gmem[sb + 0] += 1;
  gmem[sb + 3] = bc_following;
  pbase = sb + 8;
  gmem[pbase + 0] = slider1;
  gmem[pbase + 1] = slider2;
  gmem[pbase + 2] = slider3;
  gmem[pbase + 3] = slider4;
  gmem[pbase + 4] = slider5;
  gmem[pbase + 5] = slider6;
  gmem[pbase + 6] = slider7;
  gmem[pbase + 7] = slider8;
  gmem[pbase + 8] = slider9;
  gmem[pbase + 9] = slider10;
);

bc_instance_count = 0;
bc_scan = 0;
loop(BC_MAX_INST,
  tsb = BC_MY_REGION + bc_scan * BC_SLOT_SIZE;
  tsid = gmem[tsb + 1];
  tsid > 0 ? (
    bc_scan == bc_my_slot ? (
      bc_instance_count += 1;
    ) : (
      tshb = gmem[tsb + 0];
      tshb == BC_STALE_HB[bc_scan] ? (
        BC_STALE_CT[bc_scan] += samplesblock / srate;
        BC_STALE_CT[bc_scan] > BC_STALE_TIMEOUT ? (
          gmem[tsb + 1] = 0;
          BC_STALE_CT[bc_scan] = 0;
        );
      ) : (
        BC_STALE_HB[bc_scan] = tshb;
        BC_STALE_CT[bc_scan] = 0;
        bc_instance_count += 1;
      );
    );
  );
  bc_scan += 1;
);

@sample
  // --- Wow & Flutter modulation ---
  wow_phase += 0.5 / srate;   // 0.5 Hz
  wow_phase >= 1 ? wow_phase -= 1;
  flutter_phase += 6.3 / srate; // ~6.3 Hz
  flutter_phase >= 1 ? flutter_phase -= 1;

  // Wow: triangle wave for natural drift
  wow_val = wow_phase < 0.5 ? (wow_phase * 4 - 1) : (3 - wow_phase * 4);
  // Flutter: sine
  flutter_val = sin(2 * $pi * flutter_phase);

  // Modulation in samples
  wow_mod = wow_val * wf_amount * 3.0 * srate / 1000;      // ±3ms max
  flutter_mod = flutter_val * wf_amount * 0.5 * srate / 1000; // ±0.5ms max
  total_mod = wow_mod + flutter_mod;

  // --- Write to delay buffer (input + feedback with tape saturation) ---
  tape_in_l = spl0 + fb_l * intensity;
  tape_in_r = spl1 + fb_r * intensity;

  // Tape saturation on the signal going to tape
  tape_age > 0.01 ? (
    tape_in_l = tape_sat(tape_in_l, tape_age);
    tape_in_r = tape_sat(tape_in_r, tape_age);
  );

  buf_l[wpos] = tape_in_l;
  buf_r[wpos] = tape_in_r;

  // --- Read from heads ---
  wet_l = 0; wet_r = 0;

  h1_on ? (
    rd = wpos - head1_delay - total_mod;
    rd < 0 ? rd += buf_max;
    rd >= buf_max ? rd -= buf_max;
    wet_l += buf_read_cubic(buf_l, rd, buf_max);
    wet_r += buf_read_cubic(buf_r, rd, buf_max);
  );

  h2_on ? (
    rd = wpos - head2_delay - total_mod;
    rd < 0 ? rd += buf_max;
    rd >= buf_max ? rd -= buf_max;
    wet_l += buf_read_cubic(buf_l, rd, buf_max);
    wet_r += buf_read_cubic(buf_r, rd, buf_max);
  );

  h3_on ? (
    rd = wpos - head3_delay - total_mod;
    rd < 0 ? rd += buf_max;
    rd >= buf_max ? rd -= buf_max;
    wet_l += buf_read_cubic(buf_l, rd, buf_max);
    wet_r += buf_read_cubic(buf_r, rd, buf_max);
  );

  // Scale by number of active heads to prevent volume jumps
  wet_l /= num_heads;
  wet_r /= num_heads;

  // --- Feedback path: lowpass filter (tape loses highs each pass) ---
  fb_lp_l = fb_lp_l * fb_lp_coeff + wet_l * (1 - fb_lp_coeff);
  fb_lp_r = fb_lp_r * fb_lp_coeff + wet_r * (1 - fb_lp_coeff);
  fb_l = fb_lp_l;
  fb_r = fb_lp_r;

  // --- Tone shaping on wet output ---
  // Simple bass cut (highpass) when bass is low
  bass < 0.99 ? (
    wet_l = wet_l - (wet_l * bass_hp_coeff + fb_lp_l * (1 - bass_hp_coeff)) * (1 - bass);
    wet_r = wet_r - (wet_r * bass_hp_coeff + fb_lp_r * (1 - bass_hp_coeff)) * (1 - bass);
  );

  // Apply echo volume
  wet_l *= echo_vol;
  wet_r *= echo_vol;

  // --- Spring Reverb (post echo, post echo) ---
  spring_mix > 0 ? (
    // Feed the echo output into the spring
    sp_in = (wet_l + wet_r) * 0.5;

    // Allpass diffusion chain (creates spring-like dispersion)
    sp_in = spring_ap(sp_ap1_buf, sp_ap1_pos, sp_ap1_len, sp_in, 0.6);
    sp_ap1_pos += 1; sp_ap1_pos >= sp_ap1_len ? sp_ap1_pos = 0;
    sp_in = spring_ap(sp_ap2_buf, sp_ap2_pos, sp_ap2_len, sp_in, 0.6);
    sp_ap2_pos += 1; sp_ap2_pos >= sp_ap2_len ? sp_ap2_pos = 0;
    sp_in = spring_ap(sp_ap3_buf, sp_ap3_pos, sp_ap3_len, sp_in, 0.55);
    sp_ap3_pos += 1; sp_ap3_pos >= sp_ap3_len ? sp_ap3_pos = 0;
    sp_in = spring_ap(sp_ap4_buf, sp_ap4_pos, sp_ap4_len, sp_in, 0.55);
    sp_ap4_pos += 1; sp_ap4_pos >= sp_ap4_len ? sp_ap4_pos = 0;
    sp_in = spring_ap(sp_ap5_buf, sp_ap5_pos, sp_ap5_len, sp_in, 0.5);
    sp_ap5_pos += 1; sp_ap5_pos >= sp_ap5_len ? sp_ap5_pos = 0;
    sp_in = spring_ap(sp_ap6_buf, sp_ap6_pos, sp_ap6_len, sp_in, 0.5);
    sp_ap6_pos += 1; sp_ap6_pos >= sp_ap6_len ? sp_ap6_pos = 0;

    // Comb delays for spring bounce character (with feedback + damping)
    cm1_out = sp_cm1_buf[sp_cm1_pos];
    cm2_out = sp_cm2_buf[sp_cm2_pos];

    // Damping lowpass in the comb feedback
    sp_lp_l = sp_lp_l * sp_damp_coeff + cm1_out * (1 - sp_damp_coeff);
    sp_lp_r = sp_lp_r * sp_damp_coeff + cm2_out * (1 - sp_damp_coeff);

    sp_cm1_buf[sp_cm1_pos] = sp_in + sp_lp_l * 0.45;
    sp_cm2_buf[sp_cm2_pos] = sp_in + sp_lp_r * 0.40;
    sp_cm1_pos += 1; sp_cm1_pos >= sp_cm1_len ? sp_cm1_pos = 0;
    sp_cm2_pos += 1; sp_cm2_pos >= sp_cm2_len ? sp_cm2_pos = 0;

    // Stereo spring output (slightly different mix L/R)
    sp_out_l = cm1_out * 0.6 + cm2_out * 0.4;
    sp_out_r = cm1_out * 0.4 + cm2_out * 0.6;

    // Mix spring into wet signal
    wet_l += sp_out_l * spring_mix;
    wet_r += sp_out_r * spring_mix;
  );

  // --- Dry/Wet mix ---
  spl0 = spl0 * (1 - dry_wet) + wet_l * dry_wet;
  spl1 = spl1 * (1 - dry_wet) + wet_r * dry_wet;

  // Advance write position
  wpos += 1;
  wpos >= buf_max ? wpos = 0;

@gfx 520 420

// ============================================================================
//  COLOR PALETTE
// ============================================================================
COL_BG_R = 0.05; COL_BG_G = 0.05; COL_BG_B = 0.07;
COL_PANEL_R = 0.08; COL_PANEL_G = 0.08; COL_PANEL_B = 0.11;
COL_PANEL_HI_R = 0.12; COL_PANEL_HI_G = 0.12; COL_PANEL_HI_B = 0.16;
COL_BORDER_R = 0.20; COL_BORDER_G = 0.20; COL_BORDER_B = 0.25;
COL_TITLE_R = 0.95; COL_TITLE_G = 0.78; COL_TITLE_B = 0.35;
COL_SEC_R = 0.55; COL_SEC_G = 0.50; COL_SEC_B = 0.40;
COL_TEXT_R = 0.78; COL_TEXT_G = 0.78; COL_TEXT_B = 0.82;
COL_DIM_R = 0.38; COL_DIM_G = 0.38; COL_DIM_B = 0.42;
COL_ACCENT_R = 0.95; COL_ACCENT_G = 0.45; COL_ACCENT_B = 0.15;
COL_GREEN_R = 0.25; COL_GREEN_G = 0.80; COL_GREEN_B = 0.50;
COL_CYAN_R = 0.20; COL_CYAN_G = 0.60; COL_CYAN_B = 0.85;
COL_BAR_BG_R = 0.12; COL_BAR_BG_G = 0.12; COL_BAR_BG_B = 0.16;

// ============================================================================
//  BACKGROUND
// ============================================================================
gfx_r = COL_BG_R; gfx_g = COL_BG_G; gfx_b = COL_BG_B;
gfx_rect(0, 0, gfx_w, gfx_h);

// Top strip — darker header band
gfx_r = 0.03; gfx_g = 0.03; gfx_b = 0.05;
gfx_rect(0, 0, gfx_w, 42);

// Header accent line (warm gold)
gfx_r = COL_TITLE_R * 0.6; gfx_g = COL_TITLE_G * 0.6; gfx_b = COL_TITLE_B * 0.6;
gfx_rect(0, 42, gfx_w, 2);

// ============================================================================
//  HELPER: draw_bar — slick slider bar with glow fill
// ============================================================================
function draw_bar(bx, by, bw, bh, val, vmin, vmax, label, show_val) (
  // Bar background with subtle inset
  gfx_r = COL_BAR_BG_R; gfx_g = COL_BAR_BG_G; gfx_b = COL_BAR_BG_B;
  gfx_rect(bx, by, bw, bh);

  // Fill with gradient feel (brighter at top)
  norm = (val - vmin) / (vmax - vmin);
  norm = max(0, min(1, norm));
  fill_w = norm * bw;

  fill_w > 0 ? (
    gfx_r = COL_CYAN_R * 0.6; gfx_g = COL_CYAN_G * 0.6; gfx_b = COL_CYAN_B * 0.6;
    gfx_rect(bx, by, fill_w, bh);
    // Brighter top half for depth
    gfx_r = COL_CYAN_R * 0.8; gfx_g = COL_CYAN_G * 0.8; gfx_b = COL_CYAN_B * 0.8;
    gfx_rect(bx, by, fill_w, floor(bh / 2));
    // Bright edge line at top
    gfx_r = COL_CYAN_R; gfx_g = COL_CYAN_G; gfx_b = COL_CYAN_B;
    gfx_rect(bx, by, fill_w, 1);
  );

  // Thin border
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_rect(bx, by, bw, 1);
  gfx_rect(bx, by + bh - 1, bw, 1);
  gfx_rect(bx, by, 1, bh);
  gfx_rect(bx + bw - 1, by, 1, bh);

  // Label (left)
  gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
  gfx_setfont(1, "Arial", 12);
  gfx_x = bx + 5; gfx_y = by + floor((bh - 12) / 2);
  gfx_drawstr(label);

  // Value (right)
  show_val ? (
    gfx_setfont(1, "Arial", 11);
    gfx_x = bx + bw - 40; gfx_y = by + floor((bh - 11) / 2);
    gfx_drawnumber(val, val == floor(val) ? 0 : 1);
  );

  // Drag
  mouse_cap & 1 ? (
    mouse_x >= bx && mouse_x <= bx + bw &&
    mouse_y >= by && mouse_y <= by + bh ? (
      new_norm = (mouse_x - bx) / bw;
      new_norm = max(0, min(1, new_norm));
      val = vmin + new_norm * (vmax - vmin);
    );
  );

  val;
);

// ============================================================================
//  HELPER: draw_panel — section panel with header bar
// ============================================================================
function draw_panel(px, py, pw, ph, title) (
  // Panel body
  gfx_r = COL_PANEL_R; gfx_g = COL_PANEL_G; gfx_b = COL_PANEL_B;
  gfx_rect(px, py, pw, ph);

  // Header bar
  gfx_r = COL_PANEL_HI_R; gfx_g = COL_PANEL_HI_G; gfx_b = COL_PANEL_HI_B;
  gfx_rect(px, py, pw, 22);

  // Header bottom accent
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_rect(px, py + 22, pw, 1);

  // Panel border
  gfx_r = COL_BORDER_R * 0.7; gfx_g = COL_BORDER_G * 0.7; gfx_b = COL_BORDER_B * 0.7;
  gfx_rect(px, py, pw, 1);
  gfx_rect(px, py, 1, ph);
  gfx_rect(px + pw - 1, py, 1, ph);
  gfx_rect(px, py + ph - 1, pw, 1);

  // Title text
  gfx_r = COL_SEC_R; gfx_g = COL_SEC_G; gfx_b = COL_SEC_B;
  gfx_setfont(1, "Arial", 12);
  gfx_x = px + 8; gfx_y = py + 4;
  gfx_drawstr(title);
);

// ============================================================================
//  HELPER: draw_mode_sel — clickable mode selector display
// ============================================================================
function draw_mode_sel(mx, my, label, value_str) (
  gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
  gfx_setfont(1, "Arial", 11);
  gfx_x = mx; gfx_y = my;
  gfx_drawstr(label);
  gfx_r = COL_ACCENT_R; gfx_g = COL_ACCENT_G; gfx_b = COL_ACCENT_B;
  gfx_setfont(1, "Arial", 12);
  gfx_drawstr("  ");
  gfx_drawstr(value_str);
);

// ============================================================================
//  TITLE BAR
// ============================================================================
gfx_r = COL_TITLE_R; gfx_g = COL_TITLE_G; gfx_b = COL_TITLE_B;
gfx_setfont(1, "Arial", 20);
gfx_x = 14; gfx_y = 8;
gfx_drawstr("HENGE DELAY");

// UFO — top right area of header
ufo_cx = gfx_w - 55;
ufo_cy = 20;
// Saucer body (ellipse)
gfx_r = 0.5; gfx_g = 0.6; gfx_b = 0.7; gfx_a = 0.9;
gfx_circle(ufo_cx, ufo_cy, 18, 0);
gfx_circle(ufo_cx, ufo_cy, 17, 0);
gfx_rect(ufo_cx - 18, ufo_cy - 2, 36, 5);
// Dome
gfx_r = 0.6; gfx_g = 0.8; gfx_b = 1.0; gfx_a = 0.8;
gfx_circle(ufo_cx, ufo_cy - 4, 8, 0);
gfx_circle(ufo_cx, ufo_cy - 4, 7, 0);
// Beam (tractor beam triangle)
gfx_r = 0.4; gfx_g = 0.9; gfx_b = 0.5; gfx_a = 0.15;
gfx_triangle(ufo_cx - 5, ufo_cy + 3, ufo_cx + 5, ufo_cy + 3, ufo_cx - 12, ufo_cy + 28, ufo_cx + 12, ufo_cy + 28);
gfx_a = 1;

// ============================================================================
//  TAPE VISUALIZATION AREA (reels, heads, tape path)
// ============================================================================
viz_top = 46;
viz_h = 140;

// Visualization background (slightly lighter panel)
gfx_r = 0.06; gfx_g = 0.06; gfx_b = 0.09;
gfx_rect(0, viz_top, gfx_w, viz_h);

// --- Tape reels ---
reel_angle += 0.02 + intensity * 0.03;
reel_angle >= 2 * $pi ? reel_angle -= 2 * $pi;

reel_cx1 = gfx_w * 0.3;
reel_cx2 = gfx_w * 0.7;
reel_cy = viz_top + viz_h * 0.55;
reel_r = min(gfx_w * 0.10, viz_h * 0.35);

// Left reel
gfx_r = 0.18; gfx_g = 0.22; gfx_b = 0.18;
gfx_circle(reel_cx1, reel_cy, reel_r, 1);
gfx_r = 0.08; gfx_g = 0.10; gfx_b = 0.08;
gfx_circle(reel_cx1, reel_cy, reel_r * 0.4, 1);
// Spokes
gfx_r = 0.30; gfx_g = 0.35; gfx_b = 0.28;
i = 0;
loop(3,
  a = reel_angle + i * 2 * $pi / 3;
  gfx_line(reel_cx1, reel_cy,
           reel_cx1 + cos(a) * reel_r * 0.85,
           reel_cy + sin(a) * reel_r * 0.85);
  i += 1;
);

// Right reel
gfx_r = 0.18; gfx_g = 0.22; gfx_b = 0.18;
gfx_circle(reel_cx2, reel_cy, reel_r, 1);
gfx_r = 0.08; gfx_g = 0.10; gfx_b = 0.08;
gfx_circle(reel_cx2, reel_cy, reel_r * 0.4, 1);
gfx_r = 0.30; gfx_g = 0.35; gfx_b = 0.28;
i = 0;
loop(3,
  a = -reel_angle + i * 2 * $pi / 3;
  gfx_line(reel_cx2, reel_cy,
           reel_cx2 + cos(a) * reel_r * 0.85,
           reel_cy + sin(a) * reel_r * 0.85);
  i += 1;
);

// Tape path between reels
gfx_r = 0.4; gfx_g = 0.35; gfx_b = 0.25;
tape_y = reel_cy - reel_r - 5;
gfx_line(reel_cx1, tape_y, reel_cx2, tape_y);

// --- Head indicators ---
head_y = tape_y - 12;
head_spacing = (reel_cx2 - reel_cx1) / 4;

// Head 1
h1_on ? ( gfx_r = COL_GREEN_R; gfx_g = COL_GREEN_G; gfx_b = COL_GREEN_B; )
      : ( gfx_r = 0.15; gfx_g = 0.18; gfx_b = 0.14; );
hx = reel_cx1 + head_spacing;
gfx_rect(hx - 4, head_y - 6, 8, 12);
gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
gfx_setfont(1, "Arial", 10);
gfx_x = hx - 2; gfx_y = head_y - 20;
gfx_drawstr("1");

// Head 2
h2_on ? ( gfx_r = COL_GREEN_R; gfx_g = COL_GREEN_G; gfx_b = COL_GREEN_B; )
      : ( gfx_r = 0.15; gfx_g = 0.18; gfx_b = 0.14; );
hx = reel_cx1 + head_spacing * 2;
gfx_rect(hx - 4, head_y - 6, 8, 12);
gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
gfx_setfont(1, "Arial", 10);
gfx_x = hx - 2; gfx_y = head_y - 20;
gfx_drawstr("2");

// Head 3
h3_on ? ( gfx_r = COL_GREEN_R; gfx_g = COL_GREEN_G; gfx_b = COL_GREEN_B; )
      : ( gfx_r = 0.15; gfx_g = 0.18; gfx_b = 0.14; );
hx = reel_cx1 + head_spacing * 3;
gfx_rect(hx - 4, head_y - 6, 8, 12);
gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
gfx_setfont(1, "Arial", 10);
gfx_x = hx - 2; gfx_y = head_y - 20;
gfx_drawstr("3");

// Visualization bottom border
gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
gfx_rect(0, viz_top + viz_h, gfx_w, 1);

// ============================================================================
//  CONTROL PANELS — Two columns below tape visualization
// ============================================================================
margin = 8;
gap = 6;
bar_h = 18;
bar_sp = 21;
pad = 8;
ctrl_top = viz_top + viz_h + 6;
col_w = floor((gfx_w - margin * 2 - gap) / 2);
left_x = margin;
right_x = margin + col_w + gap;
panel_h = 148;

// ---- LEFT PANEL: DELAY ----
draw_panel(left_x, ctrl_top, col_w, panel_h, "DELAY");
inner_w = col_w - pad * 2;
cy = ctrl_top + 26;

// Mode selector (click to cycle through 7 options)
mode == 0 ? draw_mode_sel(left_x + pad, cy, "MODE:", "Head 1")
: mode == 1 ? draw_mode_sel(left_x + pad, cy, "MODE:", "Head 2")
: mode == 2 ? draw_mode_sel(left_x + pad, cy, "MODE:", "Head 3")
: mode == 3 ? draw_mode_sel(left_x + pad, cy, "MODE:", "1+2")
: mode == 4 ? draw_mode_sel(left_x + pad, cy, "MODE:", "1+3")
: mode == 5 ? draw_mode_sel(left_x + pad, cy, "MODE:", "2+3")
: draw_mode_sel(left_x + pad, cy, "MODE:", "All");

(mouse_cap & 1) && !(last_cap & 1) &&
  mouse_x >= left_x + pad && mouse_x <= left_x + pad + inner_w &&
  mouse_y >= cy && mouse_y <= cy + 16 ? (
    slider1 = (slider1 + 1) % 7;
);
cy += bar_sp;

slider2 = draw_bar(left_x + pad, cy, inner_w, bar_h, slider2, 50, 1000, "RATE", 1);
cy += bar_sp;
slider3 = draw_bar(left_x + pad, cy, inner_w, bar_h, slider3, 0, 100, "INTENSITY", 1);
cy += bar_sp;
slider4 = draw_bar(left_x + pad, cy, inner_w, bar_h, slider4, 0, 100, "ECHO VOL", 1);
cy += bar_sp;
slider10 = draw_bar(left_x + pad, cy, inner_w, bar_h, slider10, 0, 100, "DRY/WET", 1);

// ---- RIGHT PANEL: CHARACTER ----
draw_panel(right_x, ctrl_top, col_w, panel_h, "CHARACTER");
inner_w = col_w - pad * 2;
cy = ctrl_top + 26;

slider5 = draw_bar(right_x + pad, cy, inner_w, bar_h, slider5, 0, 100, "BASS", 1);
cy += bar_sp;
slider6 = draw_bar(right_x + pad, cy, inner_w, bar_h, slider6, 0, 100, "TREBLE", 1);
cy += bar_sp;
slider7 = draw_bar(right_x + pad, cy, inner_w, bar_h, slider7, 0, 100, "WOW&FLUT", 1);
cy += bar_sp;
slider8 = draw_bar(right_x + pad, cy, inner_w, bar_h, slider8, 0, 100, "TAPE AGE", 1);
cy += bar_sp;
slider9 = draw_bar(right_x + pad, cy, inner_w, bar_h, slider9, 0, 100, "SPRING", 1);
  // ============================================================
  // INSTANCE MANAGER PANEL
  // ============================================================
  bc_panel_h = bc_panel_expanded ? 90 : 30;
  bc_panel_y = gfx_h - bc_panel_h;

  gfx_r = 0.04; gfx_g = 0.04; gfx_b = 0.06;
  gfx_rect(0, bc_panel_y, gfx_w, bc_panel_h);
  gfx_r = 0.15; gfx_g = 0.15; gfx_b = 0.20;
  gfx_rect(0, bc_panel_y, gfx_w, 1);

  gfx_setfont(1, "Arial", 11);
  gfx_r = 0.95; gfx_g = 0.45; gfx_b = 0.15;
  gfx_x = 8; gfx_y = bc_panel_y + 8;
  bc_my_slot >= 0 ? (
    gfx_drawstr("I");
    gfx_drawnumber(bc_my_slot + 1, 0);
    gfx_drawstr("/");
    gfx_drawnumber(bc_instance_count, 0);
  ) : (
    gfx_drawstr("--");
  );

  bc_following > 0 ? (
    gfx_r = 0.2; gfx_g = 0.8; gfx_b = 0.3;
    gfx_drawstr("  Following: I");
    bc_fs = 0;
    loop(BC_MAX_INST,
      fsb = BC_MY_REGION + bc_fs * BC_SLOT_SIZE;
      gmem[fsb + 1] == bc_following ? (
        gfx_drawnumber(bc_fs + 1, 0);
        bc_fs = BC_MAX_INST;
      );
      bc_fs += 1;
    );
  ) : (
    gfx_r = 0.3; gfx_g = 0.3; gfx_b = 0.4;
    gfx_drawstr("  Following: --");
  );

  exp_x = gfx_w - 200;
  exp_y = bc_panel_y + 4;
  exp_w = 65;
  exp_h = 20;
  gfx_r = 0.12; gfx_g = 0.12; gfx_b = 0.16;
  gfx_rect(exp_x, exp_y, exp_w, exp_h);
  gfx_r = 0.5; gfx_g = 0.5; gfx_b = 0.6;
  gfx_x = exp_x + 5; gfx_y = exp_y + 4;
  bc_panel_expanded ? gfx_drawstr("COLLAPSE") : gfx_drawstr("EXPAND");
  (mouse_cap & 1) && !(last_cap & 1) &&
    mouse_x >= exp_x && mouse_x < exp_x + exp_w &&
    mouse_y >= exp_y && mouse_y < exp_y + exp_h ? (
    bc_panel_expanded = !bc_panel_expanded;
    bc_steal_mode = 0;
  );

  stl_x = gfx_w - 125;
  stl_y = bc_panel_y + 4;
  stl_w = 50;
  stl_h = 20;
  bc_steal_mode ? (
    gfx_r = 0.6; gfx_g = 0.2; gfx_b = 0.1;
  ) : (
    gfx_r = 0.2; gfx_g = 0.1; gfx_b = 0.1;
  );
  gfx_rect(stl_x, stl_y, stl_w, stl_h);
  gfx_r = 0.9; gfx_g = 0.5; gfx_b = 0.2;
  gfx_x = stl_x + 6; gfx_y = stl_y + 4;
  gfx_drawstr("STEAL");
  (mouse_cap & 1) && !(last_cap & 1) &&
    mouse_x >= stl_x && mouse_x < stl_x + stl_w &&
    mouse_y >= stl_y && mouse_y < stl_y + stl_h ? (
    bc_steal_mode = !bc_steal_mode;
    !bc_panel_expanded ? bc_panel_expanded = 1;
  );

  bc_following > 0 ? (
    unf_x = gfx_w - 65;
    unf_y = bc_panel_y + 4;
    unf_w = 55;
    unf_h = 20;
    gfx_r = 0.1; gfx_g = 0.2; gfx_b = 0.1;
    gfx_rect(unf_x, unf_y, unf_w, unf_h);
    gfx_r = 0.5; gfx_g = 0.9; gfx_b = 0.5;
    gfx_x = unf_x + 4; gfx_y = unf_y + 4;
    gfx_drawstr("UNFLW");
    (mouse_cap & 1) && !(last_cap & 1) &&
      mouse_x >= unf_x && mouse_x < unf_x + unf_w &&
      mouse_y >= unf_y && mouse_y < unf_y + unf_h ? (
      bc_following = 0;
      bc_follow_slot = -1;
    );
  );

  bc_panel_expanded ? (
    row_y = bc_panel_y + 30;
    row_h = 14;
    bc_s = 0;
    loop(BC_MAX_INST,
      isb = BC_MY_REGION + bc_s * BC_SLOT_SIZE;
      isid = gmem[isb + 1];
      isid > 0 ? (
        mouse_y >= row_y && mouse_y < row_y + row_h &&
          mouse_x >= 8 && mouse_x < gfx_w - 8 &&
          bc_s != bc_my_slot ? (
          gfx_r = 0.10; gfx_g = 0.10; gfx_b = 0.14;
          gfx_rect(4, row_y, gfx_w - 8, row_h);
        );
        gfx_setfont(1, "Arial", 10);
        bc_s == bc_my_slot ? (
          gfx_r = 0.95; gfx_g = 0.45; gfx_b = 0.15;
        ) : (
          gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.8;
        );
        gfx_x = 12; gfx_y = row_y + 1;
        gfx_drawstr("I");
        gfx_drawnumber(bc_s + 1, 0);
        gfx_drawstr("  ");
        bc_s == bc_my_slot ? (
          gfx_drawstr("[YOU]");
        ) : (
          iwho = gmem[isb + 3];
          iwho > 0 ? (
            gfx_drawstr("[>I");
            iw = 0;
            loop(BC_MAX_INST,
              iwsb = BC_MY_REGION + iw * BC_SLOT_SIZE;
              gmem[iwsb + 1] == iwho ? (
                gfx_drawnumber(iw + 1, 0);
                iw = BC_MAX_INST;
              );
              iw += 1;
            );
            gfx_drawstr("]");
          ) : (
            gfx_drawstr("[LEADER]");
          );
          gfx_r = 0.35; gfx_g = 0.45; gfx_b = 0.35;
          bc_steal_mode ? (
            gfx_drawstr("  click: steal");
          ) : (
            gfx_drawstr("  click: follow");
          );
          (mouse_cap & 1) && !(last_cap & 1) &&
            mouse_y >= row_y && mouse_y < row_y + row_h &&
            mouse_x >= 8 && mouse_x < gfx_w - 8 ? (
            bc_steal_mode ? (
              bc_steal_target = isid;
              bc_steal_pending = 1;
              bc_steal_mode = 0;
            ) : (
              bc_can_follow = 1;
              bc_cursor = isid;
              bc_hops = 0;
              while(bc_cursor > 0 && bc_hops < BC_MAX_INST) (
                bc_cursor == bc_my_id ? (
                  bc_can_follow = 0;
                  bc_cursor = 0;
                ) : (
                  bc_next = 0;
                  bc_cs = 0;
                  loop(BC_MAX_INST,
                    csb = BC_MY_REGION + bc_cs * BC_SLOT_SIZE;
                    gmem[csb + 1] == bc_cursor ? (
                      bc_next = gmem[csb + 3];
                      bc_cs = BC_MAX_INST;
                    );
                    bc_cs += 1;
                  );
                  bc_cursor = bc_next;
                );
                bc_hops += 1;
              );
              bc_can_follow ? (
                bc_following = isid;
              );
            );
          );
        );
        row_y += row_h;
      );
      bc_s += 1;
    );
  );

  last_cap = mouse_cap;

  // --- NOTICE BUTTON ---
  notice_btn_x = gfx_w - 60;
  notice_btn_y = bc_panel_y - 18;
  gfx_r = 0.6; gfx_g = 0.5; gfx_b = 0.3;
  gfx_rect(notice_btn_x, notice_btn_y, 55, 15);
  gfx_r = 0; gfx_g = 0; gfx_b = 0;
  gfx_x = notice_btn_x + 4; gfx_y = notice_btn_y + 2;
  gfx_drawstr("NOTICE");
  (mouse_cap & 1) && mouse_x >= notice_btn_x && mouse_x <= notice_btn_x + 55 && mouse_y >= notice_btn_y && mouse_y <= notice_btn_y + 15 && !notice_clicked ? (
    notice_show = !notice_show;
    notice_clicked = 1;
  );
  !(mouse_cap & 1) ? notice_clicked = 0;
  notice_show ? (
    gfx_r = 0.05; gfx_g = 0.05; gfx_b = 0.05; gfx_a = 0.95;
    gfx_rect(0, 0, gfx_w, gfx_h);
    gfx_a = 1;
    gfx_r = 0.9; gfx_g = 0.8; gfx_b = 0.5;
    gfx_x = 15; gfx_y = 10;
    gfx_drawstr("NOTICE: THEY ARE TRYING TO STEAL YOUR COMPUTER");
    gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.7;
    gfx_x = 15; gfx_y = 30;
    gfx_drawstr("The algorithms in our favorite software are decades old.");
    gfx_x = 15; gfx_y = 45;
    gfx_drawstr("A mathematical model is a truth about the world,");
    gfx_x = 15; gfx_y = 60;
    gfx_drawstr("not a copyrightable product. You do not have to stay");
    gfx_x = 15; gfx_y = 75;
    gfx_drawstr("a slave to subscription software. Install Linux.");
    gfx_x = 15; gfx_y = 90;
    gfx_drawstr("Build your own tools. Believe in yourself.");
    gfx_r = 0.5; gfx_g = 0.7; gfx_b = 1.0;
    gfx_x = 15; gfx_y = 115;
    gfx_drawstr("github.com/LMSBAND  |  instagram.com/LMSSKABAND");
    gfx_r = 0.4; gfx_g = 0.4; gfx_b = 0.4;
    gfx_x = 15; gfx_y = 140;
    gfx_r = 0.6; gfx_g = 0.5; gfx_b = 0.3;
    gfx_rect(notice_btn_x, notice_btn_y, 55, 15);
    gfx_r = 0; gfx_g = 0; gfx_b = 0;
    gfx_x = notice_btn_x + 4; gfx_y = notice_btn_y + 2;
    gfx_drawstr("NOTICE");
  );

// ============================================================
// @SERIALIZE — Persist follow state
// ============================================================
@serialize
file_var(0, bc_following);
file_var(0, bc_my_id);
