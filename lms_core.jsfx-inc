// ============================================================================
//  LMS Core DSP Library v1.0
//  Shared DSP building blocks for the LMS plugin suite
//
//  Usage: import lms_core.jsfx-inc
//
//  IMPORTANT: All functions must be inside @init so they are available
//  across all sections (@slider, @block, @sample, @gfx) in importing files.
//  JSFX rule: "functions defined in @init can be used from other sections,
//  whereas functions defined in other sections are local to those sections."
//
//  All functions use lms_ prefix. Stateful functions use this.* pattern —
//  call as instance.lms_xxx() to get independent state per instance.
//
//  Sections:
//    1. Math Utilities           (stateless)
//    2. Biquad Filter            (stereo + mono, this.* state)
//    3. Saturation Suite         (density-aware triode architecture, this.* state)
//    4. Compressor               (stereo FET, this.* state)
//    5. DC Blocker               (stereo, this.* state)
//    6. Tone Filter              (stereo 1-pole LP, this.* state)
//    7. Cubic Interpolation      (stateless)
//    8. Spring Reverb Allpass    (stateless, buffer-based)
// ============================================================================

@init

// ============================================================================
//  SECTION 1: Math Utilities (stateless)
// ============================================================================

// Bounded exp-based tanh approximation (JSFX has no built-in tanh)
function lms_tanh(x)
  local(e2x)
(
  x > 10 ? 1 : x < -10 ? -1 : (
    e2x = exp(2 * x);
    (e2x - 1) / (e2x + 1);
  );
);

// dB to linear gain
function lms_db2lin(db)
(
  10 ^ (db / 20);
);

// Linear gain to dB (safe — returns -140 for silence)
function lms_lin2db(lin)
(
  lin > 0.0000001 ? 20 * log10(lin) : -140;
);


// ADAA core (used by lms_sat_harmonics for polynomial anti-aliasing): given x_now, x_prev, F(x_now), F(x_prev), f(midpoint) fallback
// Returns the alias-suppressed output sample.
//
// Uses a crossfade zone instead of a hard epsilon switch. A single threshold
// creates a "no man's land" where dx is small enough for the division to amplify
// floating-point noise but not small enough to trigger fallback — this manifests
// as hiss on note decay tails. The crossfade blends smoothly between ADAA and
// fallback, eliminating both the hard-switch artifact and the noisy-division zone.
function lms_adaa_eval(x_now, x_prev, Fx_now, Fx_prev, f_mid)
  local(dx, adx, adaa_out, blend)
(
  dx  = x_now - x_prev;
  adx = abs(dx);
  adx < 0.00001 ? (
    f_mid;
  ) : adx > 0.0001 ? (
    (Fx_now - Fx_prev) / dx;
  ) : (
    adaa_out = (Fx_now - Fx_prev) / dx;
    blend = (adx - 0.00001) / (0.00009);  // 0..1 across the transition band
    f_mid + blend * (adaa_out - f_mid);
  );
);


// ============================================================================
//  SECTION 2: Biquad Filter (stereo, this.* state)
//
//  One instance = one stereo band.
//  Coefficients shared, L/R state separate.
//
//  Usage:
//    @init:   hp.lms_bq_init();
//    @slider: hp.lms_bq_set_hp(freq, 0.707);
//    @block:  hp.lms_bq_set_hp(freq, 0.707);
//    @sample: l = hp.lms_bq_proc_l(l);
//             r = hp.lms_bq_proc_r(r);
// ============================================================================

// Initialize biquad — zero state and set to passthrough
function lms_bq_init()
(
  // Coefficients (passthrough)
  this.b0 = 1; this.b1 = 0; this.b2 = 0;
  this.a1 = 0; this.a2 = 0;
  // Left channel state
  this.lx1 = 0; this.lx2 = 0;
  this.ly1 = 0; this.ly2 = 0;
  // Right channel state
  this.rx1 = 0; this.rx2 = 0;
  this.ry1 = 0; this.ry2 = 0;
);

// Highpass (2nd order Butterworth when q = 0.707)
function lms_bq_set_hp(freq, q)
  local(w0, cs, sn, alpha, a0_inv)
(
  w0 = 2 * $pi * freq / srate;
  cs = cos(w0); sn = sin(w0);
  alpha = sn / (2 * q);
  a0_inv = 1 / (1 + alpha);
  this.b0 = (1 + cs) / 2 * a0_inv;
  this.b1 = -(1 + cs) * a0_inv;
  this.b2 = (1 + cs) / 2 * a0_inv;
  this.a1 = -2 * cs * a0_inv;
  this.a2 = (1 - alpha) * a0_inv;
);

// Lowpass
function lms_bq_set_lp(freq, q)
  local(w0, cs, sn, alpha, a0_inv)
(
  w0 = 2 * $pi * freq / srate;
  cs = cos(w0); sn = sin(w0);
  alpha = sn / (2 * q);
  a0_inv = 1 / (1 + alpha);
  this.b0 = (1 - cs) / 2 * a0_inv;
  this.b1 = (1 - cs) * a0_inv;
  this.b2 = (1 - cs) / 2 * a0_inv;
  this.a1 = -2 * cs * a0_inv;
  this.a2 = (1 - alpha) * a0_inv;
);

// Bandpass (constant skirt gain)
function lms_bq_set_bp(freq, q)
  local(w0, cs, sn, alpha, a0_inv)
(
  w0 = 2 * $pi * freq / srate;
  cs = cos(w0); sn = sin(w0);
  alpha = sn / (2 * q);
  a0_inv = 1 / (1 + alpha);
  this.b0 = (sn / 2) * a0_inv;
  this.b1 = 0;
  this.b2 = -(sn / 2) * a0_inv;
  this.a1 = -2 * cs * a0_inv;
  this.a2 = (1 - alpha) * a0_inv;
);

// Parametric peaking EQ
function lms_bq_set_peak(freq, gain_db, q)
  local(a, w0, alpha, a0_inv)
(
  a = 10 ^ (gain_db / 20);
  w0 = 2 * $pi * freq / srate;
  alpha = sin(w0) / (2 * q);
  a0_inv = 1 / (1 + alpha / a);
  this.b0 = (1 + alpha * a) * a0_inv;
  this.b1 = (-2 * cos(w0)) * a0_inv;
  this.b2 = (1 - alpha * a) * a0_inv;
  this.a1 = this.b1;
  this.a2 = (1 - alpha / a) * a0_inv;
);

// Low shelf
function lms_bq_set_loshelf(freq, gain_db, q)
  local(a, w0, cs, sn, alpha, ap1, am1, beta, a0_inv)
(
  a = 10 ^ (gain_db / 40);
  w0 = 2 * $pi * freq / srate;
  cs = cos(w0); sn = sin(w0);
  alpha = sn / (2 * q);
  ap1 = a + 1; am1 = a - 1;
  beta = 2 * sqrt(a) * alpha;
  a0_inv = 1 / (ap1 + am1 * cs + beta);
  this.b0 = a * (ap1 - am1 * cs + beta) * a0_inv;
  this.b1 = 2 * a * (am1 - ap1 * cs) * a0_inv;
  this.b2 = a * (ap1 - am1 * cs - beta) * a0_inv;
  this.a1 = -2 * (am1 + ap1 * cs) * a0_inv;
  this.a2 = (ap1 + am1 * cs - beta) * a0_inv;
);

// High shelf
function lms_bq_set_hishelf(freq, gain_db, q)
  local(a, w0, cs, sn, alpha, ap1, am1, beta, a0_inv)
(
  a = 10 ^ (gain_db / 40);
  w0 = 2 * $pi * freq / srate;
  cs = cos(w0); sn = sin(w0);
  alpha = sn / (2 * q);
  ap1 = a + 1; am1 = a - 1;
  beta = 2 * sqrt(a) * alpha;
  a0_inv = 1 / (ap1 - am1 * cs + beta);
  this.b0 = a * (ap1 + am1 * cs + beta) * a0_inv;
  this.b1 = -2 * a * (am1 + ap1 * cs) * a0_inv;
  this.b2 = a * (ap1 + am1 * cs - beta) * a0_inv;
  this.a1 = 2 * (am1 - ap1 * cs) * a0_inv;
  this.a2 = (ap1 - am1 * cs - beta) * a0_inv;
);

// Process left channel sample through biquad
function lms_bq_proc_l(x)
  local(o)
(
  o = this.b0 * x + this.b1 * this.lx1 + this.b2 * this.lx2
                   - this.a1 * this.ly1 - this.a2 * this.ly2;
  this.lx2 = this.lx1; this.lx1 = x;
  this.ly2 = this.ly1; this.ly1 = o;
  o;
);

// Process right channel sample through biquad
function lms_bq_proc_r(x)
  local(o)
(
  o = this.b0 * x + this.b1 * this.rx1 + this.b2 * this.rx2
                   - this.a1 * this.ry1 - this.a2 * this.ry2;
  this.rx2 = this.rx1; this.rx1 = x;
  this.ry2 = this.ry1; this.ry1 = o;
  o;
);

// Process mono sample through biquad (uses lx/ly state — do NOT mix with proc_l)
function lms_bq_proc(x)
  local(o)
(
  o = this.b0 * x + this.b1 * this.lx1 + this.b2 * this.lx2
                   - this.a1 * this.ly1 - this.a2 * this.ly2;
  this.lx2 = this.lx1; this.lx1 = x;
  this.ly2 = this.ly1; this.ly1 = o;
  o;
);


// ============================================================================
//  SECTION 3: Saturation Suite (density-aware triode architecture)
//
//  All functions use this.* state for density tracking, bias shift,
//  grid conduction, Miller LP, air shelf, and DC blocking.
//  Call <instance>.lms_sat_XXX_init() once in @init, then
//  call <instance>.lms_sat_XXX(x, drive, bias) per sample.
//
//  Each mode models a different tube/device character by varying the
//  clipping curve shape (pos_hard, neg_hard, pos_ceil, neg_ceil).
//  The density-aware architecture (4-band tracker, bias shift, grid
//  conduction, Miller LP, air shelf) is shared across all modes —
//  identical to the v2 amp sim triode stages.
//
//  Usage:
//    @init:   sat.lms_sat_warm_init();
//    @sample: l = sat.lms_sat_warm(l, drive, bias);
// ============================================================================

// ---- Shared density-aware saturation init ----
function lms_sat_da_init() (
  // Coupling cap bias shift
  this.cap_charge = 0.0;
  this.cap_charge_rate = exp(-1/(srate * 0.0005));
  this.cap_drain_rate = exp(-1/(srate * 0.030));
  // 4-band density tracker
  this.hd_f_lo.lms_bq_init(); this.hd_f_lo.lms_bq_set_lp(250, 0.7);
  this.hd_f_mid_lo.lms_bq_init(); this.hd_f_mid_lo.lms_bq_set_lp(2000, 0.7);
  this.hd_f_mid_hi.lms_bq_init(); this.hd_f_mid_hi.lms_bq_set_hp(250, 0.7);
  this.hd_f_hi.lms_bq_init(); this.hd_f_hi.lms_bq_set_hp(2000, 0.7);
  this.hd_f_air.lms_bq_init(); this.hd_f_air.lms_bq_set_hp(5000, 0.7);
  this.hd_env_lo = 0; this.hd_env_mid = 0; this.hd_env_hi = 0;
  this.hd_env_air = 0; this.hd_env_total = 0;
  this.hd_att = exp(-1/(srate * 0.002));
  this.hd_rel = exp(-1/(srate * 0.080));
  this.hd_density = 1.0; this.hd_mid_density = 0.0;
  this.hd_hi_density = 0.0; this.hd_air_density = 0.0;
  this.hd_smooth = exp(-1/(srate * 0.030));
  // Miller LP (density-driven cutoff)
  this.miller.lms_bq_init();
  this.miller.lms_bq_set_lp(8000, 0.6);
  this.miller_base_freq = 8000;
  this.last_miller_freq = 8000;
  this.last_miller_q = 0.6;
  // Air shelf (density-driven HF control)
  this.air_shelf.lms_bq_init();
  this.air_shelf.lms_bq_set_hishelf(5000, 0.0, 0.7);
  this.last_air_cut = 0.0;
  // Grid conduction peak envelope
  this.peak_env = 0;
  this.peak_att = exp(-1/(srate * 0.0002));
  this.peak_rel = exp(-1/(srate * 0.050));
  // DC blocker
  this.dc_xp = 0; this.dc_yp = 0; this.dc_r = 1 - (20 / srate);
);

// ---- Shared density tracker (inline, uses this.hd_* state) ----
function lms_sat_da_hd_proc(x)
  local(lo, mid, hi, air, abs_lo, abs_mid, abs_hi, abs_air, abs_total,
        raw, raw_mid, raw_hi, raw_air)
(
  lo = this.hd_f_lo.lms_bq_proc(x);
  mid = this.hd_f_mid_hi.lms_bq_proc(this.hd_f_mid_lo.lms_bq_proc(x));
  hi = this.hd_f_hi.lms_bq_proc(x);
  air = this.hd_f_air.lms_bq_proc(x);
  abs_lo = abs(lo); abs_mid = abs(mid); abs_hi = abs(hi);
  abs_air = abs(air); abs_total = abs(x);
  abs_lo > this.hd_env_lo ? (
    this.hd_env_lo = this.hd_att * this.hd_env_lo + (1 - this.hd_att) * abs_lo;
  ) : (
    this.hd_env_lo = this.hd_rel * this.hd_env_lo + (1 - this.hd_rel) * abs_lo;
  );
  abs_mid > this.hd_env_mid ? (
    this.hd_env_mid = this.hd_att * this.hd_env_mid + (1 - this.hd_att) * abs_mid;
  ) : (
    this.hd_env_mid = this.hd_rel * this.hd_env_mid + (1 - this.hd_rel) * abs_mid;
  );
  abs_hi > this.hd_env_hi ? (
    this.hd_env_hi = this.hd_att * this.hd_env_hi + (1 - this.hd_att) * abs_hi;
  ) : (
    this.hd_env_hi = this.hd_rel * this.hd_env_hi + (1 - this.hd_rel) * abs_hi;
  );
  abs_air > this.hd_env_air ? (
    this.hd_env_air = this.hd_att * this.hd_env_air + (1 - this.hd_att) * abs_air;
  ) : (
    this.hd_env_air = this.hd_rel * this.hd_env_air + (1 - this.hd_rel) * abs_air;
  );
  abs_total > this.hd_env_total ? (
    this.hd_env_total = this.hd_att * this.hd_env_total + (1 - this.hd_att) * abs_total;
  ) : (
    this.hd_env_total = this.hd_rel * this.hd_env_total + (1 - this.hd_rel) * abs_total;
  );
  this.hd_env_lo > 0.0001 ? (
    raw = this.hd_env_total / this.hd_env_lo;
    raw = min(2.5, max(1.0, raw));
  ) : ( raw = 1.0; );
  this.hd_env_total > 0.0001 ? (
    raw_mid = this.hd_env_mid / this.hd_env_total;
    raw_mid = min(1.0, max(0.0, raw_mid));
    raw_hi = this.hd_env_hi / this.hd_env_total;
    raw_hi = min(1.0, max(0.0, raw_hi));
    raw_air = this.hd_env_air / this.hd_env_total;
    raw_air = min(1.0, max(0.0, raw_air));
  ) : ( raw_mid = 0.0; raw_hi = 0.0; raw_air = 0.0; );
  this.hd_density = this.hd_smooth * this.hd_density + (1 - this.hd_smooth) * raw;
  this.hd_mid_density = this.hd_smooth * this.hd_mid_density + (1 - this.hd_smooth) * raw_mid;
  this.hd_hi_density = this.hd_smooth * this.hd_hi_density + (1 - this.hd_smooth) * raw_hi;
  this.hd_air_density = this.hd_smooth * this.hd_air_density + (1 - this.hd_smooth) * raw_air;
);

// ---- Shared density-aware saturation core ----
// pos_hard/neg_hard: clipping hardness (higher = harder clip)
// pos_ceil/neg_ceil: clipping ceiling (output bounded to these)
// gc_thresh/gc_amount: grid conduction threshold and squash amount
function lms_sat_da_proc(x, drive, bias, pos_hard, neg_hard, pos_ceil, neg_ceil, gc_thresh, gc_amount)
  local(b, gain, bias_shift, p_ceil, n_ceil, gc_out, lp_freq, lp_q,
        air_cut, drive_boost, ax)
(
  // 1. Coupling cap bias shift
  b = x + bias * 0.1;
  b > 0.1 ? (
    this.cap_charge = this.cap_charge_rate * this.cap_charge
                    + (1 - this.cap_charge_rate) * b * 0.12;
  ) : (
    this.cap_charge = this.cap_drain_rate * this.cap_charge;
  );
  bias_shift = this.cap_charge;
  b = b - bias_shift;

  // 2. Density-driven drive boost (mid density pushes tube harder)
  drive_boost = 1.0 + this.hd_mid_density * 0.4;
  gain = (1.0 + drive * 4.0) * drive_boost;
  b = b * gain;

  // 3. Run density tracker on pre-clip signal
  this.lms_sat_da_hd_proc(b);

  // 4. Fixed clipping curves — ceiling is constant (no PSU in standalone sat)
  p_ceil = pos_ceil;
  n_ceil = neg_ceil;
  b >= 0 ? (
    b = lms_tanh(b * pos_hard) * p_ceil;
  ) : (
    b = lms_tanh(b * neg_hard) * n_ceil;
  );

  // 5. Grid conduction (peak envelope gated soft clamp)
  ax = abs(b);
  ax > this.peak_env ? (
    this.peak_env = this.peak_att * this.peak_env + (1 - this.peak_att) * ax;
  ) : (
    this.peak_env = this.peak_rel * this.peak_env + (1 - this.peak_rel) * ax;
  );
  b > gc_thresh && this.peak_env > gc_thresh * 0.8 ? (
    gc_out = gc_thresh + lms_tanh((b - gc_thresh) * 3.0) * gc_amount;
    b = gc_out;
  );

  // 6. Miller LP — density drives cutoff (AFTER clipping, on output)
  lp_freq = this.miller_base_freq - (this.hd_density - 1.0) * 500;
  lp_freq = max(this.miller_base_freq - 1500, min(this.miller_base_freq + 500, lp_freq));
  lp_q = 0.6 + this.hd_hi_density * 0.35;
  lp_q = max(0.6, min(0.95, lp_q));
  abs(lp_freq - this.last_miller_freq) > 30 || abs(lp_q - this.last_miller_q) > 0.02 ? (
    this.miller.lms_bq_set_lp(lp_freq, lp_q);
    this.last_miller_freq = lp_freq;
    this.last_miller_q = lp_q;
  );
  b = this.miller.lms_bq_proc(b);

  // 7. Air shelf — density-driven HF control
  air_cut = -this.hd_air_density * 3.0;
  air_cut = max(-3.0, min(0.0, air_cut));
  abs(air_cut - this.last_air_cut) > 0.1 ? (
    this.air_shelf.lms_bq_set_hishelf(5000, air_cut, 0.7);
    this.last_air_cut = air_cut;
  );
  b = this.air_shelf.lms_bq_proc(b);

  // 8. DC block
  this.dc_yp = b - this.dc_xp + this.dc_r * this.dc_yp;
  this.dc_xp = b;
  b = this.dc_yp;

  b;
);


// ---- lms_sat_warm — warm tube (soft symmetric, high ceiling, gentle) ----

function lms_sat_warm_init() ( this.lms_sat_da_init(); );

function lms_sat_warm(x, drive, bias) (
  // Warm tube: soft positive, slightly softer negative, high ceiling
  // pos_hard=1.2, neg_hard=0.9, pos_ceil=0.85, neg_ceil=1.0, gc_thresh=0.30, gc_amount=0.15
  this.lms_sat_da_proc(x, drive, bias, 1.2, 0.9, 0.85, 1.0, 0.30, 0.15);
);


// ---- lms_sat_hot — hot tube (pushed 12AX7, harder asymmetric) ----

function lms_sat_hot_init() ( this.lms_sat_da_init(); );

function lms_sat_hot(x, drive, bias) (
  // Hot tube: hard positive, moderate negative, tighter ceiling
  // pos_hard=1.8, neg_hard=1.4, pos_ceil=0.75, neg_ceil=0.95, gc_thresh=0.25, gc_amount=0.18
  this.lms_sat_da_proc(x, drive * 2, bias, 1.8, 1.4, 0.75, 0.95, 0.25, 0.18);
);


// ---- lms_sat_tape — tape saturation (symmetric, soft compression) ----

function lms_sat_tape_init() ( this.lms_sat_da_init(); );

function lms_sat_tape(x, drive, bias) (
  // Tape: symmetric soft compression, wide ceiling, gentle grid conduction
  // pos_hard=0.8, neg_hard=0.8, pos_ceil=0.95, neg_ceil=0.95, gc_thresh=0.35, gc_amount=0.12
  this.lms_sat_da_proc(x, drive * 1.5, bias, 0.8, 0.8, 0.95, 0.95, 0.35, 0.12);
);


// ---- lms_sat_rect — rectifier (hard positive, soft negative fold) ----

function lms_sat_rect_init() ( this.lms_sat_da_init(); );

function lms_sat_rect(x, drive, bias) (
  // Rectifier: very hard positive clip, soft negative (half-wave character)
  // pos_hard=2.0, neg_hard=0.5, pos_ceil=0.70, neg_ceil=0.40, gc_thresh=0.20, gc_amount=0.20
  this.lms_sat_da_proc(x, drive * 3, bias, 2.0, 0.5, 0.70, 0.40, 0.20, 0.20);
);


// ---- lms_sat_fuzz — fuzz (aggressive both sides, low ceiling, gated) ----

function lms_sat_fuzz_init() ( this.lms_sat_da_init(); );

function lms_sat_fuzz(x, drive, bias) (
  // Fuzz: very hard both sides, low ceiling, aggressive grid conduction
  // pos_hard=2.5, neg_hard=2.0, pos_ceil=0.60, neg_ceil=0.55, gc_thresh=0.15, gc_amount=0.25
  this.lms_sat_da_proc(x, drive * 4, bias, 2.5, 2.0, 0.60, 0.55, 0.15, 0.25);
);


// ---- lms_sat_harmonics — polynomial harmonic blend (no hard clip, minimal aliasing) ----
// Polynomial distortion aliases less severely than hard clippers, but x³ still aliases.
// We use ADAA on the x³ term (F(x³) = x⁴/4) and exact for x|x| (F = x²|x|/3).
// This is kept stateless-style since it's additive blend, not a full clipper.

function lms_sat_harmonics_init()
(
  this.xp = 0;
  this.F2p = 0;
  this.F3p = 0;
);

function lms_sat_harmonics(x, even_mix, odd_mix)
  local(x2_now, x3_now, F2_now, F3_now, x2_aa, x3_aa, result, mid)
(
  mid = (x + this.xp) * 0.5;

  // Even: f(x) = x*|x|  (2nd harmonic, signed square)  F(x) = x²|x|/3
  F2_now = x * x * abs(x) / 3;
  x2_aa  = lms_adaa_eval(x, this.xp, F2_now, this.F2p, mid * abs(mid));

  // Odd: f(x) = x³   F(x) = x⁴/4
  F3_now = x * x * x * x / 4;
  x3_aa  = lms_adaa_eval(x, this.xp, F3_now, this.F3p, mid * mid * mid);

  result = x + even_mix * x2_aa * 0.3 + odd_mix * x3_aa * 0.2;

  this.xp   = x;
  this.F2p  = F2_now;
  this.F3p  = F3_now;
  result;
);


// ============================================================================
//  SECTION 4: Compressor — FET-style (stereo, this.* state)
//
//  Stereo-linked peak detection with envelope follower.
//
//  Usage:
//    @init:   comp.lms_comp_init();
//    @slider: comp.lms_comp_set(thresh_db, ratio, att_ms, rel_ms);
//    @block:  comp.lms_comp_set(thresh_db, ratio, att_ms, rel_ms);
//    @sample: comp.lms_comp_proc(l, r);
//             l *= comp.gr;
//             r *= comp.gr;
//             // comp.gr_db has dB of gain reduction
// ============================================================================

// Initialize compressor state
function lms_comp_init()
(
  this.env = 0;
  this.gr = 1;
  this.gr_db = 0;
  this.thresh = 0;
  this.ratio = 4;
  this.att = 0;
  this.rel = 0;
);

// Set compressor parameters
function lms_comp_set(thresh_db, ratio, att_ms, rel_ms)
(
  this.thresh = thresh_db;
  this.ratio = ratio;
  this.att = exp(-1 / (att_ms * 0.001 * srate));
  this.rel = exp(-1 / (rel_ms * 0.001 * srate));
);

// Process stereo pair — updates this.gr (linear) and this.gr_db
function lms_comp_proc(l, r)
  local(det, det_db, over, target_gr)
(
  det = max(abs(l), abs(r));
  det_db = det > 0.0000001 ? 20 * log10(det) : -140;
  over = det_db - this.thresh;
  over > 0 ? (
    target_gr = over - over / this.ratio;
  ) : (
    target_gr = 0;
  );
  target_gr > this.env ? (
    this.env = this.att * this.env + (1 - this.att) * target_gr;
  ) : (
    this.env = this.rel * this.env + (1 - this.rel) * target_gr;
  );
  this.gr = 10 ^ (-this.env / 20);
  this.gr_db = this.env;
);


// ============================================================================
//  SECTION 5: DC Blocker (stereo, this.* state)
//
//  1-pole highpass to remove DC offset from asymmetric clipping.
//
//  Usage:
//    @init:   dc.lms_dc_init();          // 20 Hz default
//             dc.lms_dc_init_freq(220);  // or custom cutoff
//    @sample: l = dc.lms_dc_proc_l(l);
//             r = dc.lms_dc_proc_r(r);
// ============================================================================

// Initialize DC blocker with default 20 Hz cutoff
function lms_dc_init()
(
  this.xl = 0; this.xr = 0;
  this.yl = 0; this.yr = 0;
  this.r = 1 - (20 / srate);
);

// Initialize DC blocker with custom cutoff frequency
function lms_dc_init_freq(freq)
(
  this.xl = 0; this.xr = 0;
  this.yl = 0; this.yr = 0;
  this.r = 1 - (freq / srate);
);

// Process left channel
function lms_dc_proc_l(x)
(
  this.yl = x - this.xl + this.r * this.yl;
  this.xl = x;
  this.yl;
);

// Process right channel
function lms_dc_proc_r(x)
(
  this.yr = x - this.xr + this.r * this.yr;
  this.xr = x;
  this.yr;
);


// ============================================================================
//  SECTION 6: Tone Filter — 1-pole Lowpass (stereo, this.* state)
//
//  Simple 1-pole lowpass for tone control.
//
//  Usage:
//    @init:   tone.lms_tone_init();
//    @slider: tone.lms_tone_set(freq);
//    @block:  tone.lms_tone_set(freq);
//    @sample: l = tone.lms_tone_proc_l(l);
//             r = tone.lms_tone_proc_r(r);
// ============================================================================

// Initialize tone filter state
function lms_tone_init()
(
  this.yl = 0;
  this.yr = 0;
  this.coeff = 0;
  this.freq = 20000;
);

// Set tone filter cutoff frequency
function lms_tone_set(freq)
(
  this.freq = freq;
  this.coeff = exp(-2 * $pi * freq / srate);
);

// Process left channel (bypasses if freq >= 19999)
function lms_tone_proc_l(x)
(
  this.freq < 19999 ? (
    this.yl = this.yl * this.coeff + x * (1 - this.coeff);
    this.yl;
  ) : (
    x;
  );
);

// Process right channel (bypasses if freq >= 19999)
function lms_tone_proc_r(x)
(
  this.freq < 19999 ? (
    this.yr = this.yr * this.coeff + x * (1 - this.coeff);
    this.yr;
  ) : (
    x;
  );
);


// ============================================================================
//  SECTION 7: Cubic Interpolation (stateless)
//
//  Hermite cubic interpolation for reading from circular delay buffers.
//
//  Usage:
//    out = lms_interp_cubic(buf, pos, bmax);
// ============================================================================

function lms_interp_cubic(buf, pos, bmax)
  local(p0, p1, p2, p3, x0, x1, x2, x3, a, b, c, d, frac, idx)
(
  idx = floor(pos);
  frac = pos - idx;

  p0 = idx - 1; p0 < 0 ? p0 += bmax;
  p1 = idx;     p1 >= bmax ? p1 -= bmax;
  p2 = idx + 1; p2 >= bmax ? p2 -= bmax;
  p3 = idx + 2; p3 >= bmax ? p3 -= bmax;

  x0 = buf[p0]; x1 = buf[p1]; x2 = buf[p2]; x3 = buf[p3];

  // Cubic Hermite interpolation
  a = -0.5*x0 + 1.5*x1 - 1.5*x2 + 0.5*x3;
  b = x0 - 2.5*x1 + 2*x2 - 0.5*x3;
  c = -0.5*x0 + 0.5*x2;
  d = x1;

  ((a * frac + b) * frac + c) * frac + d;
);


// ============================================================================
//  SECTION 8: Spring Reverb Allpass (stateless, buffer-based)
//
//  Single allpass unit for spring reverb / diffusion networks.
//  Caller manages buffer position advancement.
//
//  Usage:
//    out = lms_spring_ap(buf, pos, len, input, coeff);
//    pos += 1; pos >= len ? pos = 0;
// ============================================================================

function lms_spring_ap(buf, pos, len, input, coeff)
  local(delayed, output)
(
  delayed = buf[pos];
  output = -input * coeff + delayed;
  buf[pos] = input + delayed * coeff;
  output;
);


// ============================================================================
//  SECTION 9: GUI Helpers (called from @gfx in importing plugins)
//
//  All drawing functions use global scale variable S and font variables
//  F_TITLE, F_LABEL, F_SMALL, F_TINY. Call lms_gfx_setup(nominal_w) at
//  the top of your @gfx section to initialize scaling.
//
//  These functions are defined in @init so they're available everywhere.
//  They call gfx_* functions which only do anything when called from @gfx.
//
//  Color constants are set by lms_gfx_setup() and shared across all helpers.
//
//  Usage:
//    @gfx 500 310
//    lms_gfx_setup(500);
//    lms_gfx_background();
//    lms_gfx_logo_title("MY PLUGIN", "subtitle");
//    // ... then use draw_bar, draw_panel, draw_toggle, draw_mode_sel
// ============================================================================

// ---- Global scale & font setup ----
function lms_gfx_setup(nominal_w) (
  gfx_ext_retina > 0 ? gfx_ext_retina = 1;
  S = gfx_w / nominal_w;
  S < 0.5 ? S = 0.5;

  // Scaled font sizes
  F_TITLE = max(10, floor(22 * S));
  F_LABEL = max(8, floor(12 * S));
  F_SMALL = max(7, floor(11 * S));
  F_TINY  = max(7, floor(10 * S));

  // Header height
  lms_hdr_h = floor(44 * S);

  // Color constants (set once, used by all helpers)
  COL_BG_R = 0.05; COL_BG_G = 0.05; COL_BG_B = 0.07;
  COL_PANEL_R = 0.08; COL_PANEL_G = 0.08; COL_PANEL_B = 0.11;
  COL_PANEL_HI_R = 0.12; COL_PANEL_HI_G = 0.12; COL_PANEL_HI_B = 0.16;
  COL_BORDER_R = 0.20; COL_BORDER_G = 0.20; COL_BORDER_B = 0.25;
  COL_TITLE_R = 0.95; COL_TITLE_G = 0.78; COL_TITLE_B = 0.35;
  COL_SEC_R = 0.55; COL_SEC_G = 0.50; COL_SEC_B = 0.40;
  COL_TEXT_R = 0.78; COL_TEXT_G = 0.78; COL_TEXT_B = 0.82;
  COL_DIM_R = 0.38; COL_DIM_G = 0.38; COL_DIM_B = 0.42;
  COL_ACCENT_R = 0.95; COL_ACCENT_G = 0.45; COL_ACCENT_B = 0.15;
  COL_GREEN_R = 0.25; COL_GREEN_G = 0.80; COL_GREEN_B = 0.50;
  COL_CYAN_R = 0.20; COL_CYAN_G = 0.60; COL_CYAN_B = 0.85;
  COL_BAR_BG_R = 0.12; COL_BAR_BG_G = 0.12; COL_BAR_BG_B = 0.16;
);

// ---- Background + header bar ----
function lms_gfx_background() (
  gfx_r = COL_BG_R; gfx_g = COL_BG_G; gfx_b = COL_BG_B;
  gfx_rect(0, 0, gfx_w, gfx_h);
  gfx_r = 0.03; gfx_g = 0.03; gfx_b = 0.05;
  gfx_rect(0, 0, gfx_w, lms_hdr_h);
  gfx_r = COL_TITLE_R * 0.6; gfx_g = COL_TITLE_G * 0.6; gfx_b = COL_TITLE_B * 0.6;
  gfx_rect(0, lms_hdr_h, gfx_w, max(1, floor(2 * S)));
);

// ---- Logo + title text ----
// logo_slot: image index (usually 0). title: main name. subtitle: optional (pass "" to skip)
function lms_gfx_logo_title(logo_slot, title, subtitle) (
  lms_logo_h = floor(32 * S);
  lms_logo_w = floor(32 * S * (1920 / 1080));
  lms_logo_x = floor(6 * S);
  lms_logo_y = floor((lms_hdr_h - lms_logo_h) / 2);
  gfx_blit(logo_slot, 1, 0, 0, 0, 1920, 1080, lms_logo_x, lms_logo_y, lms_logo_w, lms_logo_h);
  gfx_r = COL_TITLE_R; gfx_g = COL_TITLE_G; gfx_b = COL_TITLE_B;
  gfx_setfont(1, "Arial", F_TITLE);
  gfx_x = lms_logo_x + lms_logo_w + floor(8 * S);
  gfx_y = floor(10 * S);
  gfx_drawstr(title);
  strlen(subtitle) > 0 ? (
    gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
    gfx_setfont(1, "Arial", F_LABEL);
    gfx_x += floor(12 * S);
    gfx_y = floor(18 * S);
    gfx_drawstr(subtitle);
  );
);

// ---- draw_bar — slider bar with fill, label, optional value, click-drag ----
function lms_draw_bar(bx, by, bw, bh, val, vmin, vmax, label, show_val) (
  gfx_r = COL_BAR_BG_R; gfx_g = COL_BAR_BG_G; gfx_b = COL_BAR_BG_B;
  gfx_rect(bx, by, bw, bh);
  norm = (val - vmin) / (vmax - vmin);
  norm = max(0, min(1, norm));
  fill_w = norm * bw;
  fill_w > 0 ? (
    gfx_r = COL_CYAN_R * 0.6; gfx_g = COL_CYAN_G * 0.6; gfx_b = COL_CYAN_B * 0.6;
    gfx_rect(bx, by, fill_w, bh);
    gfx_r = COL_CYAN_R * 0.8; gfx_g = COL_CYAN_G * 0.8; gfx_b = COL_CYAN_B * 0.8;
    gfx_rect(bx, by, fill_w, floor(bh / 2));
    gfx_r = COL_CYAN_R; gfx_g = COL_CYAN_G; gfx_b = COL_CYAN_B;
    gfx_rect(bx, by, fill_w, 1);
  );
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_rect(bx, by, bw, 1); gfx_rect(bx, by + bh - 1, bw, 1);
  gfx_rect(bx, by, 1, bh); gfx_rect(bx + bw - 1, by, 1, bh);
  gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
  gfx_setfont(1, "Arial", F_LABEL);
  gfx_x = bx + floor(5 * S); gfx_y = by + floor((bh - F_LABEL) / 2);
  gfx_drawstr(label);
  show_val ? (
    gfx_setfont(1, "Arial", F_SMALL);
    gfx_x = bx + bw - floor(40 * S); gfx_y = by + floor((bh - F_SMALL) / 2);
    gfx_drawnumber(val, val == floor(val) ? 0 : 1);
  );
  mouse_cap & 1 ? (
    mouse_x >= bx && mouse_x <= bx + bw &&
    mouse_y >= by && mouse_y <= by + bh ? (
      new_norm = (mouse_x - bx) / bw;
      new_norm = max(0, min(1, new_norm));
      val = vmin + new_norm * (vmax - vmin);
    );
  );
  val;
);

// ---- draw_panel — bordered section with title bar ----
function lms_draw_panel(px, py, pw, ph, title) (
  gfx_r = COL_PANEL_R; gfx_g = COL_PANEL_G; gfx_b = COL_PANEL_B;
  gfx_rect(px, py, pw, ph);
  gfx_r = COL_PANEL_HI_R; gfx_g = COL_PANEL_HI_G; gfx_b = COL_PANEL_HI_B;
  gfx_rect(px, py, pw, floor(22 * S));
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_rect(px, py + floor(22 * S), pw, 1);
  gfx_r = COL_BORDER_R * 0.7; gfx_g = COL_BORDER_G * 0.7; gfx_b = COL_BORDER_B * 0.7;
  gfx_rect(px, py, pw, 1); gfx_rect(px, py, 1, ph);
  gfx_rect(px + pw - 1, py, 1, ph); gfx_rect(px, py + ph - 1, pw, 1);
  gfx_r = COL_SEC_R; gfx_g = COL_SEC_G; gfx_b = COL_SEC_B;
  gfx_setfont(1, "Arial", F_LABEL);
  gfx_x = px + floor(8 * S); gfx_y = py + floor(4 * S);
  gfx_drawstr(title);
);

// ---- draw_toggle — on/off circle + label ----
function lms_draw_toggle(tx, ty, is_on, label) (
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_circle(tx + floor(8 * S), ty + floor(8 * S), floor(7 * S), 0);
  is_on ? (
    gfx_r = COL_GREEN_R; gfx_g = COL_GREEN_G; gfx_b = COL_GREEN_B;
    gfx_circle(tx + floor(8 * S), ty + floor(8 * S), floor(5 * S), 1);
  ) : (
    gfx_r = 0.15; gfx_g = 0.15; gfx_b = 0.18;
    gfx_circle(tx + floor(8 * S), ty + floor(8 * S), floor(5 * S), 1);
  );
  gfx_r = is_on ? COL_TEXT_R : COL_DIM_R;
  gfx_g = is_on ? COL_TEXT_G : COL_DIM_G;
  gfx_b = is_on ? COL_TEXT_B : COL_DIM_B;
  gfx_setfont(1, "Arial", F_SMALL);
  gfx_x = tx + floor(20 * S); gfx_y = ty + floor(1 * S);
  gfx_drawstr(label);
  (mouse_cap & 1) && !(last_cap & 1) &&
    mouse_x >= tx && mouse_x <= tx + floor(80 * S) &&
    mouse_y >= ty && mouse_y <= ty + floor(16 * S) ? (
      is_on = 1 - is_on;
  );
  is_on;
);

// ---- draw_mode_sel — clickable mode selector (up to 4 options) ----
function lms_draw_mode_sel(mx, my, mw, mh, val, vmax, label, v0, v1, v2, v3) (
  gfx_r = COL_BAR_BG_R; gfx_g = COL_BAR_BG_G; gfx_b = COL_BAR_BG_B;
  gfx_rect(mx, my, mw, mh);
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_rect(mx, my, mw, 1); gfx_rect(mx, my + mh - 1, mw, 1);
  gfx_rect(mx, my, 1, mh); gfx_rect(mx + mw - 1, my, 1, mh);
  gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
  gfx_setfont(1, "Arial", F_LABEL);
  gfx_x = mx + floor(5 * S); gfx_y = my + floor((mh - F_LABEL) / 2);
  gfx_drawstr(label);
  gfx_r = COL_ACCENT_R; gfx_g = COL_ACCENT_G; gfx_b = COL_ACCENT_B;
  gfx_x = mx + mw - floor(72 * S); gfx_y = my + floor((mh - F_LABEL) / 2);
  val == 0 ? gfx_drawstr(v0);
  val == 1 ? gfx_drawstr(v1);
  val == 2 ? gfx_drawstr(v2);
  val == 3 ? gfx_drawstr(v3);
  (mouse_cap & 1) && !(last_cap & 1) &&
    mouse_x >= mx && mouse_x <= mx + mw &&
    mouse_y >= my && mouse_y <= my + mh ? (
      val = (val + 1) % (vmax + 1);
  );
  (mouse_cap & 2) && !(last_cap & 2) &&
    mouse_x >= mx && mouse_x <= mx + mw &&
    mouse_y >= my && mouse_y <= my + mh ? (
      val = val - 1; val < 0 ? val = vmax;
  );
  val;
);

// ---- NOTICE overlay ----
function lms_gfx_notice() (
  gfx_r = 0.05; gfx_g = 0.05; gfx_b = 0.05; gfx_a = 0.95;
  gfx_rect(0, 0, gfx_w, gfx_h);
  gfx_a = 1;
  gfx_setfont(1, "Arial", F_LABEL);
  gfx_r = 0.9; gfx_g = 0.8; gfx_b = 0.5;
  gfx_x = floor(15 * S); gfx_y = floor(10 * S);
  gfx_drawstr("NOTICE: THEY ARE TRYING TO STEAL YOUR COMPUTER");
  gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.7;
  gfx_x = floor(15 * S); gfx_y = floor(30 * S);
  gfx_drawstr("The algorithms in our favorite software are decades old.");
  gfx_x = floor(15 * S); gfx_y = floor(45 * S);
  gfx_drawstr("A mathematical model is a truth about the world,");
  gfx_x = floor(15 * S); gfx_y = floor(60 * S);
  gfx_drawstr("not a copyrightable product. You do not have to stay");
  gfx_x = floor(15 * S); gfx_y = floor(75 * S);
  gfx_drawstr("a slave to subscription software. Install Linux.");
  gfx_x = floor(15 * S); gfx_y = floor(90 * S);
  gfx_drawstr("Build your own tools. Believe in yourself.");
  gfx_r = 0.5; gfx_g = 0.7; gfx_b = 1.0;
  gfx_x = floor(15 * S); gfx_y = floor(115 * S);
  gfx_drawstr("github.com/LMSBAND  |  instagram.com/LMSSKABAND");
);

// ---- NOTICE button + overlay ----
// Call at the end of @gfx. Uses notice_show and notice_clicked globals.
// bc_panel_y should be set before calling (from instance panel or gfx_h).
function lms_gfx_notice_btn(bc_panel_y) (
  notice_btn_x = gfx_w - floor(60 * S);
  notice_btn_y = bc_panel_y - floor(18 * S);
  gfx_r = 0.6; gfx_g = 0.5; gfx_b = 0.3;
  gfx_rect(notice_btn_x, notice_btn_y, floor(55 * S), floor(15 * S));
  gfx_r = 0; gfx_g = 0; gfx_b = 0;
  gfx_setfont(1, "Arial", F_SMALL);
  gfx_x = notice_btn_x + floor(4 * S); gfx_y = notice_btn_y + floor(2 * S);
  gfx_drawstr("NOTICE");
  (mouse_cap & 1) && mouse_x >= notice_btn_x && mouse_x <= notice_btn_x + floor(55 * S)
    && mouse_y >= notice_btn_y && mouse_y <= notice_btn_y + floor(15 * S) && !notice_clicked ? (
    notice_show = !notice_show;
    notice_clicked = 1;
  );
  !(mouse_cap & 1) ? notice_clicked = 0;
  notice_show ? (
    lms_gfx_notice();
    // Redraw notice button on top of overlay
    gfx_r = 0.6; gfx_g = 0.5; gfx_b = 0.3;
    gfx_rect(notice_btn_x, notice_btn_y, floor(55 * S), floor(15 * S));
    gfx_r = 0; gfx_g = 0; gfx_b = 0;
    gfx_setfont(1, "Arial", F_SMALL);
    gfx_x = notice_btn_x + floor(4 * S); gfx_y = notice_btn_y + floor(2 * S);
    gfx_drawstr("NOTICE");
  );
);
