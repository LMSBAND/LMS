// ============================================================================
//  LMS Core DSP Library v1.0
//  Shared DSP building blocks for the LMS plugin suite
//
//  Usage: import lms_core.jsfx-inc
//
//  IMPORTANT: All functions must be inside @init so they are available
//  across all sections (@slider, @block, @sample, @gfx) in importing files.
//  JSFX rule: "functions defined in @init can be used from other sections,
//  whereas functions defined in other sections are local to those sections."
//
//  All functions use lms_ prefix. Stateful functions use this.* pattern —
//  call as instance.lms_xxx() to get independent state per instance.
//
//  Sections:
//    1. Math Utilities           (stateless)
//    2. Biquad Filter            (stereo, this.* state)
//    3. Saturation Suite         (stateless)
//    4. Compressor               (stereo, this.* state)
//    5. DC Blocker               (stereo, this.* state)
//    6. Tone Filter              (stereo, this.* state)
//    7. Cubic Interpolation      (stateless)
//    8. Spring Reverb Allpass    (stateless, buffer-based)
//    9. Sag Simulator            (this.* state) — tube rectifier droop
//   10. Cascaded Saturation      (stateless) — Marshall cold-clipper model
//   11. Opto Compressor          (this.* state) — LA-2A T4B photocell model
// ============================================================================

@init

// ============================================================================
//  SECTION 1: Math Utilities (stateless)
// ============================================================================

// Bounded exp-based tanh approximation (JSFX has no built-in tanh)
function lms_tanh(x)
  local(e2x)
(
  x > 10 ? 1 : x < -10 ? -1 : (
    e2x = exp(2 * x);
    (e2x - 1) / (e2x + 1);
  );
);

// dB to linear gain
function lms_db2lin(db)
(
  10 ^ (db / 20);
);

// Linear gain to dB (safe — returns -140 for silence)
function lms_lin2db(lin)
(
  lin > 0.0000001 ? 20 * log10(lin) : -140;
);


// ============================================================================
//  SECTION 2: Biquad Filter (stereo, this.* state)
//
//  One instance = one stereo band.
//  Coefficients shared, L/R state separate.
//
//  Usage:
//    @init:   hp.lms_bq_init();
//    @slider: hp.lms_bq_set_hp(freq, 0.707);
//    @block:  hp.lms_bq_set_hp(freq, 0.707);
//    @sample: l = hp.lms_bq_proc_l(l);
//             r = hp.lms_bq_proc_r(r);
// ============================================================================

// Initialize biquad — zero state and set to passthrough
function lms_bq_init()
(
  // Coefficients (passthrough)
  this.b0 = 1; this.b1 = 0; this.b2 = 0;
  this.a1 = 0; this.a2 = 0;
  // Left channel state
  this.lx1 = 0; this.lx2 = 0;
  this.ly1 = 0; this.ly2 = 0;
  // Right channel state
  this.rx1 = 0; this.rx2 = 0;
  this.ry1 = 0; this.ry2 = 0;
);

// Highpass (2nd order Butterworth when q = 0.707)
function lms_bq_set_hp(freq, q)
  local(w0, cs, sn, alpha, a0_inv)
(
  w0 = 2 * $pi * freq / srate;
  cs = cos(w0); sn = sin(w0);
  alpha = sn / (2 * q);
  a0_inv = 1 / (1 + alpha);
  this.b0 = (1 + cs) / 2 * a0_inv;
  this.b1 = -(1 + cs) * a0_inv;
  this.b2 = (1 + cs) / 2 * a0_inv;
  this.a1 = -2 * cs * a0_inv;
  this.a2 = (1 - alpha) * a0_inv;
);

// Lowpass
function lms_bq_set_lp(freq, q)
  local(w0, cs, sn, alpha, a0_inv)
(
  w0 = 2 * $pi * freq / srate;
  cs = cos(w0); sn = sin(w0);
  alpha = sn / (2 * q);
  a0_inv = 1 / (1 + alpha);
  this.b0 = (1 - cs) / 2 * a0_inv;
  this.b1 = (1 - cs) * a0_inv;
  this.b2 = (1 - cs) / 2 * a0_inv;
  this.a1 = -2 * cs * a0_inv;
  this.a2 = (1 - alpha) * a0_inv;
);

// Bandpass (constant skirt gain)
function lms_bq_set_bp(freq, q)
  local(w0, cs, sn, alpha, a0_inv)
(
  w0 = 2 * $pi * freq / srate;
  cs = cos(w0); sn = sin(w0);
  alpha = sn / (2 * q);
  a0_inv = 1 / (1 + alpha);
  this.b0 = (sn / 2) * a0_inv;
  this.b1 = 0;
  this.b2 = -(sn / 2) * a0_inv;
  this.a1 = -2 * cs * a0_inv;
  this.a2 = (1 - alpha) * a0_inv;
);

// Parametric peaking EQ
function lms_bq_set_peak(freq, gain_db, q)
  local(a, w0, alpha, a0_inv)
(
  a = 10 ^ (gain_db / 20);
  w0 = 2 * $pi * freq / srate;
  alpha = sin(w0) / (2 * q);
  a0_inv = 1 / (1 + alpha / a);
  this.b0 = (1 + alpha * a) * a0_inv;
  this.b1 = (-2 * cos(w0)) * a0_inv;
  this.b2 = (1 - alpha * a) * a0_inv;
  this.a1 = this.b1;
  this.a2 = (1 - alpha / a) * a0_inv;
);

// Low shelf
function lms_bq_set_loshelf(freq, gain_db, q)
  local(a, w0, cs, sn, alpha, ap1, am1, beta, a0_inv)
(
  a = 10 ^ (gain_db / 40);
  w0 = 2 * $pi * freq / srate;
  cs = cos(w0); sn = sin(w0);
  alpha = sn / (2 * q);
  ap1 = a + 1; am1 = a - 1;
  beta = 2 * sqrt(a) * alpha;
  a0_inv = 1 / (ap1 + am1 * cs + beta);
  this.b0 = a * (ap1 - am1 * cs + beta) * a0_inv;
  this.b1 = 2 * a * (am1 - ap1 * cs) * a0_inv;
  this.b2 = a * (ap1 - am1 * cs - beta) * a0_inv;
  this.a1 = -2 * (am1 + ap1 * cs) * a0_inv;
  this.a2 = (ap1 + am1 * cs - beta) * a0_inv;
);

// High shelf
function lms_bq_set_hishelf(freq, gain_db, q)
  local(a, w0, cs, sn, alpha, ap1, am1, beta, a0_inv)
(
  a = 10 ^ (gain_db / 40);
  w0 = 2 * $pi * freq / srate;
  cs = cos(w0); sn = sin(w0);
  alpha = sn / (2 * q);
  ap1 = a + 1; am1 = a - 1;
  beta = 2 * sqrt(a) * alpha;
  a0_inv = 1 / (ap1 - am1 * cs + beta);
  this.b0 = a * (ap1 + am1 * cs + beta) * a0_inv;
  this.b1 = -2 * a * (am1 + ap1 * cs) * a0_inv;
  this.b2 = a * (ap1 + am1 * cs - beta) * a0_inv;
  this.a1 = 2 * (am1 - ap1 * cs) * a0_inv;
  this.a2 = (ap1 - am1 * cs - beta) * a0_inv;
);

// Process left channel sample through biquad
function lms_bq_proc_l(x)
  local(o)
(
  o = this.b0 * x + this.b1 * this.lx1 + this.b2 * this.lx2
                   - this.a1 * this.ly1 - this.a2 * this.ly2;
  this.lx2 = this.lx1; this.lx1 = x;
  this.ly2 = this.ly1; this.ly1 = o;
  o;
);

// Process right channel sample through biquad
function lms_bq_proc_r(x)
  local(o)
(
  o = this.b0 * x + this.b1 * this.rx1 + this.b2 * this.rx2
                   - this.a1 * this.ry1 - this.a2 * this.ry2;
  this.rx2 = this.rx1; this.rx1 = x;
  this.ry2 = this.ry1; this.ry1 = o;
  o;
);


// ============================================================================
//  SECTION 3: Saturation Suite (stateless)
//
//  All functions take (x, drive, bias) where drive and bias are 0..1 range.
//  Uses lms_tanh() internally.
//
//  Usage:
//    l = lms_sat_warm(l, drive, bias);
// ============================================================================

// Asymmetric tube — even harmonics, warm character
function lms_sat_warm(x, drive, bias)
  local(b)
(
  b = x + bias * 0.1;
  b = b * (1 + drive);
  // Asymmetric soft clipping - tubes clip differently on positive vs negative
  b > 0 ? (
    b = lms_tanh(b);
  ) : (
    b = lms_tanh(b * 0.8) * 1.25;
  );
  b;
);

// Aggressive tube — harder clipping with more asymmetry
function lms_sat_hot(x, drive, bias)
  local(b)
(
  b = x + bias * 0.15;
  b = b * (1 + drive * 2);
  b > 0 ? (
    b = 1 - exp(-abs(b));
  ) : (
    b = -(1 - exp(-abs(b * 0.7))) * 1.1;
  );
  b;
);

// Tape saturation — symmetric arctan
function lms_sat_tape(x, drive, bias)
  local(b)
(
  b = x + bias * 0.05;
  b = b * (1 + drive * 1.5);
  b = (2 / $pi) * atan(b * $pi * 0.5);
  b;
);

// Half-wave rectifier distortion
function lms_sat_rect(x, drive, bias)
  local(b)
(
  b = x + bias * 0.2;
  b = b * (1 + drive * 3);
  // Folds negative into positive partially
  b < 0 ? b = b * (0.2 + drive * 0.1);
  b = lms_tanh(b);
  b;
);

// Gated fuzz — hard clipping with crossover distortion
function lms_sat_fuzz(x, drive, bias)
  local(b)
(
  b = x + bias * 0.1;
  b = b * (1 + drive * 4);
  abs(b) < 0.1 * (1 - drive * 0.5) ? (
    b = b * (0.3 + drive * 0.7);
  ) : (
    b = sign(b) * (1 - exp(-abs(b)));
  );
  b;
);

// Harmonic blend — even (2nd/4th) + odd (3rd/5th)
function lms_sat_harmonics(x, even_mix, odd_mix)
  local(x2, x3, result)
(
  // Even harmonics (2nd, 4th) - warm, musical
  x2 = x * x * sign(x);
  // Odd harmonics (3rd, 5th) - gritty, aggressive
  x3 = x * x * x;

  result = x + even_mix * x2 * 0.3 + odd_mix * x3 * 0.2;
  result;
);


// ============================================================================
//  SECTION 4: Compressor — FET-style (stereo, this.* state)
//
//  Stereo-linked peak detection with envelope follower.
//
//  Usage:
//    @init:   comp.lms_comp_init();
//    @slider: comp.lms_comp_set(thresh_db, ratio, att_ms, rel_ms);
//    @block:  comp.lms_comp_set(thresh_db, ratio, att_ms, rel_ms);
//    @sample: comp.lms_comp_proc(l, r);
//             l *= comp.gr;
//             r *= comp.gr;
//             // comp.gr_db has dB of gain reduction
// ============================================================================

// Initialize compressor state
function lms_comp_init()
(
  this.env = 0;
  this.gr = 1;
  this.gr_db = 0;
  this.thresh = 0;
  this.ratio = 4;
  this.att = 0;
  this.rel = 0;
);

// Set compressor parameters
function lms_comp_set(thresh_db, ratio, att_ms, rel_ms)
(
  this.thresh = thresh_db;
  this.ratio = ratio;
  this.att = exp(-1 / (att_ms * 0.001 * srate));
  this.rel = exp(-1 / (rel_ms * 0.001 * srate));
);

// Process stereo pair — updates this.gr (linear) and this.gr_db
function lms_comp_proc(l, r)
  local(det, det_db, over, target_gr)
(
  det = max(abs(l), abs(r));
  det_db = det > 0.0000001 ? 20 * log10(det) : -140;
  over = det_db - this.thresh;
  over > 0 ? (
    target_gr = over - over / this.ratio;
  ) : (
    target_gr = 0;
  );
  target_gr > this.env ? (
    this.env = this.att * this.env + (1 - this.att) * target_gr;
  ) : (
    this.env = this.rel * this.env + (1 - this.rel) * target_gr;
  );
  this.gr = 10 ^ (-this.env / 20);
  this.gr_db = this.env;
);


// ============================================================================
//  SECTION 5: DC Blocker (stereo, this.* state)
//
//  1-pole highpass to remove DC offset from asymmetric clipping.
//
//  Usage:
//    @init:   dc.lms_dc_init();          // 20 Hz default
//             dc.lms_dc_init_freq(220);  // or custom cutoff
//    @sample: l = dc.lms_dc_proc_l(l);
//             r = dc.lms_dc_proc_r(r);
// ============================================================================

// Initialize DC blocker with default 20 Hz cutoff
function lms_dc_init()
(
  this.xl = 0; this.xr = 0;
  this.yl = 0; this.yr = 0;
  this.r = 1 - (20 / srate);
);

// Initialize DC blocker with custom cutoff frequency
function lms_dc_init_freq(freq)
(
  this.xl = 0; this.xr = 0;
  this.yl = 0; this.yr = 0;
  this.r = 1 - (freq / srate);
);

// Process left channel
function lms_dc_proc_l(x)
(
  this.yl = x - this.xl + this.r * this.yl;
  this.xl = x;
  this.yl;
);

// Process right channel
function lms_dc_proc_r(x)
(
  this.yr = x - this.xr + this.r * this.yr;
  this.xr = x;
  this.yr;
);


// ============================================================================
//  SECTION 6: Tone Filter — 1-pole Lowpass (stereo, this.* state)
//
//  Simple 1-pole lowpass for tone control.
//
//  Usage:
//    @init:   tone.lms_tone_init();
//    @slider: tone.lms_tone_set(freq);
//    @block:  tone.lms_tone_set(freq);
//    @sample: l = tone.lms_tone_proc_l(l);
//             r = tone.lms_tone_proc_r(r);
// ============================================================================

// Initialize tone filter state
function lms_tone_init()
(
  this.yl = 0;
  this.yr = 0;
  this.coeff = 0;
  this.freq = 20000;
);

// Set tone filter cutoff frequency
function lms_tone_set(freq)
(
  this.freq = freq;
  this.coeff = exp(-2 * $pi * freq / srate);
);

// Process left channel (bypasses if freq >= 19999)
function lms_tone_proc_l(x)
(
  this.freq < 19999 ? (
    this.yl = this.yl * this.coeff + x * (1 - this.coeff);
    this.yl;
  ) : (
    x;
  );
);

// Process right channel (bypasses if freq >= 19999)
function lms_tone_proc_r(x)
(
  this.freq < 19999 ? (
    this.yr = this.yr * this.coeff + x * (1 - this.coeff);
    this.yr;
  ) : (
    x;
  );
);


// ============================================================================
//  SECTION 7: Cubic Interpolation (stateless)
//
//  Hermite cubic interpolation for reading from circular delay buffers.
//
//  Usage:
//    out = lms_interp_cubic(buf, pos, bmax);
// ============================================================================

function lms_interp_cubic(buf, pos, bmax)
  local(p0, p1, p2, p3, x0, x1, x2, x3, a, b, c, d, frac, idx)
(
  idx = floor(pos);
  frac = pos - idx;

  p0 = idx - 1; p0 < 0 ? p0 += bmax;
  p1 = idx;     p1 >= bmax ? p1 -= bmax;
  p2 = idx + 1; p2 >= bmax ? p2 -= bmax;
  p3 = idx + 2; p3 >= bmax ? p3 -= bmax;

  x0 = buf[p0]; x1 = buf[p1]; x2 = buf[p2]; x3 = buf[p3];

  // Cubic Hermite interpolation
  a = -0.5*x0 + 1.5*x1 - 1.5*x2 + 0.5*x3;
  b = x0 - 2.5*x1 + 2*x2 - 0.5*x3;
  c = -0.5*x0 + 0.5*x2;
  d = x1;

  ((a * frac + b) * frac + c) * frac + d;
);


// ============================================================================
//  SECTION 8: Spring Reverb Allpass (stateless, buffer-based)
//
//  Single allpass unit for spring reverb / diffusion networks.
//  Caller manages buffer position advancement.
//
//  Usage:
//    out = lms_spring_ap(buf, pos, len, input, coeff);
//    pos += 1; pos >= len ? pos = 0;
// ============================================================================

function lms_spring_ap(buf, pos, len, input, coeff)
  local(delayed, output)
(
  delayed = buf[pos];
  output = -input * coeff + delayed;
  buf[pos] = input + delayed * coeff;
  output;
);


// ============================================================================
//  SECTION 9: Sag Simulator (tube rectifier voltage droop)
//
//  Models the voltage sag of a tube rectifier under heavy load.
//  On loud transients the rectifier can't supply full voltage → the signal
//  "blooms" in: slow attack, slower release. Creates the elastic, organic
//  feel of vintage amps vs. silicon diode tightness.
//
//  Usage:
//    sag.lms_sag_init();
//    sag.lms_sag_set(20);          // attack in ms (15-30ms typical)
//    // in @sample:
//    gain = sag.lms_sag_proc(input_sample);
//    output = input * gain;
//
//  After proc: this.gr is the linear gain reduction (0.7 to 1.0)
// ============================================================================

function lms_sag_init()
(
  this.env = 0;
  this.att = 0;
  this.rel = 0;
  this.gr = 1;
  this.depth = 0.3;   // max sag depth (0 = none, 1 = 100% reduction)
);

function lms_sag_set(att_ms)
(
  // Attack: how fast the sag builds (slow = more bloom)
  this.att = exp(-1 / (srate * att_ms * 0.001));
  // Release: sag recovers much slower than it builds (3x attack time)
  this.rel = exp(-1 / (srate * att_ms * 0.003));
);

function lms_sag_proc(x)
  local(level)
(
  level = abs(x);
  level > this.env ? (
    this.env = this.att * this.env + (1 - this.att) * level;
  ) : (
    this.env = this.rel * this.env + (1 - this.rel) * level;
  );
  // Sag: high signal level → lower gain (simulates voltage droop)
  // env near 0 → gr near 1.0 (no sag), env near 1 → gr near (1 - depth)
  this.gr = 1 - this.depth * min(1, this.env);
  this.gr;
);


// ============================================================================
//  SECTION 10: Two-Stage Cascaded Saturation (Marshall cold-clipper model)
//
//  Models the V1B → V1A dual-triode chain in the JCM800 preamp.
//  V1A runs cold-biased (high bias resistor), generating asymmetric
//  2nd harmonic clipping early in the signal path — the source of the
//  JCM800's characteristic "crunch" even at moderate gain settings.
//
//  Usage:
//    out = lms_sat_cascade(x, drive1, bias1, drive2, bias2);
//    // drive/bias same ranges as lms_sat_warm
// ============================================================================

function lms_sat_cascade(x, drive1, bias1, drive2, bias2)
  local(stage1)
(
  stage1 = lms_sat_warm(x, drive1, bias1);
  lms_sat_warm(stage1, drive2, bias2);
);


// ============================================================================
//  SECTION 11: Opto Compressor (LA-2A T4B photocell model)
//
//  Program-dependent release: fast initial release from the photocell
//  discharging quickly, then slow final release as the electroluminescent
//  panel dims. Creates the "breathing" characteristic of optical compressors
//  — musical and forgiving, unlike FET or VCA compressors.
//
//  Attack is inherently fast (optical cell responds quickly to light).
//  Release is dual-stage: fast release (~50ms) then slow tail (~500ms).
//
//  Usage:
//    opto.lms_opto_init();
//    opto.lms_opto_set(-18, 4, 10);   // thresh_db, ratio, att_ms
//    // in @sample:
//    opto.lms_opto_proc(spl0, spl1);
//    spl0 *= opto.gr;
//    spl1 *= opto.gr;
//
//  After proc: this.gr (linear gain), this.gr_db (gain reduction in dB)
// ============================================================================

function lms_opto_init()
(
  this.env_fast = 0;
  this.env_slow = 0;
  this.gr = 1;
  this.gr_db = 0;
  this.thresh = lms_db2lin(-18);
  this.ratio = 4;
  this.att = 0;
  this.rel_fast = 0;
  this.rel_slow = 0;
);

function lms_opto_set(thresh_db, ratio, att_ms)
(
  this.thresh = lms_db2lin(thresh_db);
  this.ratio = ratio;
  // Attack: fast optical response (~10ms default)
  this.att = exp(-1 / (srate * att_ms * 0.001));
  // Release: T4B dual-stage — fast cell discharge then slow panel dim
  this.rel_fast = exp(-1 / (srate * 0.060));  // 60ms fast release
  this.rel_slow = exp(-1 / (srate * 0.500));  // 500ms slow tail
);

function lms_opto_proc(l, r)
  local(peak, over, target_gr, env)
(
  // Stereo peak detection
  peak = max(abs(l), abs(r));

  // Fast attack envelope
  peak > this.env_fast ? (
    this.env_fast = this.att * this.env_fast + (1 - this.att) * peak;
  ) : (
    // Dual-stage release: blend fast+slow envelopes (T4B photocell model)
    this.env_fast = this.rel_fast * this.env_fast;
    this.env_slow = this.rel_slow * this.env_slow + (1 - this.rel_slow) * this.env_fast;
    this.env_fast = max(this.env_fast, this.env_slow * 0.5);
  );

  env = this.env_fast;

  // Gain computation: soft knee around threshold
  env > this.thresh ? (
    over = env / this.thresh;
    // Soft-knee reduction: gentle slope, not brickwall
    target_gr = pow(over, -(1 - 1/this.ratio));
    this.gr = target_gr;
  ) : (
    this.gr = 1;
  );

  this.gr_db = lms_lin2db(this.gr);
  this.gr;
);


// ============================================================================
//  SECTION 12: 12AX7 Triode Models (stateful — one instance per tube stage)
//
//  Two variants matching the JCM800 2203 preamp topology:
//
//  V1B — first triode, UNBYPASSED cathode resistor (820Ω, no cap).
//        The unbypassed cathode provides local negative feedback, which:
//          - Reduces effective gain (~35 vs ~100 for bypassed)
//          - Softens clipping (feedback linearizes the transfer curve)
//          - Adds even harmonics (2nd dominant) due to class-A asymmetry
//        Transfer curve: arctan-based with asymmetric softclip
//        Models: Rk=820Ω, Ra=100kΩ, B+=300V operating point
//
//  V1A — second triode, BYPASSED cathode (10µF cap across 820Ω cathode).
//        Bypass cap shorts the cathode resistor at audio frequencies:
//          - Full gain restored (~60 effective, loaded by next stage)
//          - Harder clipping (no linearizing feedback)
//          - More 3rd harmonic content (symmetric grid limiting)
//          - Slight asymmetry from DC operating point offset
//        This stage is what makes the JCM800 Hi input aggressive.
//
//  Both stages include:
//    - Input coupling cap (35Hz HPF) — removes inter-stage DC
//    - Grid-to-cathode soft limiting (grid current above ~0.6V)
//    - Output normalised to unity at nominal plate swing
//
//  Usage:
//    @init:   v1b.lms_triode_v1b_init();
//             v1a.lms_triode_v1a_init();
//    @sample: out = v1b.lms_triode_v1b_proc(in, drive);
//             out = v1a.lms_triode_v1a_proc(in, drive);
//    drive: 0..1 — maps to input level into the stage (0=clean, 1=full grid swing)
// ============================================================================

function lms_triode_v1b_init()
(
  // Coupling cap HPF state (35Hz, removes inter-stage DC)
  this.hpx = 0; this.hpy = 0;
  this.hp_r = 1 - (2 * $pi * 35 / srate);
  // Cathode bypass state (none — cathode is unbypassed, static DC point)
  this.env = 0;  // envelope for soft sag on heavy transients
  this.env_att = exp(-1 / (srate * 0.003));   // 3ms attack
  this.env_rel = exp(-1 / (srate * 0.080));   // 80ms release
);

function lms_triode_v1b_proc(x, drive)
  local(gain, b, grid_in, pos_clip, neg_clip, env_target)
(
  // Coupling cap (inter-stage HP, removes DC)
  this.hpy = x - this.hpx + this.hp_r * this.hpy;
  this.hpx = x;
  b = this.hpy;

  // Input gain — drive scales the grid swing
  // Nominal full swing into a 12AX7 grid is about 1.5Vpp from previous stage
  // We represent this as drive * 4.0 headroom factor
  gain = 1.0 + drive * 3.0;
  b = b * gain;

  // Unbypassed cathode NFB — reduces gain and linearizes
  // Effective gain with 820Ω unbypassed cathode ≈ gm*Ra/(1 + gm*Rk) ≈ 35
  // We model this as gain softening: the more the signal swings, the more
  // the cathode voltage rises and opposes the grid, compressing the output.
  // Implemented as an asymmetric arctan with gentle positive-side rolloff.
  b > 0 ? (
    // Positive half: softer (cathode follower action pulls back)
    b = (2 / $pi) * atan(b * 1.2) * 0.85;
  ) : (
    // Negative half: slightly harder (cathode can't follow as fast going negative)
    b = (2 / $pi) * atan(b * 1.5) * 1.0;
  );

  // Grid current onset above ~0.6V equivalent — soft limiting on positive peaks
  // (grid draws current when it goes positive relative to cathode)
  b > 0.55 ? b = 0.55 + (b - 0.55) * 0.15;

  // Output level — nominal plate swing normalised to ~0.8 peak
  b * 0.8;
);


function lms_triode_v1a_init()
(
  // Coupling cap HPF (35Hz) — same as V1B
  this.hpx = 0; this.hpy = 0;
  this.hp_r = 1 - (2 * $pi * 35 / srate);
);

function lms_triode_v1a_proc(x, drive)
  local(gain, b)
(
  // Coupling cap
  this.hpy = x - this.hpx + this.hp_r * this.hpy;
  this.hpx = x;
  b = this.hpy;

  // Full gain — cathode bypassed, no NFB at audio frequencies
  // Effective gain ≈ 60 (loaded by tone stack ~50kΩ input impedance)
  gain = 1.0 + drive * 5.5;
  b = b * gain;

  // Harder clipping — 1-exp curve (exponential saturation, no feedback softening)
  // Asymmetric: positive clips harder (plate current limiting)
  //             negative clips a touch softer (grid current cutoff)
  b > 0 ? (
    b = 1.0 - exp(-abs(b) * 1.1);
  ) : (
    b = -(1.0 - exp(-abs(b) * 0.85)) * 1.05;
  );

  // Grid current on positive peaks (harder onset than V1B — already high gain stage)
  b > 0.60 ? b = 0.60 + (b - 0.60) * 0.08;

  b * 0.85;
);


// ============================================================================
//  SECTION 13: Marshall JCM800 Passive Tone Stack (stateful)
//
//  The JCM800 2203/2204 uses a passive Baxandall-derived tone stack between
//  the preamp and the recovery gain stage. Component values from the verified
//  JCM800 schematic (Trainwreck/Ceriatone cross-referenced):
//
//    Bass pot:   250kΩ (R6)
//    Mid pot:    25kΩ (R7)   ← note: much smaller than bass/treble
//    Treble pot: 1MΩ  (R8)
//    C1: 0.47µF  (bass cap)
//    C2: 22nF    (mid cap)
//    C3: 470pF   (treble cap)
//
//  Key behaviour:
//    - All controls are interactive (passive network — not independent)
//    - At "noon" (all 50%) there is ~18dB insertion loss (recovery gain compensates)
//    - Mid control is a CUT at 370Hz, not a boost — the "honk" comes from
//      turning mid DOWN (cuts the scoop) or from the treble/bass interaction
//    - Treble at full adds a shelf above ~1kHz AND rolls off some mid
//    - Bass at full boosts below ~200Hz AND slightly cuts mid
//
//  Implementation: analytical approximation using 3 interactive biquads.
//  True passive network would require a full 6th-order transfer function;
//  this model captures the interaction via cross-coupled gain coefficients.
//
//  Usage:
//    @init:   ts.lms_tonestack_jcm_init();
//    @slider/@block: ts.lms_tonestack_jcm_set(bass, mid, treble);
//                    // bass/mid/treble: 0..1 (pot position)
//    @sample: out = ts.lms_tonestack_jcm_proc(in);
// ============================================================================

function lms_tonestack_jcm_init()
(
  this.f_bass.lms_bq_init();
  this.f_mid.lms_bq_init();
  this.f_treb.lms_bq_init();
);

function lms_tonestack_jcm_set(bass, mid, treble)
  local(
    bass_db, mid_db, treb_db,
    bass_freq, mid_freq, treb_freq,
    mid_q, treb_q,
    bass_mid_xcouple, treb_mid_xcouple
  )
(
  // ---- Passive stack component values (JCM800 2203) ----
  // Bass: 250kΩ pot, 0.47µF cap → f = 1/(2π·R·C)
  // At pot max (250k): ~1.35Hz (full bass boost acts as sub-shelf)
  // Effective frequency at nominal settings: ~130Hz
  // We use the pot position to modulate both freq and gain
  bass_freq = 60 + bass * 140;    // 60Hz (scooped) to 200Hz (boosted)
  bass_db   = (bass - 0.5) * 18;  // ±9dB at extremes (passive stack range)

  // Mid: 25kΩ pot, 22nF cap → f ≈ 290Hz centre
  // The mid control is a CUT notch — mid=1.0 is LESS mid (more scooped)
  // mid=0.0 is MORE mid (less scooped). We invert so the knob feels right.
  mid_freq  = 370;               // fixed centre — passive RC sets this
  mid_q     = 1.0 + mid * 1.5;  // narrower Q at higher settings (pot loads the cap)
  mid_db    = (0.5 - mid) * 14; // mid=0→+7dB (full mid), mid=1→-7dB (scooped)

  // Treble: 1MΩ pot, 470pF cap → f ≈ 340Hz (but it's a shelf, not a peak)
  // Treble acts as high shelf pivoting around 1kHz
  treb_freq = 900 + treble * 600; // 900Hz to 1500Hz pivot
  treb_db   = (treble - 0.5) * 16; // ±8dB

  // Cross-coupling: turning bass up slightly cuts mid (passive interaction)
  bass_mid_xcouple = (bass - 0.5) * 3.0;
  // Turning treble up slightly lifts presence and cuts lower mid
  treb_mid_xcouple = (treble - 0.5) * 2.5;
  mid_db -= bass_mid_xcouple + treb_mid_xcouple;

  // Set the three interactive biquads
  this.f_bass.lms_bq_set_loshelf(bass_freq, bass_db, 0.6);
  this.f_mid.lms_bq_set_peak(mid_freq, mid_db, mid_q);
  this.f_treb.lms_bq_set_hishelf(treb_freq, treb_db, 0.75);
);

function lms_tonestack_jcm_proc(x)
  local(b)
(
  b = this.f_bass.lms_bq_proc_l(x);
  b = this.f_mid.lms_bq_proc_l(b);
  b = this.f_treb.lms_bq_proc_l(b);
  b;
);


// ============================================================================
//  SECTION 14: EL34 Push-Pull Power Amp (stateful)
//
//  Models the JCM800 power amp stage: two EL34 tubes in push-pull Class AB.
//
//  Push-pull topology:
//    - Odd harmonics dominate (2nd and 4th cancel in push-pull)
//    - Even harmonics very low at normal levels, rise with hard clipping
//    - Compression: power supply sag under heavy load (EL34 power amp sag
//      is subtler than rectifier-tube sag — more "giving" than "blooming")
//    - Presence control: modelled as variable high-frequency NFB
//      (real circuit: presence pot in series with cap to ground in NFB loop)
//      More presence = less HF NFB = more power amp gain + top-end openness
//
//  Usage:
//    @init:   pa.lms_el34_init();
//    @slider/@block: pa.lms_el34_set(drive, presence);
//                    // drive 0..1, presence 0..1
//    @sample: out = pa.lms_el34_proc(in);
// ============================================================================

function lms_el34_init()
(
  // Power supply sag envelope
  this.sag_env = 0;
  this.sag_att = exp(-1 / (srate * 0.015));  // 15ms attack (transformer limited)
  this.sag_rel = exp(-1 / (srate * 0.250));  // 250ms recovery
  // Presence shelving filter (models NFB loop)
  this.pres_f.lms_bq_init();
  // Output DC block
  this.dc.lms_dc_init();
);

function lms_el34_set(drive, presence)
  local(pres_freq, pres_db)
(
  this.drive = drive;
  // Presence: variable HF shelf (NFB reduces HF, so presence=1 lifts HF)
  // Real component: 33kΩ presence pot, 500pF cap → ~10kHz at max
  // At presence=0: heavy NFB, sounds dark and controlled
  // At presence=1: minimal NFB, bright and slightly "loose"
  pres_freq = 2000 + presence * 6000;  // 2kHz to 8kHz pivot
  pres_db   = presence * 8;            // 0 to +8dB — NFB reduction effect
  this.pres_f.lms_bq_set_hishelf(pres_freq, pres_db, 0.9);
);

function lms_el34_proc(x)
  local(b, peak, sag_gain, push, pull, out)
(
  // Power supply sag (envelope-based, class AB compression)
  peak = abs(x);
  peak > this.sag_env ? (
    this.sag_env = this.sag_att * this.sag_env + (1 - this.sag_att) * peak;
  ) : (
    this.sag_env = this.sag_rel * this.sag_env;
  );
  sag_gain = 1.0 / (1.0 + this.sag_env * 0.35);  // max ~26% sag at full clip

  b = x * sag_gain;

  // Drive into output stage
  b = b * (1.0 + this.drive * 2.5);

  // Push-pull: split into positive and negative half-cycles, clip each independently
  // Each EL34 handles one half. The odd-harmonic dominance is automatic from
  // running each half through the same nonlinearity — even harmonics cancel at
  // the output transformer.
  push = b > 0 ? b : 0;
  pull = b < 0 ? -b : 0;

  // EL34 plate saturation: 1-exp curve (harder than 12AX7, different character)
  // Positive half (push tube)
  push > 0 ? (
    push = 1.0 - exp(-push * 1.4);
  );
  // Negative half (pull tube) — slight mismatch creates tiny even harmonic residual
  // (real amps always have slight tube matching asymmetry)
  pull > 0 ? (
    pull = 1.0 - exp(-pull * 1.35);
  );

  // Recombine (restoring sign of pull half)
  out = push - pull;

  // Presence (HF NFB model — applied post-output-transformer)
  out = this.pres_f.lms_bq_proc_l(out);

  // DC block (transformer coupling)
  out = this.dc.lms_dc_proc_l(out);

  out * 0.85;
);


// ============================================================================
//  SECTION 15: Marshall 4×12 Cabinet — Celestion G12T-75 Model (stereo)
//
//  Five-band biquad model derived from measured frequency response of a
//  Marshall 1960A 4×12 loaded with Celestion G12T-75 speakers (65Hz tuning).
//
//  Bands (from measured cab IR / published Celestion data):
//
//    1. Cab resonance HP  — 80Hz Q=0.55 (ported cab tuning, -24dB/oct below 80)
//       Removes sub-bass that a real cab cannot reproduce
//
//    2. Cab resonance peak — 100Hz +3dB Q=1.8
//       The ported box resonance — that "thump" on low E palm mutes
//
//    3. Voice coil inductance notch — 1200Hz -4dB Q=0.9
//       Voice coil inductance causes a gentle dip in the 1-2kHz range
//       This is the characteristic "scoop" that makes a Celestion sound
//       different from a PA speaker
//
//    4. Cone breakup peak — 3500Hz +5dB Q=1.4
//       Celestion G12T-75 has a prominent cone resonance ~3-4kHz
//       This is the "edge" and "bite" — it's the Celestion sound
//
//    5. Air & baffle LP — 6500Hz Q=0.65 (2nd order rolloff above 6.5kHz)
//       High-frequency rolloff from cabinet baffle diffraction and
//       cone mass — real 12" speakers don't extend much past 6-7kHz
//
//  Usage:
//    @init:   cab.lms_cab_412_init();
//    @sample: l = cab.lms_cab_412_proc_l(l);
//             r = cab.lms_cab_412_proc_r(r);
//    (No set function needed — values are fixed from speaker physics)
// ============================================================================

function lms_cab_412_init()
(
  this.f1.lms_bq_init();  // cab resonance HP
  this.f2.lms_bq_init();  // cab resonance peak
  this.f3.lms_bq_init();  // voice coil notch
  this.f4.lms_bq_init();  // cone breakup peak
  this.f5.lms_bq_init();  // air LP

  // These are fixed — speaker physics don't change with settings
  this.f1.lms_bq_set_hp(80, 0.55);
  this.f2.lms_bq_set_peak(100, 3.0, 1.8);
  this.f3.lms_bq_set_peak(1200, -4.0, 0.9);
  this.f4.lms_bq_set_peak(3500, 5.0, 1.4);
  this.f5.lms_bq_set_lp(6500, 0.65);
);

function lms_cab_412_proc_l(x)
  local(b)
(
  b = this.f1.lms_bq_proc_l(x);
  b = this.f2.lms_bq_proc_l(b);
  b = this.f3.lms_bq_proc_l(b);
  b = this.f4.lms_bq_proc_l(b);
  b = this.f5.lms_bq_proc_l(b);
  b;
);

function lms_cab_412_proc_r(x)
  local(b)
(
  b = this.f1.lms_bq_proc_r(x);
  b = this.f2.lms_bq_proc_r(b);
  b = this.f3.lms_bq_proc_r(b);
  b = this.f4.lms_bq_proc_r(b);
  b = this.f5.lms_bq_proc_r(b);
  b;
);
