// ============================================================================
//  LMS Core DSP Library v1.0
//  Shared DSP building blocks for the LMS plugin suite
//
//  Usage: import lms_core.jsfx-inc
//
//  IMPORTANT: All functions must be inside @init so they are available
//  across all sections (@slider, @block, @sample, @gfx) in importing files.
//  JSFX rule: "functions defined in @init can be used from other sections,
//  whereas functions defined in other sections are local to those sections."
//
//  All functions use lms_ prefix. Stateful functions use this.* pattern —
//  call as instance.lms_xxx() to get independent state per instance.
//
//  Sections:
//    1. Math Utilities           (stateless)
//    2. Biquad Filter            (stereo, this.* state)
//    3. Saturation Suite         (stateless)
//    4. Compressor               (stereo, this.* state)
//    5. DC Blocker               (stereo, this.* state)
//    6. Tone Filter              (stereo, this.* state)
//    7. Cubic Interpolation      (stateless)
//    8. Spring Reverb Allpass    (stateless, buffer-based)
//    9. Sag Simulator            (this.* state) — tube rectifier droop
//   10. Cascaded Saturation      (stateless) — Marshall cold-clipper model
//   11. Opto Compressor          (this.* state) — LA-2A T4B photocell model
//   12. 12AX7 Triode V1B/V1A    (this.* state) — JCM800 preamp stages
//   13. Marshall JCM800 Tone Stack (this.* state) — passive Baxandall
//   14. EL34 Push-Pull Power Amp  (this.* state) — JCM800 power section
//   15. Marshall 4×12 Cabinet — Celestion G12T-75 (this.* state)
//   16. Mesa Triple Rectifier V2b Cold-Bias Stage (this.* state)
//   17. 6L6 Push-Pull Power Amp  (this.* state) — Mesa Triple Rectifier
//   18. Mesa 4×12 Cabinet — Celestion V30 (this.* state)
//   19. Mesa Triple Rectifier Tone Stack (this.* state)
// ============================================================================

@init

// ============================================================================
//  SECTION 1: Math Utilities (stateless)
// ============================================================================

// Bounded exp-based tanh approximation (JSFX has no built-in tanh)
function lms_tanh(x)
  local(e2x)
(
  x > 10 ? 1 : x < -10 ? -1 : (
    e2x = exp(2 * x);
    (e2x - 1) / (e2x + 1);
  );
);

// dB to linear gain
function lms_db2lin(db)
(
  10 ^ (db / 20);
);

// Linear gain to dB (safe — returns -140 for silence)
function lms_lin2db(lin)
(
  lin > 0.0000001 ? 20 * log10(lin) : -140;
);


// ============================================================================
//  ADAA — Antiderivative Anti-Aliasing primitives
//
//  First-order ADAA eliminates aliasing from static nonlinearities without
//  upsampling. Instead of computing f(x[n]) directly, we compute:
//
//    y[n] = (F(x[n]) - F(x[n-1])) / (x[n] - x[n-1])
//
//  where F is the antiderivative (indefinite integral) of f.
//  When x[n] ≈ x[n-1] (signal nearly static), fall back to f(midpoint)
//  to avoid divison by zero.
//
//  Each clipping function needs:
//    1. The function itself          f(x)   — for the fallback
//    2. Its antiderivative           F(x)   — for the main path
//
//  These are the primitive F(x) functions. They are called paired with their
//  f(x) counterparts by the stateful ADAA wrappers below.
//
//  Antiderivatives:
//    tanh(x)           → log(cosh(x))        [numerically: |x| - log2 for large |x|]
//    (2/π)·atan(x)     → (2/π)·(x·atan(x) - ½·log(1+x²))
//    1 - exp(-|x|)     → |x| + exp(-|x|)     [for the 1-exp soft clipper]
//    sign(x)·(1-exp(-|x|)) → sign(x)·(|x|+exp(-|x|)) — same, signed
// ============================================================================

// Antiderivative of tanh(x): log(cosh(x))
// Numerically stable: for |x|>10, cosh(x) overflows, so use |x|-log(2) approx
function lms_F_tanh(x)
(
  abs(x) > 10 ? abs(x) - 0.6931471805599453 :  // log(2)
  log(exp(x) * 0.5 + exp(-x) * 0.5);           // log(cosh(x))
);

// Antiderivative of (2/π)·atan(x): (2/π)·(x·atan(x) - 0.5·log(1+x²))
function lms_F_atan(x)
  local(r)
(
  r = (2 / $pi) * (x * atan(x) - 0.5 * log(1 + x * x));
  r;
);

// Antiderivative of (1 - exp(-x)) for x ≥ 0: x + exp(-x)
// For the full signed version sign(x)·(1-exp(-|x|)): sign(x)·(|x|+exp(-|x|))
function lms_F_1exp_pos(x)
(
  x + exp(-x);
);

function lms_F_1exp_signed(x)
  local(ax)
(
  ax = abs(x);
  sign(x) * (ax + exp(-ax));
);

// ADAA core: given x_now, x_prev, F(x_now), F(x_prev), f(midpoint) fallback
// Returns the alias-suppressed output sample.
//
// Uses a crossfade zone instead of a hard epsilon switch. A single threshold
// creates a "no man's land" where dx is small enough for the division to amplify
// floating-point noise but not small enough to trigger fallback — this manifests
// as hiss on note decay tails. The crossfade blends smoothly between ADAA and
// fallback, eliminating both the hard-switch artifact and the noisy-division zone.
function lms_adaa_eval(x_now, x_prev, Fx_now, Fx_prev, f_mid)
  local(dx, adx, adaa_out, blend)
(
  dx  = x_now - x_prev;
  adx = abs(dx);
  adx < 0.00001 ? (
    f_mid;
  ) : adx > 0.0001 ? (
    (Fx_now - Fx_prev) / dx;
  ) : (
    adaa_out = (Fx_now - Fx_prev) / dx;
    blend = (adx - 0.00001) / (0.00009);  // 0..1 across the transition band
    f_mid + blend * (adaa_out - f_mid);
  );
);


// ============================================================================
//  SECTION 2: Biquad Filter (stereo, this.* state)
//
//  One instance = one stereo band.
//  Coefficients shared, L/R state separate.
//
//  Usage:
//    @init:   hp.lms_bq_init();
//    @slider: hp.lms_bq_set_hp(freq, 0.707);
//    @block:  hp.lms_bq_set_hp(freq, 0.707);
//    @sample: l = hp.lms_bq_proc_l(l);
//             r = hp.lms_bq_proc_r(r);
// ============================================================================

// Initialize biquad — zero state and set to passthrough
function lms_bq_init()
(
  // Coefficients (passthrough)
  this.b0 = 1; this.b1 = 0; this.b2 = 0;
  this.a1 = 0; this.a2 = 0;
  // Left channel state
  this.lx1 = 0; this.lx2 = 0;
  this.ly1 = 0; this.ly2 = 0;
  // Right channel state
  this.rx1 = 0; this.rx2 = 0;
  this.ry1 = 0; this.ry2 = 0;
);

// Highpass (2nd order Butterworth when q = 0.707)
function lms_bq_set_hp(freq, q)
  local(w0, cs, sn, alpha, a0_inv)
(
  w0 = 2 * $pi * freq / srate;
  cs = cos(w0); sn = sin(w0);
  alpha = sn / (2 * q);
  a0_inv = 1 / (1 + alpha);
  this.b0 = (1 + cs) / 2 * a0_inv;
  this.b1 = -(1 + cs) * a0_inv;
  this.b2 = (1 + cs) / 2 * a0_inv;
  this.a1 = -2 * cs * a0_inv;
  this.a2 = (1 - alpha) * a0_inv;
);

// Lowpass
function lms_bq_set_lp(freq, q)
  local(w0, cs, sn, alpha, a0_inv)
(
  w0 = 2 * $pi * freq / srate;
  cs = cos(w0); sn = sin(w0);
  alpha = sn / (2 * q);
  a0_inv = 1 / (1 + alpha);
  this.b0 = (1 - cs) / 2 * a0_inv;
  this.b1 = (1 - cs) * a0_inv;
  this.b2 = (1 - cs) / 2 * a0_inv;
  this.a1 = -2 * cs * a0_inv;
  this.a2 = (1 - alpha) * a0_inv;
);

// Bandpass (constant skirt gain)
function lms_bq_set_bp(freq, q)
  local(w0, cs, sn, alpha, a0_inv)
(
  w0 = 2 * $pi * freq / srate;
  cs = cos(w0); sn = sin(w0);
  alpha = sn / (2 * q);
  a0_inv = 1 / (1 + alpha);
  this.b0 = (sn / 2) * a0_inv;
  this.b1 = 0;
  this.b2 = -(sn / 2) * a0_inv;
  this.a1 = -2 * cs * a0_inv;
  this.a2 = (1 - alpha) * a0_inv;
);

// Parametric peaking EQ
function lms_bq_set_peak(freq, gain_db, q)
  local(a, w0, alpha, a0_inv)
(
  a = 10 ^ (gain_db / 20);
  w0 = 2 * $pi * freq / srate;
  alpha = sin(w0) / (2 * q);
  a0_inv = 1 / (1 + alpha / a);
  this.b0 = (1 + alpha * a) * a0_inv;
  this.b1 = (-2 * cos(w0)) * a0_inv;
  this.b2 = (1 - alpha * a) * a0_inv;
  this.a1 = this.b1;
  this.a2 = (1 - alpha / a) * a0_inv;
);

// Low shelf
function lms_bq_set_loshelf(freq, gain_db, q)
  local(a, w0, cs, sn, alpha, ap1, am1, beta, a0_inv)
(
  a = 10 ^ (gain_db / 40);
  w0 = 2 * $pi * freq / srate;
  cs = cos(w0); sn = sin(w0);
  alpha = sn / (2 * q);
  ap1 = a + 1; am1 = a - 1;
  beta = 2 * sqrt(a) * alpha;
  a0_inv = 1 / (ap1 + am1 * cs + beta);
  this.b0 = a * (ap1 - am1 * cs + beta) * a0_inv;
  this.b1 = 2 * a * (am1 - ap1 * cs) * a0_inv;
  this.b2 = a * (ap1 - am1 * cs - beta) * a0_inv;
  this.a1 = -2 * (am1 + ap1 * cs) * a0_inv;
  this.a2 = (ap1 + am1 * cs - beta) * a0_inv;
);

// High shelf
function lms_bq_set_hishelf(freq, gain_db, q)
  local(a, w0, cs, sn, alpha, ap1, am1, beta, a0_inv)
(
  a = 10 ^ (gain_db / 40);
  w0 = 2 * $pi * freq / srate;
  cs = cos(w0); sn = sin(w0);
  alpha = sn / (2 * q);
  ap1 = a + 1; am1 = a - 1;
  beta = 2 * sqrt(a) * alpha;
  a0_inv = 1 / (ap1 - am1 * cs + beta);
  this.b0 = a * (ap1 + am1 * cs + beta) * a0_inv;
  this.b1 = -2 * a * (am1 + ap1 * cs) * a0_inv;
  this.b2 = a * (ap1 + am1 * cs - beta) * a0_inv;
  this.a1 = 2 * (am1 - ap1 * cs) * a0_inv;
  this.a2 = (ap1 - am1 * cs - beta) * a0_inv;
);

// Process left channel sample through biquad
function lms_bq_proc_l(x)
  local(o)
(
  o = this.b0 * x + this.b1 * this.lx1 + this.b2 * this.lx2
                   - this.a1 * this.ly1 - this.a2 * this.ly2;
  this.lx2 = this.lx1; this.lx1 = x;
  this.ly2 = this.ly1; this.ly1 = o;
  o;
);

// Process right channel sample through biquad
function lms_bq_proc_r(x)
  local(o)
(
  o = this.b0 * x + this.b1 * this.rx1 + this.b2 * this.rx2
                   - this.a1 * this.ry1 - this.a2 * this.ry2;
  this.rx2 = this.rx1; this.rx1 = x;
  this.ry2 = this.ry1; this.ry1 = o;
  o;
);


// ============================================================================
//  SECTION 3: Saturation Suite (stateful, ADAA anti-aliased)
//
//  All functions use this.* state to hold x_prev / Fx_prev for ADAA.
//  Call <instance>.lms_sat_XXX_init() once in @init, then
//  call <instance>.lms_sat_XXX(x, drive, bias) per sample.
//
//  The ADAA path computes the alias-suppressed output via antiderivatives.
//  Stateless helper lms_tanh() is still available for non-clipping uses.
//
//  Usage:
//    @init:   sat.lms_sat_warm_init();
//    @sample: l = sat.lms_sat_warm(l, drive, bias);
// ============================================================================

// ---- lms_sat_warm — asymmetric tanh, even harmonics, warm tube character ----

function lms_sat_warm_init()
(
  this.xp = 0;   // previous pre-clip input (after gain/bias)
  this.Fp = 0;   // F(xp) — antiderivative at previous input
);

function lms_sat_warm(x, drive, bias)
  local(b, bp, s, Fb, mid, f_mid)
(
  // Apply gain and bias (same as before)
  b  = (x  + bias * 0.1) * (1 + drive);
  bp = this.xp;   // previous scaled input

  // Asymmetric antiderivative: positive path uses tanh, negative uses tanh(b*0.8)*1.25
  // We compute each half's antiderivative separately, choosing based on sign of midpoint
  mid = (b + bp) * 0.5;
  mid >= 0 ? (
    // Positive half — F(tanh(x)) = log(cosh(x))
    Fb    = lms_F_tanh(b);
    f_mid = lms_tanh(mid);
  ) : (
    // Negative half — f(x) = tanh(x*0.8)*1.25
    // F: tanh(0.8x)*1.25 antiderivative = 1.25/0.8 * log(cosh(0.8x)) = 1.5625*log(cosh(0.8x))
    Fb    = lms_F_tanh(b * 0.8) * 1.5625;
    f_mid = lms_tanh(mid * 0.8) * 1.25;
  );

  s = lms_adaa_eval(b, bp, Fb, this.Fp, f_mid);

  // Update state (store pre-clip value; Fp matches the half we just used)
  this.xp = b;
  this.Fp = Fb;
  s;
);


// ---- lms_sat_hot — 1-exp aggressive tube, harder asymmetric clip ----

function lms_sat_hot_init()
(
  this.xp = 0;
  this.Fp = 0;
);

function lms_sat_hot(x, drive, bias)
  local(b, bp, Fb, mid, f_mid, ab, s)
(
  b  = (x + bias * 0.15) * (1 + drive * 2);
  bp = this.xp;
  mid = (b + bp) * 0.5;

  b >= 0 ? (
    // Positive: f(x) = 1-exp(-x)   F(x) = x+exp(-x)
    Fb    = lms_F_1exp_pos(b);
    f_mid = mid >= 0 ? 1 - exp(-mid) : -(1 - exp(-abs(mid * 0.7))) * 1.1;
  ) : (
    // Negative: f(x) = -(1-exp(-|x*0.7|))*1.1
    // F: antiderivative of -(1-exp(-0.7*(-x)))*1.1 for x<0
    //  = -1.1*(x + exp(0.7*x)/0.7)  [substituting u=0.7*(-x)]
    ab = abs(b);
    Fb = -1.1 * (-ab + exp(-ab * 0.7) / (-0.7));
    // simplified: 1.1*(ab + exp(-0.7*ab)/0.7)... let's keep it explicit
    Fb = 1.1 * (ab - exp(-0.7 * ab) / 0.7);
    f_mid = -(1 - exp(-abs(mid * 0.7))) * 1.1;
  );

  s = lms_adaa_eval(b, bp, Fb, this.Fp, f_mid);
  this.xp = b;
  this.Fp = Fb;
  s;
);


// ---- lms_sat_tape — symmetric arctan ----

function lms_sat_tape_init()
(
  this.xp = 0;
  this.Fp = 0;
);

function lms_sat_tape(x, drive, bias)
  local(b, bp, Fb, mid, s, scale)
(
  scale = $pi * 0.5;
  b  = (x + bias * 0.05) * (1 + drive * 1.5) * scale;
  bp = this.xp;
  mid = (b + bp) * 0.5;

  // f(x) = (2/π)·atan(x·π/2)  →  F(x) = lms_F_atan at scaled x
  Fb = lms_F_atan(b);
  s  = lms_adaa_eval(b, bp, Fb, this.Fp, (2 / $pi) * atan(mid));

  this.xp = b;
  this.Fp = Fb;
  s;
);


// ---- lms_sat_rect — half-wave rectifier, asymmetric tanh ----

function lms_sat_rect_init()
(
  this.xp = 0;
  this.Fp = 0;
);

function lms_sat_rect(x, drive, bias)
  local(b, bp, Fb, mid, s, neg_scale)
(
  b  = x + bias * 0.2;
  b *= (1 + drive * 3);
  b < 0 ? b = b * (0.2 + drive * 0.1);  // fold negative (same as before)
  bp = this.xp;
  mid = (b + bp) * 0.5;

  // tanh path (same antiderivative regardless of sign after fold)
  Fb = lms_F_tanh(b);
  s  = lms_adaa_eval(b, bp, Fb, this.Fp, lms_tanh(mid));

  this.xp = b;
  this.Fp = Fb;
  s;
);


// ---- lms_sat_fuzz — gated fuzz, sign(x)·(1-exp(-|x|)) ----

function lms_sat_fuzz_init()
(
  this.xp = 0;
  this.Fp = 0;
);

function lms_sat_fuzz(x, drive, bias)
  local(b, bp, Fb, mid, f_mid, s, gate)
(
  b  = (x + bias * 0.1) * (1 + drive * 4);
  bp = this.xp;
  gate = 0.1 * (1 - drive * 0.5);
  mid = (b + bp) * 0.5;

  abs(b) < gate ? (
    // Linear region — no aliasing here, ADAA not needed
    Fb    = b * b * (0.3 + drive * 0.7) * 0.5;  // F of linear = x²/2 * gain
    f_mid = mid * (0.3 + drive * 0.7);
  ) : (
    // Saturation region: f(x) = sign(x)*(1-exp(-|x|))  F(x) = sign(x)*(|x|+exp(-|x|))
    Fb    = lms_F_1exp_signed(b);
    f_mid = sign(mid) * (1 - exp(-abs(mid)));
  );

  s = lms_adaa_eval(b, bp, Fb, this.Fp, f_mid);
  this.xp = b;
  this.Fp = Fb;
  s;
);


// ---- lms_sat_harmonics — polynomial harmonic blend (no hard clip, minimal aliasing) ----
// Polynomial distortion aliases less severely than hard clippers, but x³ still aliases.
// We use ADAA on the x³ term (F(x³) = x⁴/4) and exact for x|x| (F = x²|x|/3).
// This is kept stateless-style since it's additive blend, not a full clipper.

function lms_sat_harmonics_init()
(
  this.xp = 0;
  this.F2p = 0;
  this.F3p = 0;
);

function lms_sat_harmonics(x, even_mix, odd_mix)
  local(x2_now, x3_now, F2_now, F3_now, x2_aa, x3_aa, result, mid)
(
  mid = (x + this.xp) * 0.5;

  // Even: f(x) = x*|x|  (2nd harmonic, signed square)  F(x) = x²|x|/3
  F2_now = x * x * abs(x) / 3;
  x2_aa  = lms_adaa_eval(x, this.xp, F2_now, this.F2p, mid * abs(mid));

  // Odd: f(x) = x³   F(x) = x⁴/4
  F3_now = x * x * x * x / 4;
  x3_aa  = lms_adaa_eval(x, this.xp, F3_now, this.F3p, mid * mid * mid);

  result = x + even_mix * x2_aa * 0.3 + odd_mix * x3_aa * 0.2;

  this.xp   = x;
  this.F2p  = F2_now;
  this.F3p  = F3_now;
  result;
);


// ============================================================================
//  SECTION 4: Compressor — FET-style (stereo, this.* state)
//
//  Stereo-linked peak detection with envelope follower.
//
//  Usage:
//    @init:   comp.lms_comp_init();
//    @slider: comp.lms_comp_set(thresh_db, ratio, att_ms, rel_ms);
//    @block:  comp.lms_comp_set(thresh_db, ratio, att_ms, rel_ms);
//    @sample: comp.lms_comp_proc(l, r);
//             l *= comp.gr;
//             r *= comp.gr;
//             // comp.gr_db has dB of gain reduction
// ============================================================================

// Initialize compressor state
function lms_comp_init()
(
  this.env = 0;
  this.gr = 1;
  this.gr_db = 0;
  this.thresh = 0;
  this.ratio = 4;
  this.att = 0;
  this.rel = 0;
);

// Set compressor parameters
function lms_comp_set(thresh_db, ratio, att_ms, rel_ms)
(
  this.thresh = thresh_db;
  this.ratio = ratio;
  this.att = exp(-1 / (att_ms * 0.001 * srate));
  this.rel = exp(-1 / (rel_ms * 0.001 * srate));
);

// Process stereo pair — updates this.gr (linear) and this.gr_db
function lms_comp_proc(l, r)
  local(det, det_db, over, target_gr)
(
  det = max(abs(l), abs(r));
  det_db = det > 0.0000001 ? 20 * log10(det) : -140;
  over = det_db - this.thresh;
  over > 0 ? (
    target_gr = over - over / this.ratio;
  ) : (
    target_gr = 0;
  );
  target_gr > this.env ? (
    this.env = this.att * this.env + (1 - this.att) * target_gr;
  ) : (
    this.env = this.rel * this.env + (1 - this.rel) * target_gr;
  );
  this.gr = 10 ^ (-this.env / 20);
  this.gr_db = this.env;
);


// ============================================================================
//  SECTION 5: DC Blocker (stereo, this.* state)
//
//  1-pole highpass to remove DC offset from asymmetric clipping.
//
//  Usage:
//    @init:   dc.lms_dc_init();          // 20 Hz default
//             dc.lms_dc_init_freq(220);  // or custom cutoff
//    @sample: l = dc.lms_dc_proc_l(l);
//             r = dc.lms_dc_proc_r(r);
// ============================================================================

// Initialize DC blocker with default 20 Hz cutoff
function lms_dc_init()
(
  this.xl = 0; this.xr = 0;
  this.yl = 0; this.yr = 0;
  this.r = 1 - (20 / srate);
);

// Initialize DC blocker with custom cutoff frequency
function lms_dc_init_freq(freq)
(
  this.xl = 0; this.xr = 0;
  this.yl = 0; this.yr = 0;
  this.r = 1 - (freq / srate);
);

// Process left channel
function lms_dc_proc_l(x)
(
  this.yl = x - this.xl + this.r * this.yl;
  this.xl = x;
  this.yl;
);

// Process right channel
function lms_dc_proc_r(x)
(
  this.yr = x - this.xr + this.r * this.yr;
  this.xr = x;
  this.yr;
);


// ============================================================================
//  SECTION 6: Tone Filter — 1-pole Lowpass (stereo, this.* state)
//
//  Simple 1-pole lowpass for tone control.
//
//  Usage:
//    @init:   tone.lms_tone_init();
//    @slider: tone.lms_tone_set(freq);
//    @block:  tone.lms_tone_set(freq);
//    @sample: l = tone.lms_tone_proc_l(l);
//             r = tone.lms_tone_proc_r(r);
// ============================================================================

// Initialize tone filter state
function lms_tone_init()
(
  this.yl = 0;
  this.yr = 0;
  this.coeff = 0;
  this.freq = 20000;
);

// Set tone filter cutoff frequency
function lms_tone_set(freq)
(
  this.freq = freq;
  this.coeff = exp(-2 * $pi * freq / srate);
);

// Process left channel (bypasses if freq >= 19999)
function lms_tone_proc_l(x)
(
  this.freq < 19999 ? (
    this.yl = this.yl * this.coeff + x * (1 - this.coeff);
    this.yl;
  ) : (
    x;
  );
);

// Process right channel (bypasses if freq >= 19999)
function lms_tone_proc_r(x)
(
  this.freq < 19999 ? (
    this.yr = this.yr * this.coeff + x * (1 - this.coeff);
    this.yr;
  ) : (
    x;
  );
);


// ============================================================================
//  SECTION 7: Cubic Interpolation (stateless)
//
//  Hermite cubic interpolation for reading from circular delay buffers.
//
//  Usage:
//    out = lms_interp_cubic(buf, pos, bmax);
// ============================================================================

function lms_interp_cubic(buf, pos, bmax)
  local(p0, p1, p2, p3, x0, x1, x2, x3, a, b, c, d, frac, idx)
(
  idx = floor(pos);
  frac = pos - idx;

  p0 = idx - 1; p0 < 0 ? p0 += bmax;
  p1 = idx;     p1 >= bmax ? p1 -= bmax;
  p2 = idx + 1; p2 >= bmax ? p2 -= bmax;
  p3 = idx + 2; p3 >= bmax ? p3 -= bmax;

  x0 = buf[p0]; x1 = buf[p1]; x2 = buf[p2]; x3 = buf[p3];

  // Cubic Hermite interpolation
  a = -0.5*x0 + 1.5*x1 - 1.5*x2 + 0.5*x3;
  b = x0 - 2.5*x1 + 2*x2 - 0.5*x3;
  c = -0.5*x0 + 0.5*x2;
  d = x1;

  ((a * frac + b) * frac + c) * frac + d;
);


// ============================================================================
//  SECTION 8: Spring Reverb Allpass (stateless, buffer-based)
//
//  Single allpass unit for spring reverb / diffusion networks.
//  Caller manages buffer position advancement.
//
//  Usage:
//    out = lms_spring_ap(buf, pos, len, input, coeff);
//    pos += 1; pos >= len ? pos = 0;
// ============================================================================

function lms_spring_ap(buf, pos, len, input, coeff)
  local(delayed, output)
(
  delayed = buf[pos];
  output = -input * coeff + delayed;
  buf[pos] = input + delayed * coeff;
  output;
);


// ============================================================================
//  SECTION 9: Sag Simulator (tube rectifier voltage droop)
//
//  Models the voltage sag of a tube rectifier under heavy load.
//  On loud transients the rectifier can't supply full voltage → the signal
//  "blooms" in: slow attack, slower release. Creates the elastic, organic
//  feel of vintage amps vs. silicon diode tightness.
//
//  Usage:
//    sag.lms_sag_init();
//    sag.lms_sag_set(20);          // attack in ms (15-30ms typical)
//    // in @sample:
//    gain = sag.lms_sag_proc(input_sample);
//    output = input * gain;
//
//  After proc: this.gr is the linear gain reduction (0.7 to 1.0)
// ============================================================================

function lms_sag_init()
(
  this.env = 0;
  this.att = 0;
  this.rel = 0;
  this.gr = 1;
  this.depth = 0.3;   // max sag depth (0 = none, 1 = 100% reduction)
);

function lms_sag_set(att_ms)
(
  // Attack: how fast the sag builds (slow = more bloom)
  this.att = exp(-1 / (srate * att_ms * 0.001));
  // Release: sag recovers much slower than it builds (3x attack time)
  this.rel = exp(-1 / (srate * att_ms * 0.003));
);

function lms_sag_proc(x)
  local(level)
(
  level = abs(x);
  level > this.env ? (
    this.env = this.att * this.env + (1 - this.att) * level;
  ) : (
    this.env = this.rel * this.env + (1 - this.rel) * level;
  );
  // Sag: high signal level → lower gain (simulates voltage droop)
  // env near 0 → gr near 1.0 (no sag), env near 1 → gr near (1 - depth)
  this.gr = 1 - this.depth * min(1, this.env);
  this.gr;
);


// ============================================================================
//  SECTION 10: Two-Stage Cascaded Saturation (Marshall cold-clipper model)
//
//  Models the V1B → V1A dual-triode chain in the JCM800 preamp.
//  V1A runs cold-biased (high bias resistor), generating asymmetric
//  2nd harmonic clipping early in the signal path — the source of the
//  JCM800's characteristic "crunch" even at moderate gain settings.
//
//  Usage:
//    out = lms_sat_cascade(x, drive1, bias1, drive2, bias2);
//    // drive/bias same ranges as lms_sat_warm
// ============================================================================

// DEPRECATED: lms_sat_cascade — lms_sat_warm is now stateful (instance method).
// Use two explicit instance calls instead:
//   s1.lms_sat_warm(x, drive1, bias1);
//   s2.lms_sat_warm(stage1, drive2, bias2);


// ============================================================================
//  SECTION 11: Opto Compressor (LA-2A T4B photocell model)
//
//  Program-dependent release: fast initial release from the photocell
//  discharging quickly, then slow final release as the electroluminescent
//  panel dims. Creates the "breathing" characteristic of optical compressors
//  — musical and forgiving, unlike FET or VCA compressors.
//
//  Attack is inherently fast (optical cell responds quickly to light).
//  Release is dual-stage: fast release (~50ms) then slow tail (~500ms).
//
//  Usage:
//    opto.lms_opto_init();
//    opto.lms_opto_set(-18, 4, 10);   // thresh_db, ratio, att_ms
//    // in @sample:
//    opto.lms_opto_proc(spl0, spl1);
//    spl0 *= opto.gr;
//    spl1 *= opto.gr;
//
//  After proc: this.gr (linear gain), this.gr_db (gain reduction in dB)
// ============================================================================

function lms_opto_init()
(
  this.env_fast = 0;
  this.env_slow = 0;
  this.gr = 1;
  this.gr_db = 0;
  this.thresh = lms_db2lin(-18);
  this.ratio = 4;
  this.att = 0;
  this.rel_fast = 0;
  this.rel_slow = 0;
);

function lms_opto_set(thresh_db, ratio, att_ms)
(
  this.thresh = lms_db2lin(thresh_db);
  this.ratio = ratio;
  // Attack: fast optical response (~10ms default)
  this.att = exp(-1 / (srate * att_ms * 0.001));
  // Release: T4B dual-stage — fast cell discharge then slow panel dim
  this.rel_fast = exp(-1 / (srate * 0.060));  // 60ms fast release
  this.rel_slow = exp(-1 / (srate * 0.500));  // 500ms slow tail
);

function lms_opto_proc(l, r)
  local(peak, over, target_gr, env)
(
  // Stereo peak detection
  peak = max(abs(l), abs(r));

  // Fast attack envelope
  peak > this.env_fast ? (
    this.env_fast = this.att * this.env_fast + (1 - this.att) * peak;
  ) : (
    // Dual-stage release: blend fast+slow envelopes (T4B photocell model)
    this.env_fast = this.rel_fast * this.env_fast;
    this.env_slow = this.rel_slow * this.env_slow + (1 - this.rel_slow) * this.env_fast;
    this.env_fast = max(this.env_fast, this.env_slow * 0.5);
  );

  env = this.env_fast;

  // Gain computation: soft knee around threshold
  env > this.thresh ? (
    over = env / this.thresh;
    // Soft-knee reduction: gentle slope, not brickwall
    target_gr = pow(over, -(1 - 1/this.ratio));
    this.gr = target_gr;
  ) : (
    this.gr = 1;
  );

  this.gr_db = lms_lin2db(this.gr);
  this.gr;
);


// ============================================================================
//  SECTION 12: 12AX7 Triode Models (stateful — one instance per tube stage)
//
//  Two variants matching the JCM800 2203 preamp topology:
//
//  V1B — first triode, UNBYPASSED cathode resistor (820Ω, no cap).
//        The unbypassed cathode provides local negative feedback, which:
//          - Reduces effective gain (~35 vs ~100 for bypassed)
//          - Softens clipping (feedback linearizes the transfer curve)
//          - Adds even harmonics (2nd dominant) due to class-A asymmetry
//        Transfer curve: arctan-based with asymmetric softclip
//        Models: Rk=820Ω, Ra=100kΩ, B+=300V operating point
//
//  V1A — second triode, BYPASSED cathode (10µF cap across 820Ω cathode).
//        Bypass cap shorts the cathode resistor at audio frequencies:
//          - Full gain restored (~60 effective, loaded by next stage)
//          - Harder clipping (no linearizing feedback)
//          - More 3rd harmonic content (symmetric grid limiting)
//          - Slight asymmetry from DC operating point offset
//        This stage is what makes the JCM800 Hi input aggressive.
//
//  Both stages include:
//    - Input coupling cap (35Hz HPF) — removes inter-stage DC
//    - Grid-to-cathode soft limiting (grid current above ~0.6V)
//    - Output normalised to unity at nominal plate swing
//
//  Usage:
//    @init:   v1b.lms_triode_v1b_init();
//             v1a.lms_triode_v1a_init();
//    @sample: out = v1b.lms_triode_v1b_proc(in, drive);
//             out = v1a.lms_triode_v1a_proc(in, drive);
//    drive: 0..1 — maps to input level into the stage (0=clean, 1=full grid swing)
// ============================================================================

function lms_triode_v1b_init()
(
  // Coupling cap HPF state (35Hz, removes inter-stage DC)
  this.hpx = 0; this.hpy = 0;
  this.hp_r = 1 - (2 * $pi * 35 / srate);
  // ADAA state for main transfer curve (asymmetric atan)
  this.xp_pos = 0; this.Fp_pos = 0;  // positive half ADAA state
  this.xp_neg = 0; this.Fp_neg = 0;  // negative half ADAA state
  // ADAA state for grid current tanh knee
  this.xp_gc = 0; this.Fp_gc = 0;
);

function lms_triode_v1b_proc(x, drive)
  local(gain, b, b_in, Fb, mid, f_mid, b_gc, Fb_gc)
(
  // Coupling cap (inter-stage HP, removes DC)
  this.hpy = x - this.hpx + this.hp_r * this.hpy;
  this.hpx = x;
  b = this.hpy;

  gain = 1.0 + drive * 3.0;
  b = b * gain;
  b_in = b;  // save for ADAA

  // Asymmetric atan transfer — ADAA per half
  // Positive: f(x) = (2/π)·atan(x·1.2)·0.85   F(x) = 0.85·lms_F_atan(x·1.2)/1.2
  // Negative: f(x) = (2/π)·atan(x·1.5)·1.0    F(x) = lms_F_atan(x·1.5)/1.5
  b >= 0 ? (
    mid   = (b + this.xp_pos) * 0.5;
    Fb    = lms_F_atan(b * 1.2) * 0.85 / 1.2;
    f_mid = (2 / $pi) * atan(mid * 1.2) * 0.85;
    b     = lms_adaa_eval(b, this.xp_pos, Fb, this.Fp_pos, f_mid);
    this.xp_pos = b_in; this.Fp_pos = Fb;
    // reset negative half state to current value to avoid discontinuity on sign change
    this.xp_neg = b_in; this.Fp_neg = lms_F_atan(b_in * 1.5) / 1.5;
  ) : (
    mid   = (b + this.xp_neg) * 0.5;
    Fb    = lms_F_atan(b * 1.5) / 1.5;
    f_mid = (2 / $pi) * atan(mid * 1.5);
    b     = lms_adaa_eval(b, this.xp_neg, Fb, this.Fp_neg, f_mid);
    this.xp_neg = b_in; this.Fp_neg = Fb;
    this.xp_pos = b_in; this.Fp_pos = lms_F_atan(b_in * 1.2) * 0.85 / 1.2;
  );

  // Grid current soft knee — ADAA tanh
  // Only active when b > 0.3; below that, signal passes through unchanged
  b > 0.3 ? (
    b_gc = b / 0.55;
    mid  = (b_gc + this.xp_gc) * 0.5;
    Fb_gc = lms_F_tanh(b_gc) * 0.55;
    b    = lms_adaa_eval(b_gc, this.xp_gc, Fb_gc, this.Fp_gc, lms_tanh(mid)) * 0.55;
    this.xp_gc = b_gc; this.Fp_gc = Fb_gc;
  ) : (
    this.xp_gc = b / 0.55; this.Fp_gc = lms_F_tanh(b / 0.55) * 0.55;
  );

  b * 0.8;
);


function lms_triode_v1a_init()
(
  // Coupling cap HPF (35Hz) — same as V1B
  this.hpx = 0; this.hpy = 0;
  this.hp_r = 1 - (2 * $pi * 35 / srate);
  // ADAA state: 1-exp clipper (two halves) + grid current tanh
  this.xp_pos = 0; this.Fp_pos = 0;
  this.xp_neg = 0; this.Fp_neg = 0;
  this.xp_gc  = 0; this.Fp_gc  = 0;
);

function lms_triode_v1a_proc(x, drive)
  local(gain, b, b_in, ab, Fb, mid, f_mid, b_gc, Fb_gc)
(
  // Coupling cap
  this.hpy = x - this.hpx + this.hp_r * this.hpy;
  this.hpx = x;
  b = this.hpy;

  gain = 1.0 + drive * 5.5;
  b = b * gain;
  b_in = b;

  // 1-exp clipper — ADAA per half
  // Positive: f(x) = 1-exp(-1.1·x)    F(x) = x + exp(-1.1·x)/1.1
  // Negative: f(x) = -(1-exp(-0.85·|x|))·1.05
  //           F(x) for x<0: -1.05·(-x + exp(0.85·x)/0.85) = 1.05·(|x|-exp(-0.85·|x|)/0.85)
  b >= 0 ? (
    mid   = (b + this.xp_pos) * 0.5;
    Fb    = b + exp(-1.1 * b) / 1.1;
    f_mid = mid >= 0 ? 1.0 - exp(-abs(mid) * 1.1) : 0;
    b     = lms_adaa_eval(b, this.xp_pos, Fb, this.Fp_pos, f_mid);
    this.xp_pos = b_in; this.Fp_pos = Fb;
    this.xp_neg = b_in; ab = abs(b_in); this.Fp_neg = 1.05 * (ab - exp(-0.85 * ab) / 0.85);
  ) : (
    ab    = abs(b);
    mid   = (b + this.xp_neg) * 0.5;
    Fb    = 1.05 * (ab - exp(-0.85 * ab) / 0.85);
    f_mid = -(1.0 - exp(-abs(mid) * 0.85)) * 1.05;
    b     = lms_adaa_eval(b, this.xp_neg, Fb, this.Fp_neg, f_mid);
    this.xp_neg = b_in; this.Fp_neg = Fb;
    this.xp_pos = b_in; this.Fp_pos = b_in + exp(-1.1 * b_in) / 1.1;
  );

  // Grid current tanh knee — ADAA
  b > 0.35 ? (
    b_gc  = b / 0.60;
    mid   = (b_gc + this.xp_gc) * 0.5;
    Fb_gc = lms_F_tanh(b_gc) * 0.60;
    b     = lms_adaa_eval(b_gc, this.xp_gc, Fb_gc, this.Fp_gc, lms_tanh(mid)) * 0.60;
    this.xp_gc = b_gc; this.Fp_gc = Fb_gc;
  ) : (
    this.xp_gc = b / 0.60; this.Fp_gc = lms_F_tanh(b / 0.60) * 0.60;
  );

  b * 0.85;
);


// ============================================================================
//  SECTION 13: Marshall JCM800 Passive Tone Stack (stateful)
//
//  The JCM800 2203/2204 uses a passive Baxandall-derived tone stack between
//  the preamp and the recovery gain stage. Component values from the verified
//  JCM800 schematic (Trainwreck/Ceriatone cross-referenced):
//
//    Bass pot:   250kΩ (R6)
//    Mid pot:    25kΩ (R7)   ← note: much smaller than bass/treble
//    Treble pot: 1MΩ  (R8)
//    C1: 0.47µF  (bass cap)
//    C2: 22nF    (mid cap)
//    C3: 470pF   (treble cap)
//
//  Key behaviour:
//    - All controls are interactive (passive network — not independent)
//    - At "noon" (all 50%) there is ~18dB insertion loss (recovery gain compensates)
//    - Mid control is a CUT at 370Hz, not a boost — the "honk" comes from
//      turning mid DOWN (cuts the scoop) or from the treble/bass interaction
//    - Treble at full adds a shelf above ~1kHz AND rolls off some mid
//    - Bass at full boosts below ~200Hz AND slightly cuts mid
//
//  Implementation: analytical approximation using 3 interactive biquads.
//  True passive network would require a full 6th-order transfer function;
//  this model captures the interaction via cross-coupled gain coefficients.
//
//  Usage:
//    @init:   ts.lms_tonestack_jcm_init();
//    @slider/@block: ts.lms_tonestack_jcm_set(bass, mid, treble);
//                    // bass/mid/treble: 0..1 (pot position)
//    @sample: out = ts.lms_tonestack_jcm_proc(in);
// ============================================================================

function lms_tonestack_jcm_init()
(
  this.f_bass.lms_bq_init();
  this.f_mid.lms_bq_init();
  this.f_treb.lms_bq_init();
);

function lms_tonestack_jcm_set(bass, mid, treble)
  local(
    bass_db, mid_db, treb_db,
    bass_freq, mid_freq, treb_freq,
    mid_q, treb_q,
    bass_mid_xcouple, treb_mid_xcouple
  )
(
  // ---- Passive stack component values (JCM800 2203) ----
  // Bass: 250kΩ pot, 0.47µF cap → f = 1/(2π·R·C)
  // At pot max (250k): ~1.35Hz (full bass boost acts as sub-shelf)
  // Effective frequency at nominal settings: ~130Hz
  // We use the pot position to modulate both freq and gain
  bass_freq = 60 + bass * 140;    // 60Hz (scooped) to 200Hz (boosted)
  bass_db   = (bass - 0.5) * 18;  // ±9dB at extremes (passive stack range)

  // Mid: 25kΩ pot, 22nF cap → f ≈ 290Hz centre
  // The mid control is a CUT notch — mid=1.0 is LESS mid (more scooped)
  // mid=0.0 is MORE mid (less scooped). We invert so the knob feels right.
  mid_freq  = 370;               // fixed centre — passive RC sets this
  mid_q     = 1.0 + mid * 1.5;  // narrower Q at higher settings (pot loads the cap)
  mid_db    = (0.5 - mid) * 14; // mid=0→+7dB (full mid), mid=1→-7dB (scooped)

  // Treble: 1MΩ pot, 470pF cap → f ≈ 340Hz (but it's a shelf, not a peak)
  // Treble acts as high shelf pivoting around 1kHz
  treb_freq = 900 + treble * 600; // 900Hz to 1500Hz pivot
  treb_db   = (treble - 0.5) * 16; // ±8dB

  // Cross-coupling: turning bass up slightly cuts mid (passive interaction)
  bass_mid_xcouple = (bass - 0.5) * 3.0;
  // Turning treble up slightly lifts presence and cuts lower mid
  treb_mid_xcouple = (treble - 0.5) * 2.5;
  mid_db -= bass_mid_xcouple + treb_mid_xcouple;

  // Set the three interactive biquads
  this.f_bass.lms_bq_set_loshelf(bass_freq, bass_db, 0.6);
  this.f_mid.lms_bq_set_peak(mid_freq, mid_db, mid_q);
  this.f_treb.lms_bq_set_hishelf(treb_freq, treb_db, 0.75);
);

function lms_tonestack_jcm_proc(x)
  local(b)
(
  b = this.f_bass.lms_bq_proc_l(x);
  b = this.f_mid.lms_bq_proc_l(b);
  b = this.f_treb.lms_bq_proc_l(b);
  b;
);


// ============================================================================
//  SECTION 14: EL34 Push-Pull Power Amp (stateful)
//
//  Models the JCM800 power amp stage: two EL34 tubes in push-pull Class AB.
//
//  Push-pull topology:
//    - Odd harmonics dominate (2nd and 4th cancel in push-pull)
//    - Even harmonics very low at normal levels, rise with hard clipping
//    - Compression: power supply sag under heavy load (EL34 power amp sag
//      is subtler than rectifier-tube sag — more "giving" than "blooming")
//    - Presence control: modelled as variable high-frequency NFB
//      (real circuit: presence pot in series with cap to ground in NFB loop)
//      More presence = less HF NFB = more power amp gain + top-end openness
//
//  Usage:
//    @init:   pa.lms_el34_init();
//    @slider/@block: pa.lms_el34_set(drive, presence);
//                    // drive 0..1, presence 0..1
//    @sample: out = pa.lms_el34_proc(in);
// ============================================================================

function lms_el34_init()
(
  // Power supply sag envelope
  this.sag_env = 0;
  this.sag_att = exp(-1 / (srate * 0.015));
  this.sag_rel = exp(-1 / (srate * 0.250));
  this.sag_smooth = 0;
  this.sag_smooth_c = exp(-1 / (srate * 0.005));
  // Presence shelving filter
  this.pres_f.lms_bq_init();
  // Output DC block
  this.dc.lms_dc_init();
  // ADAA state: separate for push (1-exp×1.4) and pull (1-exp×1.35) tubes
  this.push_xp = 0; this.push_Fp = 0;
  this.pull_xp = 0; this.pull_Fp = 0;
);

function lms_el34_set(drive, presence)
  local(pres_freq, pres_db)
(
  this.drive = drive;
  pres_freq = 2000 + presence * 6000;
  pres_db   = presence * 8;
  this.pres_f.lms_bq_set_hishelf(pres_freq, pres_db, 0.9);
);

function lms_el34_proc(x)
  local(b, peak, sag_gain, push, pull, out, Fb, mid, f_mid)
(
  // Sag
  peak = abs(x);
  peak > this.sag_env ? (
    this.sag_env = this.sag_att * this.sag_env + (1 - this.sag_att) * peak;
  ) : (
    this.sag_env = this.sag_rel * this.sag_env;
  );
  sag_gain = 1.0 / (1.0 + this.sag_env * 0.35);
  this.sag_smooth = this.sag_smooth_c * this.sag_smooth + (1 - this.sag_smooth_c) * sag_gain;

  b = x * this.sag_smooth * (1.0 + this.drive * 2.5);

  push = b > 0 ? b : 0;
  pull = b < 0 ? -b : 0;

  // EL34 push tube — 1-exp×1.4 — ADAA
  // f(x) = 1 - exp(-1.4x)   F(x) = x + exp(-1.4x)/1.4
  push > 0 ? (
    Fb    = push + exp(-1.4 * push) / 1.4;
    mid   = (push + this.push_xp) * 0.5;
    f_mid = 1.0 - exp(-1.4 * mid);
    push  = lms_adaa_eval(push, this.push_xp, Fb, this.push_Fp, f_mid);
    this.push_xp = b > 0 ? b : 0; this.push_Fp = Fb;
  ) : (
    this.push_xp = 0; this.push_Fp = 1.0 / 1.4;  // F(0) = 0 + 1/1.4
  );

  // EL34 pull tube — 1-exp×1.35 — ADAA
  pull > 0 ? (
    Fb    = pull + exp(-1.35 * pull) / 1.35;
    mid   = (pull + this.pull_xp) * 0.5;
    f_mid = 1.0 - exp(-1.35 * mid);
    pull  = lms_adaa_eval(pull, this.pull_xp, Fb, this.pull_Fp, f_mid);
    this.pull_xp = b < 0 ? -b : 0; this.pull_Fp = Fb;
  ) : (
    this.pull_xp = 0; this.pull_Fp = 1.0 / 1.35;
  );

  out = push - pull;

  out = this.pres_f.lms_bq_proc_l(out);
  out = this.dc.lms_dc_proc_l(out);

  out * 0.85;
);


// ============================================================================
//  SECTION 15: Marshall 4×12 Cabinet — Celestion G12T-75 Model (stereo)
//
//  Five-band biquad model derived from measured frequency response of a
//  Marshall 1960A 4×12 loaded with Celestion G12T-75 speakers (65Hz tuning).
//
//  Bands (from measured cab IR / published Celestion data):
//
//    1. Cab resonance HP  — 80Hz Q=0.55 (ported cab tuning, -24dB/oct below 80)
//       Removes sub-bass that a real cab cannot reproduce
//
//    2. Cab resonance peak — 100Hz +3dB Q=1.8
//       The ported box resonance — that "thump" on low E palm mutes
//
//    3. Voice coil inductance notch — 1200Hz -4dB Q=0.9
//       Voice coil inductance causes a gentle dip in the 1-2kHz range
//       This is the characteristic "scoop" that makes a Celestion sound
//       different from a PA speaker
//
//    4. Cone breakup peak — 3500Hz +5dB Q=1.4
//       Celestion G12T-75 has a prominent cone resonance ~3-4kHz
//       This is the "edge" and "bite" — it's the Celestion sound
//
//    5. Air & baffle LP — 6500Hz Q=0.65 (2nd order rolloff above 6.5kHz)
//       High-frequency rolloff from cabinet baffle diffraction and
//       cone mass — real 12" speakers don't extend much past 6-7kHz
//
//  Usage:
//    @init:   cab.lms_cab_412_init();
//    @sample: l = cab.lms_cab_412_proc_l(l);
//             r = cab.lms_cab_412_proc_r(r);
//    (No set function needed — values are fixed from speaker physics)
// ============================================================================

function lms_cab_412_init()
(
  this.f1.lms_bq_init();  // cab resonance HP
  this.f2.lms_bq_init();  // cab resonance peak
  this.f3.lms_bq_init();  // voice coil notch
  this.f4.lms_bq_init();  // cone breakup peak
  this.f5.lms_bq_init();  // air LP

  // These are fixed — speaker physics don't change with settings
  this.f1.lms_bq_set_hp(80, 0.55);
  this.f2.lms_bq_set_peak(100, 3.0, 1.8);
  this.f3.lms_bq_set_peak(1200, -4.0, 0.9);
  this.f4.lms_bq_set_peak(3500, 5.0, 1.4);
  this.f5.lms_bq_set_lp(6500, 0.65);
);

function lms_cab_412_proc_l(x)
  local(b)
(
  b = this.f1.lms_bq_proc_l(x);
  b = this.f2.lms_bq_proc_l(b);
  b = this.f3.lms_bq_proc_l(b);
  b = this.f4.lms_bq_proc_l(b);
  b = this.f5.lms_bq_proc_l(b);
  b;
);

function lms_cab_412_proc_r(x)
  local(b)
(
  b = this.f1.lms_bq_proc_r(x);
  b = this.f2.lms_bq_proc_r(b);
  b = this.f3.lms_bq_proc_r(b);
  b = this.f4.lms_bq_proc_r(b);
  b = this.f5.lms_bq_proc_r(b);
  b;
);


// ============================================================================
//  SECTION 16: Mesa Triple Rectifier V2b Cold-Bias Stage (stateful)
//
//  The Mesa Triple Rectifier Modern channel's "wall of brown" comes primarily
//  from V2b — the third triode in the preamp chain (after V1a and V2a).
//  V2b runs with:
//    - Unbypassed cathode resistor (large value, ~2.7kΩ) — near-cutoff bias
//    - This "cold bias" means the tube spends much of its cycle in quasi-cutoff
//    - Result: extreme asymmetric clipping, ~49% 2nd harmonic content
//    - This is the opposite of V1B (which is unbypassed for NFB/linearising)
//    - V2b's cathode is unbypassed for *bias shift* — the cathode voltage rises
//      dramatically on signal, pulling the tube toward cutoff on positive peaks
//
//  The Modern channel chain: V1a (bypassed, high gain) → V2a (partial bypass,
//  bass limited) → V2b (cold bias, extreme 2nd) → tone stack → 6L6 power amp
//
//  V2b characteristics:
//    - Strong asymmetric clipping: positive peaks clip much earlier than negative
//    - Soft-cut on negative (quasi-cutoff: tube turns off rather than hard clips)
//    - 2nd harmonic dominant (~4× compared to 3rd at moderate levels)
//    - "Spongy" feel: cathode voltage follows signal, providing programme-dependent
//      gain reduction (separate from the power amp sag)
//
//  Usage:
//    @init:   v2b.lms_triode_v2b_init();
//    @sample: out = v2b.lms_triode_v2b_proc(in, drive);
//    drive: 0..1 — grid swing into the stage
// ============================================================================

function lms_triode_v2b_init()
(
  // Coupling cap HPF (22Hz — Mesa uses a large coupling cap, very low cutoff)
  this.hpx = 0; this.hpy = 0;
  this.hp_r = 1 - (2 * $pi * 22 / srate);
  // Cathode bias envelope
  this.bias_env = 0;
  this.bias_att = exp(-1 / (srate * 0.008));
  this.bias_rel = exp(-1 / (srate * 0.120));
  // ADAA state: negative quasi-cutoff tanh fold + grid current tanh
  this.xp_neg = 0; this.Fp_neg = 0;
  this.xp_gc  = 0; this.Fp_gc  = 0;
);

function lms_triode_v2b_proc(x, drive)
  local(gain, b, b_in, bias_shift, pos_thresh, ab, u, Fu, mid, f_mid, b_gc, Fb_gc)
(
  // Coupling cap
  this.hpy = x - this.hpx + this.hp_r * this.hpy;
  this.hpx = x;
  b = this.hpy;

  gain = 1.0 + drive * 4.5;
  b = b * gain;

  // Cathode bias envelope
  abs(b) > this.bias_env ? (
    this.bias_env = this.bias_att * this.bias_env + (1 - this.bias_att) * abs(b);
  ) : (
    this.bias_env = this.bias_rel * this.bias_env;
  );
  bias_shift = min(0.7, this.bias_env * 0.5);

  // Positive clipping — hard brickwall with dynamic threshold.
  // Hard clip is not a smooth function so ADAA isn't applicable here directly;
  // the threshold changes sample-to-sample (bias_shift), making it a
  // time-varying nonlinearity. We tame it instead with a tanh soft knee:
  pos_thresh = 0.65 - bias_shift * 0.30;
  b > pos_thresh * 0.85 ? (
    // Soft approach to the ceiling via tanh (avoids hard discontinuity)
    b = pos_thresh * lms_tanh(b / pos_thresh);
  );

  // Negative quasi-cutoff — tanh fold, ADAA applied
  // f(x) for |x|>0.2: -0.2 - tanh((|x|-0.2)*1.8)*0.45
  // Antiderivative (for x<-0.2): -0.2*x - log(cosh((|x|-0.2)*1.8))*0.45/1.8
  // We compute in terms of u = (-b - 0.2) for x < -0.2
  b < -0.2 ? (
    u     = (-b - 0.2);   // u > 0 when b < -0.2
    mid   = ((-b - 0.2) + this.xp_neg) * 0.5;  // midpoint of u
    Fu    = -0.2 * b - lms_F_tanh(u * 1.8) * 0.45 / 1.8;
    f_mid = -0.2 - lms_tanh(mid * 1.8) * 0.45;
    b     = lms_adaa_eval(u, this.xp_neg, Fu, this.Fp_neg, f_mid);
    this.xp_neg = u; this.Fp_neg = Fu;
  ) : (
    // Out of negative zone — reset ADAA state cleanly
    this.xp_neg = 0; this.Fp_neg = 0;
  );
  b_in = b;

  // Grid current — tanh soft knee, ADAA
  b > 0.3 ? (
    b_gc  = b / 0.50;
    mid   = (b_gc + this.xp_gc) * 0.5;
    Fb_gc = lms_F_tanh(b_gc) * 0.50;
    b     = lms_adaa_eval(b_gc, this.xp_gc, Fb_gc, this.Fp_gc, lms_tanh(mid)) * 0.50;
    this.xp_gc = b_gc; this.Fp_gc = Fb_gc;
  ) : (
    this.xp_gc = b / 0.50; this.Fp_gc = lms_F_tanh(b / 0.50) * 0.50;
  );

  b * 0.88;
);


// ============================================================================
//  SECTION 17: 6L6 Push-Pull Power Amp (stateful)
//
//  The Mesa Triple Rectifier uses a quad of 6L6GC tubes in push-pull Class AB.
//  Compared to the EL34 (Section 14):
//    - Higher plate voltage tolerance → more headroom before clip
//    - Brighter character (different transfer curve, less 3rd harmonic domination)
//    - Sag is MORE prominent with the tube rectifier option (the "Vintage" setting)
//    - With silicon rectifier: tight and fast, very little sag
//    - Modern channel presence is NOT an NFB shelf but an RC treble filter
//      in the feedback loop — modelled here as a resonant presence peak
//      rather than a shelf (Mesa "Presence" sounds different from Marshall "Presence")
//
//  Usage:
//    @init:   pa.lms_6l6_init();
//    @slider/@block: pa.lms_6l6_set(drive, presence, sob_rect);
//                    // drive 0..1, presence 0..1, sob_rect 0=Si/1=Tube
//    @sample: out = pa.lms_6l6_proc(in);
// ============================================================================

function lms_6l6_init()
(
  // Power supply sag envelope
  this.sag_env = 0;
  this.sag_att = exp(-1 / (srate * 0.012));
  this.sag_rel = exp(-1 / (srate * 0.200));
  this.sag_smooth = 0;
  this.sag_smooth_c = exp(-1 / (srate * 0.005));
  // Presence peak filter
  this.pres_f.lms_bq_init();
  // DC block
  this.dc.lms_dc_init();
  this.sag_depth = 0.20;
  // ADAA state: atan-based push and pull tubes
  this.push_xp = 0; this.push_Fp = 0;
  this.pull_xp = 0; this.pull_Fp = 0;
);

function lms_6l6_set(drive, presence, sob_rect)
  local(pres_freq, pres_db, pres_q)
(
  this.drive = drive;
  this.sag_depth = sob_rect == 1 ? 0.35 : 0.12;
  pres_freq = 3000 + presence * 4000;
  pres_db   = presence * 10;
  pres_q    = 1.5 + presence * 1.5;
  this.pres_f.lms_bq_set_peak(pres_freq, pres_db, pres_q);
);

function lms_6l6_proc(x)
  local(b, peak, sag_gain, push, pull, out, Fb, mid, f_mid)
(
  // Sag
  peak = abs(x);
  peak > this.sag_env ? (
    this.sag_env = this.sag_att * this.sag_env + (1 - this.sag_att) * peak;
  ) : (
    this.sag_env = this.sag_rel * this.sag_env;
  );
  sag_gain = 1.0 / (1.0 + this.sag_env * this.sag_depth);
  this.sag_smooth = this.sag_smooth_c * this.sag_smooth + (1 - this.sag_smooth_c) * sag_gain;

  b = x * this.sag_smooth * (1.0 + this.drive * 2.0);

  push = b > 0 ? b : 0;
  pull = b < 0 ? -b : 0;

  // 6L6 push tube — atan×1.6 — ADAA
  // f(x) = (2/π)·atan(1.6x)   F(x) = lms_F_atan(1.6x)/1.6
  push > 0 ? (
    Fb    = lms_F_atan(push * 1.6) / 1.6;
    mid   = (push + this.push_xp) * 0.5;
    f_mid = (2 / $pi) * atan(mid * 1.6);
    push  = lms_adaa_eval(push, this.push_xp, Fb, this.push_Fp, f_mid);
    this.push_xp = b > 0 ? b : 0; this.push_Fp = Fb;
  ) : (
    this.push_xp = 0; this.push_Fp = 0;
  );

  // 6L6 pull tube — atan×1.58 — ADAA (slight mismatch)
  pull > 0 ? (
    Fb    = lms_F_atan(pull * 1.58) / 1.58;
    mid   = (pull + this.pull_xp) * 0.5;
    f_mid = (2 / $pi) * atan(mid * 1.58);
    pull  = lms_adaa_eval(pull, this.pull_xp, Fb, this.pull_Fp, f_mid);
    this.pull_xp = b < 0 ? -b : 0; this.pull_Fp = Fb;
  ) : (
    this.pull_xp = 0; this.pull_Fp = 0;
  );

  out = push - pull;

  out = this.pres_f.lms_bq_proc_l(out);
  out = this.dc.lms_dc_proc_l(out);

  out * 0.85;
);


// ============================================================================
//  SECTION 18: Mesa 4×12 Cabinet — Celestion V30 Model (stereo)
//
//  Five-band biquad model of a Mesa Boogie 4×12 loaded with Celestion V30
//  speakers. The V30 sounds noticeably different from the G12T-75 (Section 15):
//
//    G12T-75 (Marshall):  cone breakup ~3.5kHz, darker, boxier, more midrange
//    V30 (Mesa):          cone breakup ~4kHz, tighter bass, more upper presence
//                         pronounced "singing" mid-upper range, iconic metal sound
//
//  Bands (from Celestion published data + measured IR analysis):
//
//    1. Cab resonance HP  — 90Hz Q=0.60 (Mesa cab is tighter/smaller than 1960A)
//       Slightly higher than Marshall (90 vs 80Hz) — Mesa cabs are more sealed
//
//    2. Cab resonance peak — 110Hz +2dB Q=2.0
//       Mesa cab resonance sits slightly higher and is narrower than Marshall
//       Less "thump", more defined low end
//
//    3. Voice coil notch — 800Hz -3dB Q=0.7
//       V30 voice coil dip is in the upper-mid range (800Hz vs G12T-75 at 1200Hz)
//       This gives the V30 its characteristic "hollowed" 800Hz response
//
//    4. Cone breakup peak — 4000Hz +6dB Q=1.6
//       V30 cone resonance is higher and more prominent than G12T-75
//       This is THE V30 sound — that upper presence "singing" characteristic
//
//    5. Air LP — 7000Hz Q=0.70 (V30 extends slightly higher than G12T-75)
//
//  Usage:
//    @init:   cab.lms_cab_mesa_412_init();
//    @sample: l = cab.lms_cab_mesa_412_proc_l(l);
//             r = cab.lms_cab_mesa_412_proc_r(r);
// ============================================================================

function lms_cab_mesa_412_init()
(
  this.f1.lms_bq_init();  // cab resonance HP
  this.f2.lms_bq_init();  // cab resonance peak
  this.f3.lms_bq_init();  // voice coil notch
  this.f4.lms_bq_init();  // cone breakup peak
  this.f5.lms_bq_init();  // air LP

  this.f1.lms_bq_set_hp(90, 0.60);
  this.f2.lms_bq_set_peak(110, 2.0, 2.0);
  this.f3.lms_bq_set_peak(800, -3.0, 0.7);
  this.f4.lms_bq_set_peak(4000, 6.0, 1.6);
  this.f5.lms_bq_set_lp(7000, 0.70);
);

function lms_cab_mesa_412_proc_l(x)
  local(b)
(
  b = this.f1.lms_bq_proc_l(x);
  b = this.f2.lms_bq_proc_l(b);
  b = this.f3.lms_bq_proc_l(b);
  b = this.f4.lms_bq_proc_l(b);
  b = this.f5.lms_bq_proc_l(b);
  b;
);

function lms_cab_mesa_412_proc_r(x)
  local(b)
(
  b = this.f1.lms_bq_proc_r(x);
  b = this.f2.lms_bq_proc_r(b);
  b = this.f3.lms_bq_proc_r(b);
  b = this.f4.lms_bq_proc_r(b);
  b = this.f5.lms_bq_proc_r(b);
  b;
);


// ============================================================================
//  SECTION 19: Mesa Triple Rectifier Tone Stack (stateful)
//
//  The Mesa Boogie Triple Rectifier Modern channel uses a different tone stack
//  topology from the Marshall (Section 13):
//
//    Marshall (JCM800): Baxandall-derived, Bass/Mid/Treble all interactive,
//                       mid is a CUT at 370Hz. Very interactive controls.
//
//    Mesa Modern:       More independent controls, different component values.
//                       Bass: larger pot (500kΩ), deeper shelf (~60Hz)
//                       Mid:  25kΩ pot at 750Hz (higher than Marshall's 370Hz)
//                       Treble: shelf at ~1.5kHz
//                       The "scoop" character comes from the mid control acting
//                       as a boost/cut at 750Hz — unlike Marshall where it's
//                       primarily a cut network.
//
//  The Mesa stack is placed AFTER the preamp stages and BEFORE the power amp,
//  like the Marshall, but the insertion loss is less severe (~12dB vs ~18dB).
//
//  Usage:
//    @init:   ts.lms_tonestack_mesa_init();
//    @slider/@block: ts.lms_tonestack_mesa_set(bass, mid, treble);
//                    // bass/mid/treble: 0..1 (pot position)
//    @sample: out = ts.lms_tonestack_mesa_proc(in);
// ============================================================================

function lms_tonestack_mesa_init()
(
  this.f_bass.lms_bq_init();
  this.f_mid.lms_bq_init();
  this.f_treb.lms_bq_init();
);

function lms_tonestack_mesa_set(bass, mid, treble)
  local(
    bass_db, mid_db, treb_db,
    bass_freq, mid_freq, treb_freq,
    mid_q
  )
(
  // Bass: 500kΩ pot, larger cap → deeper shelf around 60Hz
  // More independent from mid than Marshall (lower crossover point)
  bass_freq = 50 + bass * 80;      // 50Hz to 130Hz
  bass_db   = (bass - 0.5) * 16;   // ±8dB

  // Mid: 25kΩ pot, 22nF → ~750Hz centre (higher than Marshall's 370Hz)
  // Mesa mid is more of a boost/cut than a pure cut network
  // mid=0.5 is flat, mid=0 scoops, mid=1 gives the "shout"
  mid_freq  = 750;
  mid_q     = 0.8 + mid * 1.2;    // Q broadens at higher settings
  mid_db    = (mid - 0.5) * 16;   // ±8dB (symmetric, unlike Marshall)

  // Treble: shelf at ~1.5kHz — acts a bit like presence on Mesa
  treb_freq = 1200 + treble * 800; // 1200Hz to 2000Hz
  treb_db   = (treble - 0.5) * 14; // ±7dB

  // Mesa controls are more independent — less cross-coupling than Marshall
  // But bass at extremes still affects perceived mid
  bass_db -= (bass - 0.5) * 1.5;  // minimal cross-couple

  this.f_bass.lms_bq_set_loshelf(bass_freq, bass_db, 0.55);
  this.f_mid.lms_bq_set_peak(mid_freq, mid_db, mid_q);
  this.f_treb.lms_bq_set_hishelf(treb_freq, treb_db, 0.70);
);

function lms_tonestack_mesa_proc(x)
  local(b)
(
  b = this.f_bass.lms_bq_proc_l(x);
  b = this.f_mid.lms_bq_proc_l(b);
  b = this.f_treb.lms_bq_proc_l(b);
  b;
);
