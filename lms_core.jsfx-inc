// ============================================================================
//  LMS Core DSP Library v1.0
//  Shared DSP building blocks for the LMS plugin suite
//
//  Usage: import lms_core.jsfx-inc
//
//  IMPORTANT: All functions must be inside @init so they are available
//  across all sections (@slider, @block, @sample, @gfx) in importing files.
//  JSFX rule: "functions defined in @init can be used from other sections,
//  whereas functions defined in other sections are local to those sections."
//
//  All functions use lms_ prefix. Stateful functions use this.* pattern —
//  call as instance.lms_xxx() to get independent state per instance.
//
//  Sections:
//    1. Math Utilities           (stateless)
//    2. Biquad Filter            (stereo + mono, this.* state)
//    3. Saturation Suite         (density-aware triode architecture, this.* state)
//    4. Compressor               (stereo FET, this.* state)
//    5. DC Blocker               (stereo, this.* state)
//    6. Tone Filter              (stereo 1-pole LP, this.* state)
//    7. Cubic Interpolation      (stateless)
//    8. Spring Reverb Allpass    (stateless, buffer-based)
// ============================================================================

@init

// ============================================================================
//  SECTION 1: Math Utilities (stateless)
// ============================================================================

// Bounded exp-based tanh approximation (JSFX has no built-in tanh)
function lms_tanh(x)
  local(e2x)
(
  x > 10 ? 1 : x < -10 ? -1 : (
    e2x = exp(2 * x);
    (e2x - 1) / (e2x + 1);
  );
);

// dB to linear gain
function lms_db2lin(db)
(
  10 ^ (db / 20);
);

// Linear gain to dB (safe — returns -140 for silence)
function lms_lin2db(lin)
(
  lin > 0.0000001 ? 20 * log10(lin) : -140;
);


// ADAA core (used by lms_sat_harmonics for polynomial anti-aliasing): given x_now, x_prev, F(x_now), F(x_prev), f(midpoint) fallback
// Returns the alias-suppressed output sample.
//
// Uses a crossfade zone instead of a hard epsilon switch. A single threshold
// creates a "no man's land" where dx is small enough for the division to amplify
// floating-point noise but not small enough to trigger fallback — this manifests
// as hiss on note decay tails. The crossfade blends smoothly between ADAA and
// fallback, eliminating both the hard-switch artifact and the noisy-division zone.
function lms_adaa_eval(x_now, x_prev, Fx_now, Fx_prev, f_mid)
  local(dx, adx, adaa_out, blend)
(
  dx  = x_now - x_prev;
  adx = abs(dx);
  adx < 0.00001 ? (
    f_mid;
  ) : adx > 0.0001 ? (
    (Fx_now - Fx_prev) / dx;
  ) : (
    adaa_out = (Fx_now - Fx_prev) / dx;
    blend = (adx - 0.00001) / (0.00009);  // 0..1 across the transition band
    f_mid + blend * (adaa_out - f_mid);
  );
);


// ============================================================================
//  SECTION 2: Biquad Filter (stereo, this.* state)
//
//  One instance = one stereo band.
//  Coefficients shared, L/R state separate.
//
//  Usage:
//    @init:   hp.lms_bq_init();
//    @slider: hp.lms_bq_set_hp(freq, 0.707);
//    @block:  hp.lms_bq_set_hp(freq, 0.707);
//    @sample: l = hp.lms_bq_proc_l(l);
//             r = hp.lms_bq_proc_r(r);
// ============================================================================

// Initialize biquad — zero state and set to passthrough
function lms_bq_init()
(
  // Coefficients (passthrough)
  this.b0 = 1; this.b1 = 0; this.b2 = 0;
  this.a1 = 0; this.a2 = 0;
  // Left channel state
  this.lx1 = 0; this.lx2 = 0;
  this.ly1 = 0; this.ly2 = 0;
  // Right channel state
  this.rx1 = 0; this.rx2 = 0;
  this.ry1 = 0; this.ry2 = 0;
);

// Highpass (2nd order Butterworth when q = 0.707)
function lms_bq_set_hp(freq, q)
  local(w0, cs, sn, alpha, a0_inv)
(
  w0 = 2 * $pi * freq / srate;
  cs = cos(w0); sn = sin(w0);
  alpha = sn / (2 * q);
  a0_inv = 1 / (1 + alpha);
  this.b0 = (1 + cs) / 2 * a0_inv;
  this.b1 = -(1 + cs) * a0_inv;
  this.b2 = (1 + cs) / 2 * a0_inv;
  this.a1 = -2 * cs * a0_inv;
  this.a2 = (1 - alpha) * a0_inv;
);

// Lowpass
function lms_bq_set_lp(freq, q)
  local(w0, cs, sn, alpha, a0_inv)
(
  w0 = 2 * $pi * freq / srate;
  cs = cos(w0); sn = sin(w0);
  alpha = sn / (2 * q);
  a0_inv = 1 / (1 + alpha);
  this.b0 = (1 - cs) / 2 * a0_inv;
  this.b1 = (1 - cs) * a0_inv;
  this.b2 = (1 - cs) / 2 * a0_inv;
  this.a1 = -2 * cs * a0_inv;
  this.a2 = (1 - alpha) * a0_inv;
);

// Bandpass (constant skirt gain)
function lms_bq_set_bp(freq, q)
  local(w0, cs, sn, alpha, a0_inv)
(
  w0 = 2 * $pi * freq / srate;
  cs = cos(w0); sn = sin(w0);
  alpha = sn / (2 * q);
  a0_inv = 1 / (1 + alpha);
  this.b0 = (sn / 2) * a0_inv;
  this.b1 = 0;
  this.b2 = -(sn / 2) * a0_inv;
  this.a1 = -2 * cs * a0_inv;
  this.a2 = (1 - alpha) * a0_inv;
);

// Parametric peaking EQ
function lms_bq_set_peak(freq, gain_db, q)
  local(a, w0, alpha, a0_inv)
(
  a = 10 ^ (gain_db / 20);
  w0 = 2 * $pi * freq / srate;
  alpha = sin(w0) / (2 * q);
  a0_inv = 1 / (1 + alpha / a);
  this.b0 = (1 + alpha * a) * a0_inv;
  this.b1 = (-2 * cos(w0)) * a0_inv;
  this.b2 = (1 - alpha * a) * a0_inv;
  this.a1 = this.b1;
  this.a2 = (1 - alpha / a) * a0_inv;
);

// Low shelf
function lms_bq_set_loshelf(freq, gain_db, q)
  local(a, w0, cs, sn, alpha, ap1, am1, beta, a0_inv)
(
  a = 10 ^ (gain_db / 40);
  w0 = 2 * $pi * freq / srate;
  cs = cos(w0); sn = sin(w0);
  alpha = sn / (2 * q);
  ap1 = a + 1; am1 = a - 1;
  beta = 2 * sqrt(a) * alpha;
  a0_inv = 1 / (ap1 + am1 * cs + beta);
  this.b0 = a * (ap1 - am1 * cs + beta) * a0_inv;
  this.b1 = 2 * a * (am1 - ap1 * cs) * a0_inv;
  this.b2 = a * (ap1 - am1 * cs - beta) * a0_inv;
  this.a1 = -2 * (am1 + ap1 * cs) * a0_inv;
  this.a2 = (ap1 + am1 * cs - beta) * a0_inv;
);

// High shelf
function lms_bq_set_hishelf(freq, gain_db, q)
  local(a, w0, cs, sn, alpha, ap1, am1, beta, a0_inv)
(
  a = 10 ^ (gain_db / 40);
  w0 = 2 * $pi * freq / srate;
  cs = cos(w0); sn = sin(w0);
  alpha = sn / (2 * q);
  ap1 = a + 1; am1 = a - 1;
  beta = 2 * sqrt(a) * alpha;
  a0_inv = 1 / (ap1 - am1 * cs + beta);
  this.b0 = a * (ap1 + am1 * cs + beta) * a0_inv;
  this.b1 = -2 * a * (am1 + ap1 * cs) * a0_inv;
  this.b2 = a * (ap1 + am1 * cs - beta) * a0_inv;
  this.a1 = 2 * (am1 - ap1 * cs) * a0_inv;
  this.a2 = (ap1 - am1 * cs - beta) * a0_inv;
);

// Process left channel sample through biquad
function lms_bq_proc_l(x)
  local(o)
(
  o = this.b0 * x + this.b1 * this.lx1 + this.b2 * this.lx2
                   - this.a1 * this.ly1 - this.a2 * this.ly2;
  this.lx2 = this.lx1; this.lx1 = x;
  this.ly2 = this.ly1; this.ly1 = o;
  o;
);

// Process right channel sample through biquad
function lms_bq_proc_r(x)
  local(o)
(
  o = this.b0 * x + this.b1 * this.rx1 + this.b2 * this.rx2
                   - this.a1 * this.ry1 - this.a2 * this.ry2;
  this.rx2 = this.rx1; this.rx1 = x;
  this.ry2 = this.ry1; this.ry1 = o;
  o;
);

// Process mono sample through biquad (uses lx/ly state — do NOT mix with proc_l)
function lms_bq_proc(x)
  local(o)
(
  o = this.b0 * x + this.b1 * this.lx1 + this.b2 * this.lx2
                   - this.a1 * this.ly1 - this.a2 * this.ly2;
  this.lx2 = this.lx1; this.lx1 = x;
  this.ly2 = this.ly1; this.ly1 = o;
  o;
);


// ============================================================================
//  SECTION 3: Saturation Suite (density-aware triode architecture)
//
//  All functions use this.* state for density tracking, bias shift,
//  grid conduction, Miller LP, air shelf, and DC blocking.
//  Call <instance>.lms_sat_XXX_init() once in @init, then
//  call <instance>.lms_sat_XXX(x, drive, bias) per sample.
//
//  Each mode models a different tube/device character by varying the
//  clipping curve shape (pos_hard, neg_hard, pos_ceil, neg_ceil).
//  The density-aware architecture (4-band tracker, bias shift, grid
//  conduction, Miller LP, air shelf) is shared across all modes —
//  identical to the v2 amp sim triode stages.
//
//  Usage:
//    @init:   sat.lms_sat_warm_init();
//    @sample: l = sat.lms_sat_warm(l, drive, bias);
// ============================================================================

// ---- Shared density-aware saturation init ----
function lms_sat_da_init() (
  // Coupling cap bias shift
  this.cap_charge = 0.0;
  this.cap_charge_rate = exp(-1/(srate * 0.0005));
  this.cap_drain_rate = exp(-1/(srate * 0.030));
  // 4-band density tracker
  this.hd_f_lo.lms_bq_init(); this.hd_f_lo.lms_bq_set_lp(250, 0.7);
  this.hd_f_mid_lo.lms_bq_init(); this.hd_f_mid_lo.lms_bq_set_lp(2000, 0.7);
  this.hd_f_mid_hi.lms_bq_init(); this.hd_f_mid_hi.lms_bq_set_hp(250, 0.7);
  this.hd_f_hi.lms_bq_init(); this.hd_f_hi.lms_bq_set_hp(2000, 0.7);
  this.hd_f_air.lms_bq_init(); this.hd_f_air.lms_bq_set_hp(5000, 0.7);
  this.hd_env_lo = 0; this.hd_env_mid = 0; this.hd_env_hi = 0;
  this.hd_env_air = 0; this.hd_env_total = 0;
  this.hd_att = exp(-1/(srate * 0.002));
  this.hd_rel = exp(-1/(srate * 0.080));
  this.hd_density = 1.0; this.hd_mid_density = 0.0;
  this.hd_hi_density = 0.0; this.hd_air_density = 0.0;
  this.hd_smooth = exp(-1/(srate * 0.030));
  // Miller LP (density-driven cutoff)
  this.miller.lms_bq_init();
  this.miller.lms_bq_set_lp(8000, 0.6);
  this.miller_base_freq = 8000;
  this.last_miller_freq = 8000;
  this.last_miller_q = 0.6;
  // Air shelf (density-driven HF control)
  this.air_shelf.lms_bq_init();
  this.air_shelf.lms_bq_set_hishelf(5000, 0.0, 0.7);
  this.last_air_cut = 0.0;
  // Grid conduction peak envelope
  this.peak_env = 0;
  this.peak_att = exp(-1/(srate * 0.0002));
  this.peak_rel = exp(-1/(srate * 0.050));
  // DC blocker
  this.dc_xp = 0; this.dc_yp = 0; this.dc_r = 1 - (20 / srate);
);

// ---- Shared density tracker (inline, uses this.hd_* state) ----
function lms_sat_da_hd_proc(x)
  local(lo, mid, hi, air, abs_lo, abs_mid, abs_hi, abs_air, abs_total,
        raw, raw_mid, raw_hi, raw_air)
(
  lo = this.hd_f_lo.lms_bq_proc(x);
  mid = this.hd_f_mid_hi.lms_bq_proc(this.hd_f_mid_lo.lms_bq_proc(x));
  hi = this.hd_f_hi.lms_bq_proc(x);
  air = this.hd_f_air.lms_bq_proc(x);
  abs_lo = abs(lo); abs_mid = abs(mid); abs_hi = abs(hi);
  abs_air = abs(air); abs_total = abs(x);
  abs_lo > this.hd_env_lo ? (
    this.hd_env_lo = this.hd_att * this.hd_env_lo + (1 - this.hd_att) * abs_lo;
  ) : (
    this.hd_env_lo = this.hd_rel * this.hd_env_lo + (1 - this.hd_rel) * abs_lo;
  );
  abs_mid > this.hd_env_mid ? (
    this.hd_env_mid = this.hd_att * this.hd_env_mid + (1 - this.hd_att) * abs_mid;
  ) : (
    this.hd_env_mid = this.hd_rel * this.hd_env_mid + (1 - this.hd_rel) * abs_mid;
  );
  abs_hi > this.hd_env_hi ? (
    this.hd_env_hi = this.hd_att * this.hd_env_hi + (1 - this.hd_att) * abs_hi;
  ) : (
    this.hd_env_hi = this.hd_rel * this.hd_env_hi + (1 - this.hd_rel) * abs_hi;
  );
  abs_air > this.hd_env_air ? (
    this.hd_env_air = this.hd_att * this.hd_env_air + (1 - this.hd_att) * abs_air;
  ) : (
    this.hd_env_air = this.hd_rel * this.hd_env_air + (1 - this.hd_rel) * abs_air;
  );
  abs_total > this.hd_env_total ? (
    this.hd_env_total = this.hd_att * this.hd_env_total + (1 - this.hd_att) * abs_total;
  ) : (
    this.hd_env_total = this.hd_rel * this.hd_env_total + (1 - this.hd_rel) * abs_total;
  );
  this.hd_env_lo > 0.0001 ? (
    raw = this.hd_env_total / this.hd_env_lo;
    raw = min(2.5, max(1.0, raw));
  ) : ( raw = 1.0; );
  this.hd_env_total > 0.0001 ? (
    raw_mid = this.hd_env_mid / this.hd_env_total;
    raw_mid = min(1.0, max(0.0, raw_mid));
    raw_hi = this.hd_env_hi / this.hd_env_total;
    raw_hi = min(1.0, max(0.0, raw_hi));
    raw_air = this.hd_env_air / this.hd_env_total;
    raw_air = min(1.0, max(0.0, raw_air));
  ) : ( raw_mid = 0.0; raw_hi = 0.0; raw_air = 0.0; );
  this.hd_density = this.hd_smooth * this.hd_density + (1 - this.hd_smooth) * raw;
  this.hd_mid_density = this.hd_smooth * this.hd_mid_density + (1 - this.hd_smooth) * raw_mid;
  this.hd_hi_density = this.hd_smooth * this.hd_hi_density + (1 - this.hd_smooth) * raw_hi;
  this.hd_air_density = this.hd_smooth * this.hd_air_density + (1 - this.hd_smooth) * raw_air;
);

// ---- Shared density-aware saturation core ----
// pos_hard/neg_hard: clipping hardness (higher = harder clip)
// pos_ceil/neg_ceil: clipping ceiling (output bounded to these)
// gc_thresh/gc_amount: grid conduction threshold and squash amount
function lms_sat_da_proc(x, drive, bias, pos_hard, neg_hard, pos_ceil, neg_ceil, gc_thresh, gc_amount)
  local(b, gain, bias_shift, p_ceil, n_ceil, gc_out, lp_freq, lp_q,
        air_cut, drive_boost, ax)
(
  // 1. Coupling cap bias shift
  b = x + bias * 0.1;
  b > 0.1 ? (
    this.cap_charge = this.cap_charge_rate * this.cap_charge
                    + (1 - this.cap_charge_rate) * b * 0.12;
  ) : (
    this.cap_charge = this.cap_drain_rate * this.cap_charge;
  );
  bias_shift = this.cap_charge;
  b = b - bias_shift;

  // 2. Density-driven drive boost (mid density pushes tube harder)
  drive_boost = 1.0 + this.hd_mid_density * 0.4;
  gain = (1.0 + drive * 4.0) * drive_boost;
  b = b * gain;

  // 3. Run density tracker on pre-clip signal
  this.lms_sat_da_hd_proc(b);

  // 4. Fixed clipping curves — ceiling is constant (no PSU in standalone sat)
  p_ceil = pos_ceil;
  n_ceil = neg_ceil;
  b >= 0 ? (
    b = lms_tanh(b * pos_hard) * p_ceil;
  ) : (
    b = lms_tanh(b * neg_hard) * n_ceil;
  );

  // 5. Grid conduction (peak envelope gated soft clamp)
  ax = abs(b);
  ax > this.peak_env ? (
    this.peak_env = this.peak_att * this.peak_env + (1 - this.peak_att) * ax;
  ) : (
    this.peak_env = this.peak_rel * this.peak_env + (1 - this.peak_rel) * ax;
  );
  b > gc_thresh && this.peak_env > gc_thresh * 0.8 ? (
    gc_out = gc_thresh + lms_tanh((b - gc_thresh) * 3.0) * gc_amount;
    b = gc_out;
  );

  // 6. Miller LP — density drives cutoff (AFTER clipping, on output)
  lp_freq = this.miller_base_freq - (this.hd_density - 1.0) * 500;
  lp_freq = max(this.miller_base_freq - 1500, min(this.miller_base_freq + 500, lp_freq));
  lp_q = 0.6 + this.hd_hi_density * 0.35;
  lp_q = max(0.6, min(0.95, lp_q));
  abs(lp_freq - this.last_miller_freq) > 30 || abs(lp_q - this.last_miller_q) > 0.02 ? (
    this.miller.lms_bq_set_lp(lp_freq, lp_q);
    this.last_miller_freq = lp_freq;
    this.last_miller_q = lp_q;
  );
  b = this.miller.lms_bq_proc(b);

  // 7. Air shelf — density-driven HF control
  air_cut = -this.hd_air_density * 3.0;
  air_cut = max(-3.0, min(0.0, air_cut));
  abs(air_cut - this.last_air_cut) > 0.1 ? (
    this.air_shelf.lms_bq_set_hishelf(5000, air_cut, 0.7);
    this.last_air_cut = air_cut;
  );
  b = this.air_shelf.lms_bq_proc(b);

  // 8. DC block
  this.dc_yp = b - this.dc_xp + this.dc_r * this.dc_yp;
  this.dc_xp = b;
  b = this.dc_yp;

  b;
);


// ---- lms_sat_warm — warm tube (soft symmetric, high ceiling, gentle) ----

function lms_sat_warm_init() ( this.lms_sat_da_init(); );

function lms_sat_warm(x, drive, bias) (
  // Warm tube: soft positive, slightly softer negative, high ceiling
  // pos_hard=1.2, neg_hard=0.9, pos_ceil=0.85, neg_ceil=1.0, gc_thresh=0.30, gc_amount=0.15
  this.lms_sat_da_proc(x, drive, bias, 1.2, 0.9, 0.85, 1.0, 0.30, 0.15);
);


// ---- lms_sat_hot — hot tube (pushed 12AX7, harder asymmetric) ----

function lms_sat_hot_init() ( this.lms_sat_da_init(); );

function lms_sat_hot(x, drive, bias) (
  // Hot tube: hard positive, moderate negative, tighter ceiling
  // pos_hard=1.8, neg_hard=1.4, pos_ceil=0.75, neg_ceil=0.95, gc_thresh=0.25, gc_amount=0.18
  this.lms_sat_da_proc(x, drive * 2, bias, 1.8, 1.4, 0.75, 0.95, 0.25, 0.18);
);


// ---- lms_sat_tape — tape saturation (symmetric, soft compression) ----

function lms_sat_tape_init() ( this.lms_sat_da_init(); );

function lms_sat_tape(x, drive, bias) (
  // Tape: symmetric soft compression, wide ceiling, gentle grid conduction
  // pos_hard=0.8, neg_hard=0.8, pos_ceil=0.95, neg_ceil=0.95, gc_thresh=0.35, gc_amount=0.12
  this.lms_sat_da_proc(x, drive * 1.5, bias, 0.8, 0.8, 0.95, 0.95, 0.35, 0.12);
);


// ---- lms_sat_rect — rectifier (hard positive, soft negative fold) ----

function lms_sat_rect_init() ( this.lms_sat_da_init(); );

function lms_sat_rect(x, drive, bias) (
  // Rectifier: very hard positive clip, soft negative (half-wave character)
  // pos_hard=2.0, neg_hard=0.5, pos_ceil=0.70, neg_ceil=0.40, gc_thresh=0.20, gc_amount=0.20
  this.lms_sat_da_proc(x, drive * 3, bias, 2.0, 0.5, 0.70, 0.40, 0.20, 0.20);
);


// ---- lms_sat_fuzz — fuzz (aggressive both sides, low ceiling, gated) ----

function lms_sat_fuzz_init() ( this.lms_sat_da_init(); );

function lms_sat_fuzz(x, drive, bias) (
  // Fuzz: very hard both sides, low ceiling, aggressive grid conduction
  // pos_hard=2.5, neg_hard=2.0, pos_ceil=0.60, neg_ceil=0.55, gc_thresh=0.15, gc_amount=0.25
  this.lms_sat_da_proc(x, drive * 4, bias, 2.5, 2.0, 0.60, 0.55, 0.15, 0.25);
);


// ---- lms_sat_harmonics — polynomial harmonic blend (no hard clip, minimal aliasing) ----
// Polynomial distortion aliases less severely than hard clippers, but x³ still aliases.
// We use ADAA on the x³ term (F(x³) = x⁴/4) and exact for x|x| (F = x²|x|/3).
// This is kept stateless-style since it's additive blend, not a full clipper.

function lms_sat_harmonics_init()
(
  this.xp = 0;
  this.F2p = 0;
  this.F3p = 0;
);

function lms_sat_harmonics(x, even_mix, odd_mix)
  local(x2_now, x3_now, F2_now, F3_now, x2_aa, x3_aa, result, mid)
(
  mid = (x + this.xp) * 0.5;

  // Even: f(x) = x*|x|  (2nd harmonic, signed square)  F(x) = x²|x|/3
  F2_now = x * x * abs(x) / 3;
  x2_aa  = lms_adaa_eval(x, this.xp, F2_now, this.F2p, mid * abs(mid));

  // Odd: f(x) = x³   F(x) = x⁴/4
  F3_now = x * x * x * x / 4;
  x3_aa  = lms_adaa_eval(x, this.xp, F3_now, this.F3p, mid * mid * mid);

  result = x + even_mix * x2_aa * 0.3 + odd_mix * x3_aa * 0.2;

  this.xp   = x;
  this.F2p  = F2_now;
  this.F3p  = F3_now;
  result;
);


// ============================================================================
//  SECTION 4: Compressor — FET-style (stereo, this.* state)
//
//  Stereo-linked peak detection with envelope follower.
//
//  Usage:
//    @init:   comp.lms_comp_init();
//    @slider: comp.lms_comp_set(thresh_db, ratio, att_ms, rel_ms);
//    @block:  comp.lms_comp_set(thresh_db, ratio, att_ms, rel_ms);
//    @sample: comp.lms_comp_proc(l, r);
//             l *= comp.gr;
//             r *= comp.gr;
//             // comp.gr_db has dB of gain reduction
// ============================================================================

// Initialize compressor state
function lms_comp_init()
(
  this.env = 0;
  this.gr = 1;
  this.gr_db = 0;
  this.thresh = 0;
  this.ratio = 4;
  this.att = 0;
  this.rel = 0;
);

// Set compressor parameters
function lms_comp_set(thresh_db, ratio, att_ms, rel_ms)
(
  this.thresh = thresh_db;
  this.ratio = ratio;
  this.att = exp(-1 / (att_ms * 0.001 * srate));
  this.rel = exp(-1 / (rel_ms * 0.001 * srate));
);

// Process stereo pair — updates this.gr (linear) and this.gr_db
function lms_comp_proc(l, r)
  local(det, det_db, over, target_gr)
(
  det = max(abs(l), abs(r));
  det_db = det > 0.0000001 ? 20 * log10(det) : -140;
  over = det_db - this.thresh;
  over > 0 ? (
    target_gr = over - over / this.ratio;
  ) : (
    target_gr = 0;
  );
  target_gr > this.env ? (
    this.env = this.att * this.env + (1 - this.att) * target_gr;
  ) : (
    this.env = this.rel * this.env + (1 - this.rel) * target_gr;
  );
  this.gr = 10 ^ (-this.env / 20);
  this.gr_db = this.env;
);


// ============================================================================
//  SECTION 5: DC Blocker (stereo, this.* state)
//
//  1-pole highpass to remove DC offset from asymmetric clipping.
//
//  Usage:
//    @init:   dc.lms_dc_init();          // 20 Hz default
//             dc.lms_dc_init_freq(220);  // or custom cutoff
//    @sample: l = dc.lms_dc_proc_l(l);
//             r = dc.lms_dc_proc_r(r);
// ============================================================================

// Initialize DC blocker with default 20 Hz cutoff
function lms_dc_init()
(
  this.xl = 0; this.xr = 0;
  this.yl = 0; this.yr = 0;
  this.r = 1 - (20 / srate);
);

// Initialize DC blocker with custom cutoff frequency
function lms_dc_init_freq(freq)
(
  this.xl = 0; this.xr = 0;
  this.yl = 0; this.yr = 0;
  this.r = 1 - (freq / srate);
);

// Process left channel
function lms_dc_proc_l(x)
(
  this.yl = x - this.xl + this.r * this.yl;
  this.xl = x;
  this.yl;
);

// Process right channel
function lms_dc_proc_r(x)
(
  this.yr = x - this.xr + this.r * this.yr;
  this.xr = x;
  this.yr;
);


// ============================================================================
//  SECTION 6: Tone Filter — 1-pole Lowpass (stereo, this.* state)
//
//  Simple 1-pole lowpass for tone control.
//
//  Usage:
//    @init:   tone.lms_tone_init();
//    @slider: tone.lms_tone_set(freq);
//    @block:  tone.lms_tone_set(freq);
//    @sample: l = tone.lms_tone_proc_l(l);
//             r = tone.lms_tone_proc_r(r);
// ============================================================================

// Initialize tone filter state
function lms_tone_init()
(
  this.yl = 0;
  this.yr = 0;
  this.coeff = 0;
  this.freq = 20000;
);

// Set tone filter cutoff frequency
function lms_tone_set(freq)
(
  this.freq = freq;
  this.coeff = exp(-2 * $pi * freq / srate);
);

// Process left channel (bypasses if freq >= 19999)
function lms_tone_proc_l(x)
(
  this.freq < 19999 ? (
    this.yl = this.yl * this.coeff + x * (1 - this.coeff);
    this.yl;
  ) : (
    x;
  );
);

// Process right channel (bypasses if freq >= 19999)
function lms_tone_proc_r(x)
(
  this.freq < 19999 ? (
    this.yr = this.yr * this.coeff + x * (1 - this.coeff);
    this.yr;
  ) : (
    x;
  );
);


// ============================================================================
//  SECTION 7: Cubic Interpolation (stateless)
//
//  Hermite cubic interpolation for reading from circular delay buffers.
//
//  Usage:
//    out = lms_interp_cubic(buf, pos, bmax);
// ============================================================================

function lms_interp_cubic(buf, pos, bmax)
  local(p0, p1, p2, p3, x0, x1, x2, x3, a, b, c, d, frac, idx)
(
  idx = floor(pos);
  frac = pos - idx;

  p0 = idx - 1; p0 < 0 ? p0 += bmax;
  p1 = idx;     p1 >= bmax ? p1 -= bmax;
  p2 = idx + 1; p2 >= bmax ? p2 -= bmax;
  p3 = idx + 2; p3 >= bmax ? p3 -= bmax;

  x0 = buf[p0]; x1 = buf[p1]; x2 = buf[p2]; x3 = buf[p3];

  // Cubic Hermite interpolation
  a = -0.5*x0 + 1.5*x1 - 1.5*x2 + 0.5*x3;
  b = x0 - 2.5*x1 + 2*x2 - 0.5*x3;
  c = -0.5*x0 + 0.5*x2;
  d = x1;

  ((a * frac + b) * frac + c) * frac + d;
);


// ============================================================================
//  SECTION 8: Spring Reverb Allpass (stateless, buffer-based)
//
//  Single allpass unit for spring reverb / diffusion networks.
//  Caller manages buffer position advancement.
//
//  Usage:
//    out = lms_spring_ap(buf, pos, len, input, coeff);
//    pos += 1; pos >= len ? pos = 0;
// ============================================================================

function lms_spring_ap(buf, pos, len, input, coeff)
  local(delayed, output)
(
  delayed = buf[pos];
  output = -input * coeff + delayed;
  buf[pos] = input + delayed * coeff;
  output;
);
