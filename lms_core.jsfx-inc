// ============================================================================
//  LMS Core DSP Library v1.2
//  Shared DSP building blocks for the LMS plugin suite
//
//  Usage: import lms_core.jsfx-inc
//
//  IMPORTANT: All functions must be inside @init so they are available
//  across all sections (@slider, @block, @sample, @gfx) in importing files.
//  JSFX rule: "functions defined in @init can be used from other sections,
//  whereas functions defined in other sections are local to those sections."
//
//  All functions use lms_ prefix. Stateful functions use this.* pattern —
//  call as instance.lms_xxx() to get independent state per instance.
//
//  Sections:
//    1. Math Utilities           (stateless)
//    2. Biquad Filter            (stereo + mono, this.* state)
//    3. Saturation Suite         (density-aware triode architecture, this.* state)
//    4. Compressor               (stereo FET, this.* state)
//    5. DC Blocker               (stereo, this.* state)
//    6. Tone Filter              (stereo 1-pole LP, this.* state)
//    7. Cubic Interpolation      (stateless)
//    8. Spring Reverb Allpass    (stateless, buffer-based)
//    9. GUI Helpers              (called from @gfx)
//   10. Opto Compressor          (LA-2A T4B photocell, stereo, this.* state)
//   11. Brick-Wall Limiter       (true-peak aware, stereo, this.* state)
//   12. Pitch Detection & Correction (YIN detector, dual-tap shifter, scale snap)
// ============================================================================

@init

// ============================================================================
//  SECTION 1: Math Utilities (stateless)
// ============================================================================

// Bounded exp-based tanh approximation (JSFX has no built-in tanh)
function lms_tanh(x)
  local(e2x)
(
  x > 10 ? 1 : x < -10 ? -1 : (
    e2x = exp(2 * x);
    (e2x - 1) / (e2x + 1);
  );
);

// dB to linear gain
function lms_db2lin(db)
(
  10 ^ (db / 20);
);

// Linear gain to dB (safe — returns -140 for silence)
function lms_lin2db(lin)
(
  lin > 0.0000001 ? 20 * log10(lin) : -140;
);


// ADAA core (used by lms_sat_harmonics for polynomial anti-aliasing): given x_now, x_prev, F(x_now), F(x_prev), f(midpoint) fallback
// Returns the alias-suppressed output sample.
//
// Uses a crossfade zone instead of a hard epsilon switch. A single threshold
// creates a "no man's land" where dx is small enough for the division to amplify
// floating-point noise but not small enough to trigger fallback — this manifests
// as hiss on note decay tails. The crossfade blends smoothly between ADAA and
// fallback, eliminating both the hard-switch artifact and the noisy-division zone.
function lms_adaa_eval(x_now, x_prev, Fx_now, Fx_prev, f_mid)
  local(dx, adx, adaa_out, blend)
(
  dx  = x_now - x_prev;
  adx = abs(dx);
  adx < 0.00001 ? (
    f_mid;
  ) : adx > 0.0001 ? (
    (Fx_now - Fx_prev) / dx;
  ) : (
    adaa_out = (Fx_now - Fx_prev) / dx;
    blend = (adx - 0.00001) / (0.00009);  // 0..1 across the transition band
    f_mid + blend * (adaa_out - f_mid);
  );
);


// ============================================================================
//  SECTION 2: Biquad Filter (stereo, this.* state)
//
//  One instance = one stereo band.
//  Coefficients shared, L/R state separate.
//
//  Usage:
//    @init:   hp.lms_bq_init();
//    @slider: hp.lms_bq_set_hp(freq, 0.707);
//    @block:  hp.lms_bq_set_hp(freq, 0.707);
//    @sample: l = hp.lms_bq_proc_l(l);
//             r = hp.lms_bq_proc_r(r);
// ============================================================================

// Initialize biquad — zero state and set to passthrough
function lms_bq_init()
(
  // Coefficients (passthrough)
  this.b0 = 1; this.b1 = 0; this.b2 = 0;
  this.a1 = 0; this.a2 = 0;
  // Left channel state
  this.lx1 = 0; this.lx2 = 0;
  this.ly1 = 0; this.ly2 = 0;
  // Right channel state
  this.rx1 = 0; this.rx2 = 0;
  this.ry1 = 0; this.ry2 = 0;
);

// Highpass (2nd order Butterworth when q = 0.707)
function lms_bq_set_hp(freq, q)
  local(w0, cs, sn, alpha, a0_inv)
(
  w0 = 2 * $pi * freq / srate;
  cs = cos(w0); sn = sin(w0);
  alpha = sn / (2 * q);
  a0_inv = 1 / (1 + alpha);
  this.b0 = (1 + cs) / 2 * a0_inv;
  this.b1 = -(1 + cs) * a0_inv;
  this.b2 = (1 + cs) / 2 * a0_inv;
  this.a1 = -2 * cs * a0_inv;
  this.a2 = (1 - alpha) * a0_inv;
);

// Lowpass
function lms_bq_set_lp(freq, q)
  local(w0, cs, sn, alpha, a0_inv)
(
  w0 = 2 * $pi * freq / srate;
  cs = cos(w0); sn = sin(w0);
  alpha = sn / (2 * q);
  a0_inv = 1 / (1 + alpha);
  this.b0 = (1 - cs) / 2 * a0_inv;
  this.b1 = (1 - cs) * a0_inv;
  this.b2 = (1 - cs) / 2 * a0_inv;
  this.a1 = -2 * cs * a0_inv;
  this.a2 = (1 - alpha) * a0_inv;
);

// Bandpass (constant skirt gain)
function lms_bq_set_bp(freq, q)
  local(w0, cs, sn, alpha, a0_inv)
(
  w0 = 2 * $pi * freq / srate;
  cs = cos(w0); sn = sin(w0);
  alpha = sn / (2 * q);
  a0_inv = 1 / (1 + alpha);
  this.b0 = (sn / 2) * a0_inv;
  this.b1 = 0;
  this.b2 = -(sn / 2) * a0_inv;
  this.a1 = -2 * cs * a0_inv;
  this.a2 = (1 - alpha) * a0_inv;
);

// Parametric peaking EQ
function lms_bq_set_peak(freq, gain_db, q)
  local(a, w0, alpha, a0_inv)
(
  a = 10 ^ (gain_db / 20);
  w0 = 2 * $pi * freq / srate;
  alpha = sin(w0) / (2 * q);
  a0_inv = 1 / (1 + alpha / a);
  this.b0 = (1 + alpha * a) * a0_inv;
  this.b1 = (-2 * cos(w0)) * a0_inv;
  this.b2 = (1 - alpha * a) * a0_inv;
  this.a1 = this.b1;
  this.a2 = (1 - alpha / a) * a0_inv;
);

// Low shelf
function lms_bq_set_loshelf(freq, gain_db, q)
  local(a, w0, cs, sn, alpha, ap1, am1, beta, a0_inv)
(
  a = 10 ^ (gain_db / 40);
  w0 = 2 * $pi * freq / srate;
  cs = cos(w0); sn = sin(w0);
  alpha = sn / (2 * q);
  ap1 = a + 1; am1 = a - 1;
  beta = 2 * sqrt(a) * alpha;
  a0_inv = 1 / (ap1 + am1 * cs + beta);
  this.b0 = a * (ap1 - am1 * cs + beta) * a0_inv;
  this.b1 = 2 * a * (am1 - ap1 * cs) * a0_inv;
  this.b2 = a * (ap1 - am1 * cs - beta) * a0_inv;
  this.a1 = -2 * (am1 + ap1 * cs) * a0_inv;
  this.a2 = (ap1 + am1 * cs - beta) * a0_inv;
);

// High shelf
function lms_bq_set_hishelf(freq, gain_db, q)
  local(a, w0, cs, sn, alpha, ap1, am1, beta, a0_inv)
(
  a = 10 ^ (gain_db / 40);
  w0 = 2 * $pi * freq / srate;
  cs = cos(w0); sn = sin(w0);
  alpha = sn / (2 * q);
  ap1 = a + 1; am1 = a - 1;
  beta = 2 * sqrt(a) * alpha;
  a0_inv = 1 / (ap1 - am1 * cs + beta);
  this.b0 = a * (ap1 + am1 * cs + beta) * a0_inv;
  this.b1 = -2 * a * (am1 + ap1 * cs) * a0_inv;
  this.b2 = a * (ap1 + am1 * cs - beta) * a0_inv;
  this.a1 = 2 * (am1 - ap1 * cs) * a0_inv;
  this.a2 = (ap1 - am1 * cs - beta) * a0_inv;
);

// Process left channel sample through biquad
function lms_bq_proc_l(x)
  local(o)
(
  o = this.b0 * x + this.b1 * this.lx1 + this.b2 * this.lx2
                   - this.a1 * this.ly1 - this.a2 * this.ly2;
  this.lx2 = this.lx1; this.lx1 = x;
  this.ly2 = this.ly1; this.ly1 = o;
  o;
);

// Process right channel sample through biquad
function lms_bq_proc_r(x)
  local(o)
(
  o = this.b0 * x + this.b1 * this.rx1 + this.b2 * this.rx2
                   - this.a1 * this.ry1 - this.a2 * this.ry2;
  this.rx2 = this.rx1; this.rx1 = x;
  this.ry2 = this.ry1; this.ry1 = o;
  o;
);

// Process mono sample through biquad (uses lx/ly state — do NOT mix with proc_l)
function lms_bq_proc(x)
  local(o)
(
  o = this.b0 * x + this.b1 * this.lx1 + this.b2 * this.lx2
                   - this.a1 * this.ly1 - this.a2 * this.ly2;
  this.lx2 = this.lx1; this.lx1 = x;
  this.ly2 = this.ly1; this.ly1 = o;
  o;
);


// ============================================================================
//  SECTION 3: Saturation Suite (density-aware triode architecture)
//
//  All functions use this.* state for density tracking, bias shift,
//  grid conduction, Miller LP, air shelf, and DC blocking.
//  Call <instance>.lms_sat_XXX_init() once in @init, then
//  call <instance>.lms_sat_XXX(x, drive, bias) per sample.
//
//  Each mode models a different tube/device character by varying the
//  clipping curve shape (pos_hard, neg_hard, pos_ceil, neg_ceil).
//  The density-aware architecture (4-band tracker, bias shift, grid
//  conduction, Miller LP, air shelf) is shared across all modes —
//  identical to the v2 amp sim triode stages.
//
//  Usage:
//    @init:   sat.lms_sat_warm_init();
//    @sample: l = sat.lms_sat_warm(l, drive, bias);
// ============================================================================

// ---- Shared density-aware saturation init ----
function lms_sat_da_init() (
  // Coupling cap bias shift
  this.cap_charge = 0.0;
  this.cap_charge_rate = exp(-1/(srate * 0.0005));
  this.cap_drain_rate = exp(-1/(srate * 0.030));
  // 4-band density tracker
  this.hd_f_lo.lms_bq_init(); this.hd_f_lo.lms_bq_set_lp(250, 0.7);
  this.hd_f_mid_lo.lms_bq_init(); this.hd_f_mid_lo.lms_bq_set_lp(2000, 0.7);
  this.hd_f_mid_hi.lms_bq_init(); this.hd_f_mid_hi.lms_bq_set_hp(250, 0.7);
  this.hd_f_hi.lms_bq_init(); this.hd_f_hi.lms_bq_set_hp(2000, 0.7);
  this.hd_f_air.lms_bq_init(); this.hd_f_air.lms_bq_set_hp(5000, 0.7);
  this.hd_env_lo = 0; this.hd_env_mid = 0; this.hd_env_hi = 0;
  this.hd_env_air = 0; this.hd_env_total = 0;
  this.hd_att = exp(-1/(srate * 0.002));
  this.hd_rel = exp(-1/(srate * 0.080));
  this.hd_density = 1.0; this.hd_mid_density = 0.0;
  this.hd_hi_density = 0.0; this.hd_air_density = 0.0;
  this.hd_smooth = exp(-1/(srate * 0.030));
  // Miller LP (density-driven cutoff)
  this.miller.lms_bq_init();
  this.miller.lms_bq_set_lp(8000, 0.6);
  this.miller_base_freq = 8000;
  this.last_miller_freq = 8000;
  this.last_miller_q = 0.6;
  // Air shelf (density-driven HF control)
  this.air_shelf.lms_bq_init();
  this.air_shelf.lms_bq_set_hishelf(5000, 0.0, 0.7);
  this.last_air_cut = 0.0;
  // Grid conduction peak envelope
  this.peak_env = 0;
  this.peak_att = exp(-1/(srate * 0.0002));
  this.peak_rel = exp(-1/(srate * 0.050));
  // DC blocker
  this.dc_xp = 0; this.dc_yp = 0; this.dc_r = 1 - (20 / srate);
);

// ---- Shared density tracker (inline, uses this.hd_* state) ----
function lms_sat_da_hd_proc(x)
  local(lo, mid, hi, air, abs_lo, abs_mid, abs_hi, abs_air, abs_total,
        raw, raw_mid, raw_hi, raw_air)
(
  lo = this.hd_f_lo.lms_bq_proc(x);
  mid = this.hd_f_mid_hi.lms_bq_proc(this.hd_f_mid_lo.lms_bq_proc(x));
  hi = this.hd_f_hi.lms_bq_proc(x);
  air = this.hd_f_air.lms_bq_proc(x);
  abs_lo = abs(lo); abs_mid = abs(mid); abs_hi = abs(hi);
  abs_air = abs(air); abs_total = abs(x);
  abs_lo > this.hd_env_lo ? (
    this.hd_env_lo = this.hd_att * this.hd_env_lo + (1 - this.hd_att) * abs_lo;
  ) : (
    this.hd_env_lo = this.hd_rel * this.hd_env_lo + (1 - this.hd_rel) * abs_lo;
  );
  abs_mid > this.hd_env_mid ? (
    this.hd_env_mid = this.hd_att * this.hd_env_mid + (1 - this.hd_att) * abs_mid;
  ) : (
    this.hd_env_mid = this.hd_rel * this.hd_env_mid + (1 - this.hd_rel) * abs_mid;
  );
  abs_hi > this.hd_env_hi ? (
    this.hd_env_hi = this.hd_att * this.hd_env_hi + (1 - this.hd_att) * abs_hi;
  ) : (
    this.hd_env_hi = this.hd_rel * this.hd_env_hi + (1 - this.hd_rel) * abs_hi;
  );
  abs_air > this.hd_env_air ? (
    this.hd_env_air = this.hd_att * this.hd_env_air + (1 - this.hd_att) * abs_air;
  ) : (
    this.hd_env_air = this.hd_rel * this.hd_env_air + (1 - this.hd_rel) * abs_air;
  );
  abs_total > this.hd_env_total ? (
    this.hd_env_total = this.hd_att * this.hd_env_total + (1 - this.hd_att) * abs_total;
  ) : (
    this.hd_env_total = this.hd_rel * this.hd_env_total + (1 - this.hd_rel) * abs_total;
  );
  this.hd_env_lo > 0.0001 ? (
    raw = this.hd_env_total / this.hd_env_lo;
    raw = min(2.5, max(1.0, raw));
  ) : ( raw = 1.0; );
  this.hd_env_total > 0.0001 ? (
    raw_mid = this.hd_env_mid / this.hd_env_total;
    raw_mid = min(1.0, max(0.0, raw_mid));
    raw_hi = this.hd_env_hi / this.hd_env_total;
    raw_hi = min(1.0, max(0.0, raw_hi));
    raw_air = this.hd_env_air / this.hd_env_total;
    raw_air = min(1.0, max(0.0, raw_air));
  ) : ( raw_mid = 0.0; raw_hi = 0.0; raw_air = 0.0; );
  this.hd_density = this.hd_smooth * this.hd_density + (1 - this.hd_smooth) * raw;
  this.hd_mid_density = this.hd_smooth * this.hd_mid_density + (1 - this.hd_smooth) * raw_mid;
  this.hd_hi_density = this.hd_smooth * this.hd_hi_density + (1 - this.hd_smooth) * raw_hi;
  this.hd_air_density = this.hd_smooth * this.hd_air_density + (1 - this.hd_smooth) * raw_air;
);

// ---- Shared density-aware saturation core ----
// pos_hard/neg_hard: clipping hardness (higher = harder clip)
// pos_ceil/neg_ceil: clipping ceiling (output bounded to these)
// gc_thresh/gc_amount: grid conduction threshold and squash amount
function lms_sat_da_proc(x, drive, bias, pos_hard, neg_hard, pos_ceil, neg_ceil, gc_thresh, gc_amount)
  local(b, gain, bias_shift, p_ceil, n_ceil, gc_out, lp_freq, lp_q,
        air_cut, drive_boost, ax)
(
  // 1. Coupling cap bias shift
  b = x + bias * 0.1;
  b > 0.1 ? (
    this.cap_charge = this.cap_charge_rate * this.cap_charge
                    + (1 - this.cap_charge_rate) * b * 0.12;
  ) : (
    this.cap_charge = this.cap_drain_rate * this.cap_charge;
  );
  bias_shift = this.cap_charge;
  b = b - bias_shift;

  // 2. Density-driven drive boost (mid density pushes tube harder)
  drive_boost = 1.0 + this.hd_mid_density * 0.4;
  gain = (1.0 + drive * 4.0) * drive_boost;
  b = b * gain;

  // 3. Run density tracker on pre-clip signal
  this.lms_sat_da_hd_proc(b);

  // 4. Fixed clipping curves — ceiling is constant (no PSU in standalone sat)
  p_ceil = pos_ceil;
  n_ceil = neg_ceil;
  b >= 0 ? (
    b = lms_tanh(b * pos_hard) * p_ceil;
  ) : (
    b = lms_tanh(b * neg_hard) * n_ceil;
  );

  // 5. Grid conduction (peak envelope gated soft clamp)
  ax = abs(b);
  ax > this.peak_env ? (
    this.peak_env = this.peak_att * this.peak_env + (1 - this.peak_att) * ax;
  ) : (
    this.peak_env = this.peak_rel * this.peak_env + (1 - this.peak_rel) * ax;
  );
  b > gc_thresh && this.peak_env > gc_thresh * 0.8 ? (
    gc_out = gc_thresh + lms_tanh((b - gc_thresh) * 3.0) * gc_amount;
    b = gc_out;
  );

  // 6. Miller LP — density drives cutoff (AFTER clipping, on output)
  lp_freq = this.miller_base_freq - (this.hd_density - 1.0) * 500;
  lp_freq = max(this.miller_base_freq - 1500, min(this.miller_base_freq + 500, lp_freq));
  lp_q = 0.6 + this.hd_hi_density * 0.35;
  lp_q = max(0.6, min(0.95, lp_q));
  abs(lp_freq - this.last_miller_freq) > 30 || abs(lp_q - this.last_miller_q) > 0.02 ? (
    this.miller.lms_bq_set_lp(lp_freq, lp_q);
    this.last_miller_freq = lp_freq;
    this.last_miller_q = lp_q;
  );
  b = this.miller.lms_bq_proc(b);

  // 7. Air shelf — density-driven HF control
  air_cut = -this.hd_air_density * 3.0;
  air_cut = max(-3.0, min(0.0, air_cut));
  abs(air_cut - this.last_air_cut) > 0.1 ? (
    this.air_shelf.lms_bq_set_hishelf(5000, air_cut, 0.7);
    this.last_air_cut = air_cut;
  );
  b = this.air_shelf.lms_bq_proc(b);

  // 8. DC block
  this.dc_yp = b - this.dc_xp + this.dc_r * this.dc_yp;
  this.dc_xp = b;
  b = this.dc_yp;

  b;
);


// ---- lms_sat_warm — warm tube (soft symmetric, high ceiling, gentle) ----

function lms_sat_warm_init() ( this.lms_sat_da_init(); );

function lms_sat_warm(x, drive, bias) (
  // Warm tube: soft positive, slightly softer negative, high ceiling
  // pos_hard=1.2, neg_hard=0.9, pos_ceil=0.85, neg_ceil=1.0, gc_thresh=0.30, gc_amount=0.15
  this.lms_sat_da_proc(x, drive, bias, 1.2, 0.9, 0.85, 1.0, 0.30, 0.15);
);


// ---- lms_sat_hot — hot tube (pushed 12AX7, harder asymmetric) ----

function lms_sat_hot_init() ( this.lms_sat_da_init(); );

function lms_sat_hot(x, drive, bias) (
  // Hot tube: hard positive, moderate negative, tighter ceiling
  // pos_hard=1.8, neg_hard=1.4, pos_ceil=0.75, neg_ceil=0.95, gc_thresh=0.25, gc_amount=0.18
  this.lms_sat_da_proc(x, drive * 2, bias, 1.8, 1.4, 0.75, 0.95, 0.25, 0.18);
);


// ---- lms_sat_tape — tape saturation (symmetric, soft compression) ----

function lms_sat_tape_init() ( this.lms_sat_da_init(); );

function lms_sat_tape(x, drive, bias) (
  // Tape: symmetric soft compression, wide ceiling, gentle grid conduction
  // pos_hard=0.8, neg_hard=0.8, pos_ceil=0.95, neg_ceil=0.95, gc_thresh=0.35, gc_amount=0.12
  this.lms_sat_da_proc(x, drive * 1.5, bias, 0.8, 0.8, 0.95, 0.95, 0.35, 0.12);
);


// ---- lms_sat_rect — rectifier (hard positive, soft negative fold) ----

function lms_sat_rect_init() ( this.lms_sat_da_init(); );

function lms_sat_rect(x, drive, bias) (
  // Rectifier: very hard positive clip, soft negative (half-wave character)
  // pos_hard=2.0, neg_hard=0.5, pos_ceil=0.70, neg_ceil=0.40, gc_thresh=0.20, gc_amount=0.20
  this.lms_sat_da_proc(x, drive * 3, bias, 2.0, 0.5, 0.70, 0.40, 0.20, 0.20);
);


// ---- lms_sat_fuzz — fuzz (aggressive both sides, low ceiling, gated) ----

function lms_sat_fuzz_init() ( this.lms_sat_da_init(); );

function lms_sat_fuzz(x, drive, bias) (
  // Fuzz: very hard both sides, low ceiling, aggressive grid conduction
  // pos_hard=2.5, neg_hard=2.0, pos_ceil=0.60, neg_ceil=0.55, gc_thresh=0.15, gc_amount=0.25
  this.lms_sat_da_proc(x, drive * 4, bias, 2.5, 2.0, 0.60, 0.55, 0.15, 0.25);
);


// ---- lms_sat_harmonics — polynomial harmonic blend (no hard clip, minimal aliasing) ----
// Polynomial distortion aliases less severely than hard clippers, but x³ still aliases.
// We use ADAA on the x³ term (F(x³) = x⁴/4) and exact for x|x| (F = x²|x|/3).
// This is kept stateless-style since it's additive blend, not a full clipper.

function lms_sat_harmonics_init()
(
  this.xp = 0;
  this.F2p = 0;
  this.F3p = 0;
);

function lms_sat_harmonics(x, even_mix, odd_mix)
  local(x2_now, x3_now, F2_now, F3_now, x2_aa, x3_aa, result, mid)
(
  mid = (x + this.xp) * 0.5;

  // Even: f(x) = x*|x|  (2nd harmonic, signed square)  F(x) = x²|x|/3
  F2_now = x * x * abs(x) / 3;
  x2_aa  = lms_adaa_eval(x, this.xp, F2_now, this.F2p, mid * abs(mid));

  // Odd: f(x) = x³   F(x) = x⁴/4
  F3_now = x * x * x * x / 4;
  x3_aa  = lms_adaa_eval(x, this.xp, F3_now, this.F3p, mid * mid * mid);

  result = x + even_mix * x2_aa * 0.3 + odd_mix * x3_aa * 0.2;

  this.xp   = x;
  this.F2p  = F2_now;
  this.F3p  = F3_now;
  result;
);


// ============================================================================
//  SECTION 4: Compressor — FET-style (stereo, this.* state)
//
//  Stereo-linked peak detection with envelope follower.
//
//  Usage:
//    @init:   comp.lms_comp_init();
//    @slider: comp.lms_comp_set(thresh_db, ratio, att_ms, rel_ms);
//    @block:  comp.lms_comp_set(thresh_db, ratio, att_ms, rel_ms);
//    @sample: comp.lms_comp_proc(l, r);
//             l *= comp.gr;
//             r *= comp.gr;
//             // comp.gr_db has dB of gain reduction
// ============================================================================

// Initialize compressor state
function lms_comp_init()
(
  this.env = 0;
  this.gr = 1;
  this.gr_db = 0;
  this.thresh = 0;
  this.ratio = 4;
  this.att = 0;
  this.rel = 0;
);

// Set compressor parameters
function lms_comp_set(thresh_db, ratio, att_ms, rel_ms)
(
  this.thresh = thresh_db;
  this.ratio = ratio;
  this.att = exp(-1 / (att_ms * 0.001 * srate));
  this.rel = exp(-1 / (rel_ms * 0.001 * srate));
);

// Process stereo pair — updates this.gr (linear) and this.gr_db
function lms_comp_proc(l, r)
  local(det, det_db, over, target_gr)
(
  det = max(abs(l), abs(r));
  det_db = det > 0.0000001 ? 20 * log10(det) : -140;
  over = det_db - this.thresh;
  over > 0 ? (
    target_gr = over - over / this.ratio;
  ) : (
    target_gr = 0;
  );
  target_gr > this.env ? (
    this.env = this.att * this.env + (1 - this.att) * target_gr;
  ) : (
    this.env = this.rel * this.env + (1 - this.rel) * target_gr;
  );
  this.gr = 10 ^ (-this.env / 20);
  this.gr_db = this.env;
);


// ============================================================================
//  SECTION 5: DC Blocker (stereo, this.* state)
//
//  1-pole highpass to remove DC offset from asymmetric clipping.
//
//  Usage:
//    @init:   dc.lms_dc_init();          // 20 Hz default
//             dc.lms_dc_init_freq(220);  // or custom cutoff
//    @sample: l = dc.lms_dc_proc_l(l);
//             r = dc.lms_dc_proc_r(r);
// ============================================================================

// Initialize DC blocker with default 20 Hz cutoff
function lms_dc_init()
(
  this.xl = 0; this.xr = 0;
  this.yl = 0; this.yr = 0;
  this.r = 1 - (20 / srate);
);

// Initialize DC blocker with custom cutoff frequency
function lms_dc_init_freq(freq)
(
  this.xl = 0; this.xr = 0;
  this.yl = 0; this.yr = 0;
  this.r = 1 - (freq / srate);
);

// Process left channel
function lms_dc_proc_l(x)
(
  this.yl = x - this.xl + this.r * this.yl;
  this.xl = x;
  this.yl;
);

// Process right channel
function lms_dc_proc_r(x)
(
  this.yr = x - this.xr + this.r * this.yr;
  this.xr = x;
  this.yr;
);


// ============================================================================
//  SECTION 6: Tone Filter — 1-pole Lowpass (stereo, this.* state)
//
//  Simple 1-pole lowpass for tone control.
//
//  Usage:
//    @init:   tone.lms_tone_init();
//    @slider: tone.lms_tone_set(freq);
//    @block:  tone.lms_tone_set(freq);
//    @sample: l = tone.lms_tone_proc_l(l);
//             r = tone.lms_tone_proc_r(r);
// ============================================================================

// Initialize tone filter state
function lms_tone_init()
(
  this.yl = 0;
  this.yr = 0;
  this.coeff = 0;
  this.freq = 20000;
);

// Set tone filter cutoff frequency
function lms_tone_set(freq)
(
  this.freq = freq;
  this.coeff = exp(-2 * $pi * freq / srate);
);

// Process left channel (bypasses if freq >= 19999)
function lms_tone_proc_l(x)
(
  this.freq < 19999 ? (
    this.yl = this.yl * this.coeff + x * (1 - this.coeff);
    this.yl;
  ) : (
    x;
  );
);

// Process right channel (bypasses if freq >= 19999)
function lms_tone_proc_r(x)
(
  this.freq < 19999 ? (
    this.yr = this.yr * this.coeff + x * (1 - this.coeff);
    this.yr;
  ) : (
    x;
  );
);


// ============================================================================
//  SECTION 7: Cubic Interpolation (stateless)
//
//  Hermite cubic interpolation for reading from circular delay buffers.
//
//  Usage:
//    out = lms_interp_cubic(buf, pos, bmax);
// ============================================================================

function lms_interp_cubic(buf, pos, bmax)
  local(p0, p1, p2, p3, x0, x1, x2, x3, a, b, c, d, frac, idx)
(
  idx = floor(pos);
  frac = pos - idx;

  p0 = idx - 1; p0 < 0 ? p0 += bmax;
  p1 = idx;     p1 >= bmax ? p1 -= bmax;
  p2 = idx + 1; p2 >= bmax ? p2 -= bmax;
  p3 = idx + 2; p3 >= bmax ? p3 -= bmax;

  x0 = buf[p0]; x1 = buf[p1]; x2 = buf[p2]; x3 = buf[p3];

  // Cubic Hermite interpolation
  a = -0.5*x0 + 1.5*x1 - 1.5*x2 + 0.5*x3;
  b = x0 - 2.5*x1 + 2*x2 - 0.5*x3;
  c = -0.5*x0 + 0.5*x2;
  d = x1;

  ((a * frac + b) * frac + c) * frac + d;
);


// ============================================================================
//  SECTION 8: Spring Reverb Allpass (stateless, buffer-based)
//
//  Single allpass unit for spring reverb / diffusion networks.
//  Caller manages buffer position advancement.
//
//  Usage:
//    out = lms_spring_ap(buf, pos, len, input, coeff);
//    pos += 1; pos >= len ? pos = 0;
// ============================================================================

function lms_spring_ap(buf, pos, len, input, coeff)
  local(delayed, output)
(
  delayed = buf[pos];
  output = -input * coeff + delayed;
  buf[pos] = input + delayed * coeff;
  output;
);


// ============================================================================
//  SECTION 9: GUI Helpers (called from @gfx in importing plugins)
//
//  All drawing functions use global scale variable S and font variables
//  F_TITLE, F_LABEL, F_SMALL, F_TINY. Call lms_gfx_setup(nominal_w) at
//  the top of your @gfx section to initialize scaling.
//
//  These functions are defined in @init so they're available everywhere.
//  They call gfx_* functions which only do anything when called from @gfx.
//
//  Color constants are set by lms_gfx_setup() and shared across all helpers.
//
//  Usage:
//    @gfx 500 310
//    lms_gfx_setup(500);
//    lms_gfx_background();
//    lms_gfx_logo_title("MY PLUGIN", "subtitle");
//    // ... then use draw_bar, draw_panel, draw_toggle, draw_mode_sel
// ============================================================================

// ---- Global scale & font setup ----
function lms_gfx_setup(nominal_w) (
  gfx_ext_retina > 0 ? gfx_ext_retina = 1;
  S = gfx_w / nominal_w;
  S < 0.5 ? S = 0.5;

  // Scaled font sizes
  F_TITLE = max(10, floor(22 * S));
  F_LABEL = max(8, floor(12 * S));
  F_SMALL = max(7, floor(11 * S));
  F_TINY  = max(7, floor(10 * S));

  // Header height
  lms_hdr_h = floor(44 * S);

  // Color constants (set once, used by all helpers)
  COL_BG_R = 0.05; COL_BG_G = 0.05; COL_BG_B = 0.07;
  COL_PANEL_R = 0.08; COL_PANEL_G = 0.08; COL_PANEL_B = 0.11;
  COL_PANEL_HI_R = 0.12; COL_PANEL_HI_G = 0.12; COL_PANEL_HI_B = 0.16;
  COL_BORDER_R = 0.20; COL_BORDER_G = 0.20; COL_BORDER_B = 0.25;
  COL_TITLE_R = 0.95; COL_TITLE_G = 0.78; COL_TITLE_B = 0.35;
  COL_SEC_R = 0.55; COL_SEC_G = 0.50; COL_SEC_B = 0.40;
  COL_TEXT_R = 0.78; COL_TEXT_G = 0.78; COL_TEXT_B = 0.82;
  COL_DIM_R = 0.38; COL_DIM_G = 0.38; COL_DIM_B = 0.42;
  COL_ACCENT_R = 0.95; COL_ACCENT_G = 0.45; COL_ACCENT_B = 0.15;
  COL_GREEN_R = 0.25; COL_GREEN_G = 0.80; COL_GREEN_B = 0.50;
  COL_CYAN_R = 0.20; COL_CYAN_G = 0.60; COL_CYAN_B = 0.85;
  COL_BAR_BG_R = 0.12; COL_BAR_BG_G = 0.12; COL_BAR_BG_B = 0.16;
);

// ---- Background + header bar ----
function lms_gfx_background() (
  gfx_r = COL_BG_R; gfx_g = COL_BG_G; gfx_b = COL_BG_B;
  gfx_rect(0, 0, gfx_w, gfx_h);
  gfx_r = 0.03; gfx_g = 0.03; gfx_b = 0.05;
  gfx_rect(0, 0, gfx_w, lms_hdr_h);
  gfx_r = COL_TITLE_R * 0.6; gfx_g = COL_TITLE_G * 0.6; gfx_b = COL_TITLE_B * 0.6;
  gfx_rect(0, lms_hdr_h, gfx_w, max(1, floor(2 * S)));
);

// ---- Logo + title text ----
// logo_slot: image index (usually 0). title: main name. subtitle: optional (pass "" to skip)
function lms_gfx_logo_title(logo_slot, title, subtitle) (
  lms_logo_h = floor(32 * S);
  lms_logo_w = floor(32 * S * (1920 / 1080));
  lms_logo_x = floor(6 * S);
  lms_logo_y = floor((lms_hdr_h - lms_logo_h) / 2);
  gfx_blit(logo_slot, 1, 0, 0, 0, 1920, 1080, lms_logo_x, lms_logo_y, lms_logo_w, lms_logo_h);
  gfx_r = COL_TITLE_R; gfx_g = COL_TITLE_G; gfx_b = COL_TITLE_B;
  gfx_setfont(1, "Arial", F_TITLE);
  gfx_x = lms_logo_x + lms_logo_w + floor(8 * S);
  gfx_y = floor(10 * S);
  gfx_drawstr(title);
  strlen(subtitle) > 0 ? (
    gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
    gfx_setfont(1, "Arial", F_LABEL);
    gfx_x += floor(12 * S);
    gfx_y = floor(18 * S);
    gfx_drawstr(subtitle);
  );
);

// ---- draw_bar — slider bar with fill, label, optional value, click-drag ----
function lms_draw_bar(bx, by, bw, bh, val, vmin, vmax, label, show_val) (
  gfx_r = COL_BAR_BG_R; gfx_g = COL_BAR_BG_G; gfx_b = COL_BAR_BG_B;
  gfx_rect(bx, by, bw, bh);
  norm = (val - vmin) / (vmax - vmin);
  norm = max(0, min(1, norm));
  fill_w = norm * bw;
  fill_w > 0 ? (
    gfx_r = COL_CYAN_R * 0.6; gfx_g = COL_CYAN_G * 0.6; gfx_b = COL_CYAN_B * 0.6;
    gfx_rect(bx, by, fill_w, bh);
    gfx_r = COL_CYAN_R * 0.8; gfx_g = COL_CYAN_G * 0.8; gfx_b = COL_CYAN_B * 0.8;
    gfx_rect(bx, by, fill_w, floor(bh / 2));
    gfx_r = COL_CYAN_R; gfx_g = COL_CYAN_G; gfx_b = COL_CYAN_B;
    gfx_rect(bx, by, fill_w, 1);
  );
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_rect(bx, by, bw, 1); gfx_rect(bx, by + bh - 1, bw, 1);
  gfx_rect(bx, by, 1, bh); gfx_rect(bx + bw - 1, by, 1, bh);
  gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
  gfx_setfont(1, "Arial", F_LABEL);
  gfx_x = bx + floor(5 * S); gfx_y = by + floor((bh - F_LABEL) / 2);
  gfx_drawstr(label);
  show_val ? (
    gfx_setfont(1, "Arial", F_SMALL);
    gfx_x = bx + bw - floor(40 * S); gfx_y = by + floor((bh - F_SMALL) / 2);
    gfx_drawnumber(val, val == floor(val) ? 0 : 1);
  );
  mouse_cap & 1 ? (
    mouse_x >= bx && mouse_x <= bx + bw &&
    mouse_y >= by && mouse_y <= by + bh ? (
      new_norm = (mouse_x - bx) / bw;
      new_norm = max(0, min(1, new_norm));
      val = vmin + new_norm * (vmax - vmin);
    );
  );
  val;
);

// ---- draw_panel — bordered section with title bar ----
function lms_draw_panel(px, py, pw, ph, title) (
  gfx_r = COL_PANEL_R; gfx_g = COL_PANEL_G; gfx_b = COL_PANEL_B;
  gfx_rect(px, py, pw, ph);
  gfx_r = COL_PANEL_HI_R; gfx_g = COL_PANEL_HI_G; gfx_b = COL_PANEL_HI_B;
  gfx_rect(px, py, pw, floor(22 * S));
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_rect(px, py + floor(22 * S), pw, 1);
  gfx_r = COL_BORDER_R * 0.7; gfx_g = COL_BORDER_G * 0.7; gfx_b = COL_BORDER_B * 0.7;
  gfx_rect(px, py, pw, 1); gfx_rect(px, py, 1, ph);
  gfx_rect(px + pw - 1, py, 1, ph); gfx_rect(px, py + ph - 1, pw, 1);
  gfx_r = COL_SEC_R; gfx_g = COL_SEC_G; gfx_b = COL_SEC_B;
  gfx_setfont(1, "Arial", F_LABEL);
  gfx_x = px + floor(8 * S); gfx_y = py + floor(4 * S);
  gfx_drawstr(title);
);

// ---- draw_toggle — on/off circle + label ----
function lms_draw_toggle(tx, ty, is_on, label) (
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_circle(tx + floor(8 * S), ty + floor(8 * S), floor(7 * S), 0);
  is_on ? (
    gfx_r = COL_GREEN_R; gfx_g = COL_GREEN_G; gfx_b = COL_GREEN_B;
    gfx_circle(tx + floor(8 * S), ty + floor(8 * S), floor(5 * S), 1);
  ) : (
    gfx_r = 0.15; gfx_g = 0.15; gfx_b = 0.18;
    gfx_circle(tx + floor(8 * S), ty + floor(8 * S), floor(5 * S), 1);
  );
  gfx_r = is_on ? COL_TEXT_R : COL_DIM_R;
  gfx_g = is_on ? COL_TEXT_G : COL_DIM_G;
  gfx_b = is_on ? COL_TEXT_B : COL_DIM_B;
  gfx_setfont(1, "Arial", F_SMALL);
  gfx_x = tx + floor(20 * S); gfx_y = ty + floor(1 * S);
  gfx_drawstr(label);
  (mouse_cap & 1) && !(last_cap & 1) &&
    mouse_x >= tx && mouse_x <= tx + floor(80 * S) &&
    mouse_y >= ty && mouse_y <= ty + floor(16 * S) ? (
      is_on = 1 - is_on;
  );
  is_on;
);

// ---- draw_mode_sel — clickable mode selector (up to 4 options) ----
function lms_draw_mode_sel(mx, my, mw, mh, val, vmax, label, v0, v1, v2, v3) (
  gfx_r = COL_BAR_BG_R; gfx_g = COL_BAR_BG_G; gfx_b = COL_BAR_BG_B;
  gfx_rect(mx, my, mw, mh);
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_rect(mx, my, mw, 1); gfx_rect(mx, my + mh - 1, mw, 1);
  gfx_rect(mx, my, 1, mh); gfx_rect(mx + mw - 1, my, 1, mh);
  gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
  gfx_setfont(1, "Arial", F_LABEL);
  gfx_x = mx + floor(5 * S); gfx_y = my + floor((mh - F_LABEL) / 2);
  gfx_drawstr(label);
  gfx_r = COL_ACCENT_R; gfx_g = COL_ACCENT_G; gfx_b = COL_ACCENT_B;
  gfx_x = mx + mw - floor(72 * S); gfx_y = my + floor((mh - F_LABEL) / 2);
  val == 0 ? gfx_drawstr(v0);
  val == 1 ? gfx_drawstr(v1);
  val == 2 ? gfx_drawstr(v2);
  val == 3 ? gfx_drawstr(v3);
  (mouse_cap & 1) && !(last_cap & 1) &&
    mouse_x >= mx && mouse_x <= mx + mw &&
    mouse_y >= my && mouse_y <= my + mh ? (
      val = (val + 1) % (vmax + 1);
  );
  (mouse_cap & 2) && !(last_cap & 2) &&
    mouse_x >= mx && mouse_x <= mx + mw &&
    mouse_y >= my && mouse_y <= my + mh ? (
      val = val - 1; val < 0 ? val = vmax;
  );
  val;
);

// ---- NOTICE overlay ----
function lms_gfx_notice() (
  gfx_r = 0.05; gfx_g = 0.05; gfx_b = 0.05; gfx_a = 0.95;
  gfx_rect(0, 0, gfx_w, gfx_h);
  gfx_a = 1;
  gfx_setfont(1, "Arial", F_LABEL);
  gfx_r = 0.9; gfx_g = 0.8; gfx_b = 0.5;
  gfx_x = floor(15 * S); gfx_y = floor(10 * S);
  gfx_drawstr("NOTICE: THEY ARE TRYING TO STEAL YOUR COMPUTER");
  gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.7;
  gfx_x = floor(15 * S); gfx_y = floor(30 * S);
  gfx_drawstr("The algorithms in our favorite software are decades old.");
  gfx_x = floor(15 * S); gfx_y = floor(45 * S);
  gfx_drawstr("A mathematical model is a truth about the world,");
  gfx_x = floor(15 * S); gfx_y = floor(60 * S);
  gfx_drawstr("not a copyrightable product. You do not have to stay");
  gfx_x = floor(15 * S); gfx_y = floor(75 * S);
  gfx_drawstr("a slave to subscription software. Install Linux.");
  gfx_x = floor(15 * S); gfx_y = floor(90 * S);
  gfx_drawstr("Build your own tools. Believe in yourself.");
  gfx_r = 0.5; gfx_g = 0.7; gfx_b = 1.0;
  gfx_x = floor(15 * S); gfx_y = floor(115 * S);
  gfx_drawstr("github.com/LMSBAND  |  instagram.com/LMSSKABAND");
);

// ---- NOTICE button + overlay ----
// Call at the end of @gfx. Uses notice_show and notice_clicked globals.
// bc_panel_y should be set before calling (from instance panel or gfx_h).
function lms_gfx_notice_btn(bc_panel_y) (
  notice_btn_x = gfx_w - floor(60 * S);
  notice_btn_y = bc_panel_y - floor(18 * S);
  gfx_r = 0.6; gfx_g = 0.5; gfx_b = 0.3;
  gfx_rect(notice_btn_x, notice_btn_y, floor(55 * S), floor(15 * S));
  gfx_r = 0; gfx_g = 0; gfx_b = 0;
  gfx_setfont(1, "Arial", F_SMALL);
  gfx_x = notice_btn_x + floor(4 * S); gfx_y = notice_btn_y + floor(2 * S);
  gfx_drawstr("NOTICE");
  (mouse_cap & 1) && mouse_x >= notice_btn_x && mouse_x <= notice_btn_x + floor(55 * S)
    && mouse_y >= notice_btn_y && mouse_y <= notice_btn_y + floor(15 * S) && !notice_clicked ? (
    notice_show = !notice_show;
    notice_show ? buy_show = 0;
    notice_clicked = 1;
  );
  !(mouse_cap & 1) ? notice_clicked = 0;
  notice_show ? (
    lms_gfx_notice();
    // Redraw notice button on top of overlay
    gfx_r = 0.6; gfx_g = 0.5; gfx_b = 0.3;
    gfx_rect(notice_btn_x, notice_btn_y, floor(55 * S), floor(15 * S));
    gfx_r = 0; gfx_g = 0; gfx_b = 0;
    gfx_setfont(1, "Arial", F_SMALL);
    gfx_x = notice_btn_x + floor(4 * S); gfx_y = notice_btn_y + floor(2 * S);
    gfx_drawstr("NOTICE");
  );
);

// ---- BUY overlay ----
function lms_gfx_buy() (
  gfx_r = 0.05; gfx_g = 0.05; gfx_b = 0.05; gfx_a = 0.95;
  gfx_rect(0, 0, gfx_w, gfx_h);
  gfx_a = 1;
  gfx_setfont(1, "Arial", F_LABEL);
  gfx_r = 0.9; gfx_g = 0.8; gfx_b = 0.5;
  gfx_x = floor(15 * S); gfx_y = floor(10 * S);
  gfx_drawstr("SUPPORT LMS");
  gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.7;
  gfx_x = floor(15 * S); gfx_y = floor(35 * S);
  gfx_drawstr("These plugins are offered for free use by anyone not able to afford it.");
  gfx_x = floor(15 * S); gfx_y = floor(50 * S);
  gfx_drawstr("No need to prove anything to us. But if you can afford to buy this suite,");
  gfx_x = floor(15 * S); gfx_y = floor(65 * S);
  gfx_drawstr("we would sure appreciate it. 50 dollars gets you every update and every");
  gfx_x = floor(15 * S); gfx_y = floor(80 * S);
  gfx_drawstr("plugin added to this suite forever. Its in its baby stages and these will");
  gfx_x = floor(15 * S); gfx_y = floor(95 * S);
  gfx_drawstr("only get doper over time. We also offer 6 months installments. But if you");
  gfx_x = floor(15 * S); gfx_y = floor(110 * S);
  gfx_drawstr("dont have the money, dont sweat it, you can use as much and as long as");
  gfx_x = floor(15 * S); gfx_y = floor(125 * S);
  gfx_drawstr("you like. Hail Satan. - LMS");
  gfx_r = 0.5; gfx_g = 0.7; gfx_b = 1.0;
  gfx_x = floor(15 * S); gfx_y = floor(150 * S);
  gfx_drawstr("bryanleaf.gumroad.com/l/zzgmzx");
);

// ---- BUY button + overlay ----
// Call at the end of @gfx, before or after lms_gfx_notice_btn().
// Uses buy_show and buy_clicked globals.
function lms_gfx_buy_btn(bc_panel_y) (
  buy_btn_x = gfx_w - floor(115 * S);
  buy_btn_y = bc_panel_y - floor(18 * S);
  gfx_r = 0.6; gfx_g = 0.5; gfx_b = 0.3;
  gfx_rect(buy_btn_x, buy_btn_y, floor(50 * S), floor(15 * S));
  gfx_r = 0; gfx_g = 0; gfx_b = 0;
  gfx_setfont(1, "Arial", F_SMALL);
  gfx_x = buy_btn_x + floor(4 * S); gfx_y = buy_btn_y + floor(2 * S);
  gfx_drawstr("BUY");
  (mouse_cap & 1) && mouse_x >= buy_btn_x && mouse_x <= buy_btn_x + floor(50 * S)
    && mouse_y >= buy_btn_y && mouse_y <= buy_btn_y + floor(15 * S) && !buy_clicked ? (
    buy_show = !buy_show;
    buy_show ? notice_show = 0;
    buy_clicked = 1;
  );
  !(mouse_cap & 1) ? buy_clicked = 0;
  buy_show ? (
    lms_gfx_buy();
    // Redraw both buttons on top of overlay
    gfx_r = 0.6; gfx_g = 0.5; gfx_b = 0.3;
    gfx_rect(buy_btn_x, buy_btn_y, floor(50 * S), floor(15 * S));
    gfx_r = 0; gfx_g = 0; gfx_b = 0;
    gfx_setfont(1, "Arial", F_SMALL);
    gfx_x = buy_btn_x + floor(4 * S); gfx_y = buy_btn_y + floor(2 * S);
    gfx_drawstr("BUY");
  );
);


// ============================================================================
//  SECTION 10: Opto Compressor — LA-2A T4B Photocell Model
//  (stereo, density-aware, this.* state)
//
//  Models the Teletronix LA-2A leveling amplifier's electro-optical
//  gain reduction circuit. The T4B cell contains an EL panel (light source)
//  driving a CdS photoresistor (variable attenuator). The photocell's
//  power-law resistance curve creates a natural soft knee, and its
//  persistent photoconductivity ("memory") creates program-dependent
//  release — the defining characteristic of the LA-2A sound.
//
//  Density-aware: a 4-band harmonic density tracker (same architecture
//  as the v2 amp triode stages) drives the photocell model. Denser
//  signals = faster EL response, longer memory accumulation, more
//  program-dependent behavior. This maps to real physics: the EL panel
//  responds differently to different spectral content.
//
//  Feedback topology: the sidechain reads from the compressed OUTPUT,
//  not the input. This self-regulating loop is what makes the LA-2A
//  gentle and musical. Limit mode blends a small amount of input signal
//  into the sidechain for higher effective ratios.
//
//  Usage:
//    @init:   opto.lms_opto_init();
//    @slider: opto.lms_opto_set(peak_red, mode, emphasis, warmth);
//    @block:  opto.lms_opto_set(peak_red, mode, emphasis, warmth);
//    @sample: opto.lms_opto_proc(l, r);
//             l *= opto.gr;
//             r *= opto.gr;
//             // opto.gr_db has dB of gain reduction for metering
// ============================================================================

// ---- Opto internal: 4-band density tracker ----
// Identical architecture to the v2 amp triode stages.
// Tracks lo/mid/hi/air energy distribution to drive photocell behavior.
function lms_opto_hd_init() (
  this.f_lo.lms_bq_init(); this.f_lo.lms_bq_set_lp(250, 0.7);
  this.f_mid_lo.lms_bq_init(); this.f_mid_lo.lms_bq_set_lp(2000, 0.7);
  this.f_mid_hi.lms_bq_init(); this.f_mid_hi.lms_bq_set_hp(250, 0.7);
  this.f_hi.lms_bq_init(); this.f_hi.lms_bq_set_hp(2000, 0.7);
  this.f_air.lms_bq_init(); this.f_air.lms_bq_set_hp(5000, 0.7);
  this.env_lo = 0; this.env_mid = 0; this.env_hi = 0;
  this.env_air = 0; this.env_total = 0;
  this.att = exp(-1 / (srate * 0.002));
  this.rel = exp(-1 / (srate * 0.080));
  this.density = 1.0; this.mid_density = 0.0;
  this.hi_density = 0.0; this.air_density = 0.0;
  this.smooth = exp(-1 / (srate * 0.030));
);

function lms_opto_hd_proc(x)
  local(lo, mid, hi, air, abs_lo, abs_mid, abs_hi, abs_air, abs_total,
        raw, raw_mid, raw_hi, raw_air)
(
  lo = this.f_lo.lms_bq_proc(x);
  mid = this.f_mid_hi.lms_bq_proc(this.f_mid_lo.lms_bq_proc(x));
  hi = this.f_hi.lms_bq_proc(x);
  air = this.f_air.lms_bq_proc(x);
  abs_lo = abs(lo); abs_mid = abs(mid); abs_hi = abs(hi);
  abs_air = abs(air); abs_total = abs(x);
  abs_lo > this.env_lo ? (
    this.env_lo = this.att * this.env_lo + (1 - this.att) * abs_lo;
  ) : (
    this.env_lo = this.rel * this.env_lo + (1 - this.rel) * abs_lo;
  );
  abs_mid > this.env_mid ? (
    this.env_mid = this.att * this.env_mid + (1 - this.att) * abs_mid;
  ) : (
    this.env_mid = this.rel * this.env_mid + (1 - this.rel) * abs_mid;
  );
  abs_hi > this.env_hi ? (
    this.env_hi = this.att * this.env_hi + (1 - this.att) * abs_hi;
  ) : (
    this.env_hi = this.rel * this.env_hi + (1 - this.rel) * abs_hi;
  );
  abs_air > this.env_air ? (
    this.env_air = this.att * this.env_air + (1 - this.att) * abs_air;
  ) : (
    this.env_air = this.rel * this.env_air + (1 - this.rel) * abs_air;
  );
  abs_total > this.env_total ? (
    this.env_total = this.att * this.env_total + (1 - this.att) * abs_total;
  ) : (
    this.env_total = this.rel * this.env_total + (1 - this.rel) * abs_total;
  );
  this.env_lo > 0.0001 ? (
    raw = this.env_total / this.env_lo;
    raw = min(2.5, max(1.0, raw));
  ) : ( raw = 1.0; );
  this.env_total > 0.0001 ? (
    raw_mid = this.env_mid / this.env_total; raw_mid = min(1.0, max(0.0, raw_mid));
    raw_hi = this.env_hi / this.env_total; raw_hi = min(1.0, max(0.0, raw_hi));
    raw_air = this.env_air / this.env_total; raw_air = min(1.0, max(0.0, raw_air));
  ) : ( raw_mid = 0.0; raw_hi = 0.0; raw_air = 0.0; );
  this.density = this.smooth * this.density + (1 - this.smooth) * raw;
  this.mid_density = this.smooth * this.mid_density + (1 - this.smooth) * raw_mid;
  this.hi_density = this.smooth * this.hi_density + (1 - this.smooth) * raw_hi;
  this.air_density = this.smooth * this.air_density + (1 - this.smooth) * raw_air;
);

// ---- Opto init ----
function lms_opto_init() (
  // T4B Photocell state
  this.cell_r = 1.0;          // normalized resistance: 1.0 = dark (no compression), 0.0 = full light
  this.cell_target = 1.0;     // target resistance from current light level
  this.light = 0.0;           // current EL panel brightness
  this.memory = 0.0;          // accumulated light energy (CdS trap states)
  this.memory_decay = exp(-1 / (srate * 2.0));  // ~2s half-life for memory

  // Envelope coefficients
  this.att_coeff = exp(-1 / (srate * 0.010));    // ~10ms attack
  this.rel_fast = exp(-1 / (srate * 0.060));     // ~60ms stage 1 release
  this.rel_slow = exp(-1 / (srate * 1.000));     // ~1s stage 2 base release
  this.recovery_pct = 1.0;    // 0 = fully compressed, 1 = fully recovered

  // Sidechain
  this.sc_env = 0.0;          // sidechain envelope
  this.sc_gain = 0.5;         // peak reduction amount (0-1)
  this.sc_mode = 0;           // 0=compress, 1=limit
  this.emphasis = 0.5;        // R37 pre-emphasis (0-1)
  this.warmth = 0.0;          // output tube drive (0-1)
  this.mix = 1.0;             // dry/wet

  // Feedback state (1-sample delay for feedback topology)
  this.prev_gr = 1.0;

  // Sidechain pre-emphasis filter (R37 — hi-shelf in sidechain)
  this.sc_shelf.lms_bq_init();
  this.sc_shelf.lms_bq_set_hishelf(3500, 0.0, 0.7);
  this.last_emph_db = 0.0;

  // 4-band density tracker
  this.hd.lms_opto_hd_init();

  // Output tube saturation (very subtle — 12AX7 warmth)
  this.sat_l.lms_sat_warm_init();
  this.sat_r.lms_sat_warm_init();

  // DC blocker
  this.dc.lms_dc_init();

  // Output
  this.gr = 1.0;
  this.gr_db = 0.0;

  // Metering extras
  this.cell_r_display = 1.0;
  this.memory_display = 0.0;
  this.release_stage = 0;     // 0=idle, 1=fast, 2=slow
);

// ---- Opto set parameters ----
// peak_red: 0-1 (maps to sidechain amp gain — "how much compression")
// mode: 0=compress, 1=limit
// emphasis: 0-1 (R37 HF sidechain sensitivity)
// warmth: 0-1 (output tube saturation amount)
function lms_opto_set(peak_red, mode, emphasis, warmth) (
  this.sc_gain = peak_red;
  this.sc_mode = mode;
  this.emphasis = emphasis;
  this.warmth = warmth;

  // Update sidechain emphasis filter if changed significantly
  // Base: 0 dB at 0% emphasis, up to +12 dB at 100%
  emph_db = emphasis * 12.0;
  abs(emph_db - this.last_emph_db) > 0.5 ? (
    this.sc_shelf.lms_bq_set_hishelf(3500, emph_db, 0.7);
    this.last_emph_db = emph_db;
  );
);

// ---- Opto process stereo pair ----
// Updates this.gr (linear gain 0.01-1.0) and this.gr_db
function lms_opto_proc(l, r)
  local(mono, sc_input, sc_level, sc_db, el_voltage, gamma,
        r_target, att_time, eff_att, rel_coeff, eff_rel_slow,
        density_memory_boost, recovery_threshold)
(
  mono = (l + r) * 0.5;

  // 1. Run density tracker on input signal
  this.hd.lms_opto_hd_proc(mono);

  // 2. Compute sidechain input (FEEDBACK topology)
  //    Compress: sidechain = output level (using previous sample's GR)
  //    Limit: sidechain = (1/25)*input + (24/25)*output
  this.sc_mode == 0 ? (
    // Compress mode: pure feedback
    sc_input = abs(mono) * this.prev_gr;
  ) : (
    // Limit mode: blended — small input component for higher effective ratio
    sc_input = abs(mono) * 0.04 + abs(mono) * this.prev_gr * 0.96;
  );

  // 3. Apply sidechain pre-emphasis (R37)
  //    Density-aware: air content slightly boosts emphasis
  sc_input = this.sc_shelf.lms_bq_proc(sc_input);

  // 4. Sidechain amplifier (Peak Reduction control)
  //    sc_gain maps 0-1 to effective sidechain sensitivity
  //    At 0: no compression. At 1: very sensitive, heavy compression.
  sc_level = sc_input * (0.5 + this.sc_gain * 4.0);

  // 5. EL Panel → Light intensity
  //    Real EL panel has a threshold below which it doesn't illuminate,
  //    then brightness is approximately proportional to applied voltage.
  //    Density-aware: denser signals produce slightly more consistent light
  //    (real EL panels respond more consistently to harmonically rich content)
  el_voltage = max(0.0, sc_level - 0.01);  // soft threshold
  this.light = el_voltage * el_voltage;     // square law (EL panel is voltage-squared brightness)
  this.light = min(1.0, this.light * (1.0 + this.hd.mid_density * 0.15));

  // 6. CdS Photoresistor — power-law resistance from light
  //    R = (L_ref / L)^gamma, gamma ~0.7
  //    Normalized: 1.0 = dark (no compression), approaching 0 = full light (max compression)
  gamma = 0.7;
  this.light > 0.0001 ? (
    r_target = (0.001 / max(0.001, this.light)) ^ gamma;
    r_target = min(1.0, max(0.01, r_target));
  ) : (
    r_target = 1.0;  // dark — no compression
  );

  // 7. Two-stage release with density-driven memory
  //    This IS the LA-2A. Without this it's just another compressor.

  // Memory accumulation — integrate light exposure over time
  // Denser signals contribute more to memory (more trapped carriers in CdS)
  density_memory_boost = 1.0 + (this.hd.density - 1.0) * 0.3;
  this.memory += this.light * density_memory_boost / srate;
  this.memory *= this.memory_decay;
  this.memory = min(2.0, this.memory);  // cap to prevent runaway

  // Attack: ~10ms, slightly faster with denser signal
  att_time = 0.010 * (1.0 - this.hd.mid_density * 0.15);
  att_time = max(0.003, att_time);  // never faster than 3ms
  eff_att = exp(-1 / (srate * att_time));

  // Determine recovery percentage (where are we in the release cycle)
  this.recovery_pct = (this.cell_r - 0.01) / 0.99;
  this.recovery_pct = max(0.0, min(1.0, this.recovery_pct));

  // Release: two-stage
  recovery_threshold = 0.5;  // transition point between fast and slow
  this.recovery_pct < recovery_threshold ? (
    // Stage 1: fast initial recovery (~60ms)
    rel_coeff = this.rel_fast;
    this.release_stage = 1;
  ) : (
    // Stage 2: slow tail — memory stretches this
    // More memory = more trapped carriers = slower recovery
    eff_rel_slow = 1.0 + this.memory * 2.0;  // 1s base, up to 5s with heavy memory
    rel_coeff = exp(-1 / (srate * eff_rel_slow));
    this.release_stage = 2;
  );

  // Apply envelope: asymmetric attack/release on photocell resistance
  r_target < this.cell_r ? (
    // Attacking (resistance dropping = more compression)
    this.cell_r = eff_att * this.cell_r + (1 - eff_att) * r_target;
    this.release_stage = 0;
  ) : (
    // Releasing (resistance rising = less compression)
    this.cell_r = rel_coeff * this.cell_r + (1 - rel_coeff) * r_target;
  );

  // Clamp
  this.cell_r = max(0.01, min(1.0, this.cell_r));

  // 8. Gain from voltage divider
  //    gain = R_photocell / (R_series + R_photocell)
  //    Normalized: cell_r IS the gain (1.0 = unity, 0.01 = -40dB)
  this.gr = this.cell_r;
  this.gr_db = 20 * log10(max(0.001, this.gr));

  // Store for next sample's feedback
  this.prev_gr = this.gr;

  // Update display values (smoothed for GUI)
  this.cell_r_display = this.cell_r_display * 0.95 + this.cell_r * 0.05;
  this.memory_display = this.memory_display * 0.95 + this.memory * 0.05;
);


// ============================================================================
//  SECTION 11: Brick-Wall Limiter (true-peak aware, stereo, this.* state)
//
//  Transparent brick-wall limiter with true peak detection via 2x
//  oversampled inter-sample peak interpolation. Catches DAC-clipping
//  peaks that sample-level detection misses.
//
//  Usage:
//    @init:   lim.lms_lim_init();
//    @slider: lim.lms_lim_set(ceiling_db, release_ms);
//    @block:  lim.lms_lim_set(ceiling_db, release_ms);
//    @sample: lim.lms_lim_proc(l, r);
//             spl0 = lim.out_l;   // already limited + hard-clipped
//             spl1 = lim.out_r;
//             // lim.gr, lim.gr_db for metering, lim.true_peak for peak display
//
//  Lookahead: 1ms delay buffer lets the limiter see peaks before they
//  hit the output. Hard clip safety catches anything residual.
//  Nothing exceeds ceiling. Period.
// ============================================================================

function lms_lim_init() (
  // State
  this.gr = 1.0;
  this.gr_db = 0.0;
  this.gain_reduction = 1.0;
  this.true_peak = 0.0;

  // Envelope
  this.env_fast = 0.0;
  this.rel_coeff = exp(-1 / (srate * 0.003));

  // Ceiling
  this.ceiling = 1.0;
  this.ceil_db = -0.3;

  // Lookahead buffer (1ms — enough to catch transients before they hit output)
  this.la_len = max(1, floor(srate * 0.001));
  this.la_buf = 900000;  // memory offset for lookahead buffer (L+R interleaved)
  this.la_pos = 0;
  i = 0;
  loop(this.la_len * 2,
    this.la_buf[i] = 0;
    i += 1;
  );

  // True peak detection (2x oversampled half-band interpolation)
  this.hb_l.lms_bq_init();
  this.hb_r.lms_bq_init();
  this.hb_l.lms_bq_set_lp(srate * 0.25, 0.54);
  this.hb_r.lms_bq_set_lp(srate * 0.25, 0.54);
  this.prev_l = 0;
  this.prev_r = 0;

  // Metering
  this.gr_meter = 0;
  this.gr_meter_rel = exp(-1 / (srate * 0.100));
);

function lms_lim_set(ceiling_db, release_ms) (
  this.ceil_db = ceiling_db;
  this.ceiling = lms_db2lin(ceiling_db);
  this.rel_coeff = exp(-1 / (srate * release_ms * 0.001));
);

function lms_lim_proc(l, r)
  local(mid_l, mid_r, sample_peak, interp_peak, needed_gr,
        out_l, out_r, out_peak, hard_gr)
(
  // True peak detection: interpolate between current and previous sample
  mid_l = (l + this.prev_l) * 0.5;
  mid_r = (r + this.prev_r) * 0.5;
  mid_l = this.hb_l.lms_bq_proc_l(mid_l);
  mid_r = this.hb_r.lms_bq_proc_r(mid_r);
  this.prev_l = l;
  this.prev_r = r;

  sample_peak = max(abs(l), abs(r));
  interp_peak = max(abs(mid_l), abs(mid_r));
  this.true_peak = max(sample_peak, interp_peak);

  // Calculate needed gain reduction for THIS sample (no knee — brick wall)
  this.true_peak > this.ceiling ? (
    needed_gr = this.ceiling / this.true_peak;
  ) : (
    needed_gr = 1.0;
  );

  // Instant attack: if we need more reduction, take it immediately
  // Smooth release: let GR recover slowly
  needed_gr < this.gain_reduction ? (
    this.gain_reduction = needed_gr;
  ) : (
    this.gain_reduction = this.gain_reduction * this.rel_coeff
                        + needed_gr * (1 - this.rel_coeff);
  );

  // Write current input into lookahead buffer, read delayed output
  // This gives us 1ms to see peaks coming and reduce gain BEFORE they arrive
  out_l = this.la_buf[this.la_pos * 2];
  out_r = this.la_buf[this.la_pos * 2 + 1];
  this.la_buf[this.la_pos * 2] = l;
  this.la_buf[this.la_pos * 2 + 1] = r;
  this.la_pos = (this.la_pos + 1) % this.la_len;

  // Apply gain reduction to the delayed signal
  this.gr = this.gain_reduction;

  // Hard clip safety: absolutely nothing past ceiling (catches any residual)
  out_l *= this.gr;
  out_r *= this.gr;
  out_peak = max(abs(out_l), abs(out_r));
  out_peak > this.ceiling ? (
    hard_gr = this.ceiling / out_peak;
    out_l *= hard_gr;
    out_r *= hard_gr;
    this.gr *= hard_gr;
  );

  // Store clipped output for caller to read
  this.out_l = out_l;
  this.out_r = out_r;

  this.gr_db = 20 * log10(max(0.001, this.gr));

  // Metering (instant attack, 100ms release)
  this.gr_db < this.gr_meter ? (
    this.gr_meter = this.gr_db;
  ) : (
    this.gr_meter = this.gr_meter * this.gr_meter_rel + this.gr_db * (1 - this.gr_meter_rel);
  );
);


// ============================================================================
//  SECTION 12: Pitch Detection & Correction
//
//  Three independent subsystems:
//    A. YIN Pitch Detector   (mono, this.* state, buffer-based)
//    B. Dual-Tap Pitch Shifter (mono, this.* state, buffer-based)
//    C. Scale Snap Helper    (stateless)
//
//  A: YIN Pitch Detector
//    Detects fundamental frequency of monophonic audio (vocals, solo
//    instruments). Uses the YIN algorithm (de Cheveigne & Kawahara 2002):
//    cumulative mean normalized difference function with absolute
//    threshold and parabolic interpolation. Naturally resists octave
//    errors and provides a built-in confidence value.
//
//    Usage:
//      @init:   pd.lms_yin_init(buf_offset);
//                 // buf_offset = starting memory address for buffers
//                 // reserves ~4300 slots from buf_offset
//      @sample: pd.lms_yin_write(mono_sample);
//      @block:  pd.lms_yin_detect();
//                 // pd.freq        = detected frequency in Hz (0 if none)
//                 // pd.confidence  = 0.0-1.0 (higher = more periodic)
//                 // pd.midi_note   = float (e.g. 69.5 = A4+50 cents)
//                 // pd.midi_int    = integer MIDI note (nearest semitone)
//                 // pd.cents       = cents offset from nearest (-50 to +50)
//
//  B: Pitch-Synchronous Dual-Tap Shifter (PSOLA-inspired)
//    Shifts pitch using two crossfaded read pointers with grain size
//    locked to the detected pitch period. When a pointer resets, a
//    mini autocorrelation finds the best phase-match nearby, so
//    splices land on matching waveform positions — no comb filter,
//    no phase discontinuities. Falls back to fixed grain size when
//    no pitch is detected (e.g. consonants, silence).
//
//    Usage:
//      @init:   ps.lms_pshift_init(buf_offset);
//                 // reserves 4096 slots from buf_offset
//      @block:  ps.lms_pshift_set_period(srate / detected_freq);
//                 // tell the shifter the current pitch period in samples
//                 // pass 0 when no pitch is detected
//      @sample: out = ps.lms_pshift_proc(in, shift_ratio);
//                 // shift_ratio: 1.0 = no shift
//                 // > 1.0 = pitch up, < 1.0 = pitch down
//
//  C: Scale Snap
//    Snaps a frequency to the nearest note in a given musical scale.
//    Uses bitmask lookup — fast, no branching.
//
//    Usage:
//      target_hz = lms_snap_to_scale(freq_hz, root_note, scale_mask);
//        // root_note: 0=C, 1=C#, ... 11=B
//        // scale_mask: bitmask of active notes (see constants below)
//
//    Scale mask constants (set in your @init):
//      LMS_SCALE_CHROMATIC  = 4095   (0xFFF — all 12 notes)
//      LMS_SCALE_MAJOR      = 2741   (0xAB5 — W-W-H-W-W-W-H)
//      LMS_SCALE_MINOR      = 1453   (0x5AD — W-H-W-W-H-W-W)
// ============================================================================

// ---- Scale mask constants ----
LMS_SCALE_CHROMATIC  = 4095;
LMS_SCALE_MAJOR      = 2741;
LMS_SCALE_MINOR      = 1453;

// Pre-compute log(2) inverse for Hz-to-MIDI conversion
LMS_INV_LOG2 = 1.4426950408889634;

// ---- A: YIN Pitch Detector ----

// Initialize YIN detector. buf_offset = starting memory address.
// Reserves buf_offset to buf_offset+4299.
function lms_yin_init(buf_offset)
(
  // Circular audio buffer
  this.buf = buf_offset;
  this.buf_len = 2048;
  this.write_pos = 0;

  // YIN workspace
  this.yin = buf_offset + 2048;   // 601 slots (tau 0..600)

  // Linear workspace for analysis (avoids modulo in inner loop)
  this.lin = buf_offset + 2650;   // 1200 slots

  // Detection range (recompute if srate changes)
  this.tau_min = ceil(srate / 1000);  // ~1000 Hz max
  this.tau_max = ceil(srate / 80);    // ~80 Hz min
  this.W = 480;                       // integration window

  // YIN threshold (adjustable via slider in the plugin)
  this.threshold = 0.15;

  // Output state
  this.freq = 0;
  this.confidence = 0;
  this.midi_note = 0;
  this.midi_int = 0;
  this.cents = 0;

  // Smoothing state
  this.prev_freq = 0;
  this.smooth_alpha = 0.7;  // 0-1: higher = more responsive

  // Zero all buffers
  memset(this.buf, 0, this.buf_len);
  memset(this.yin, 0, 601);
  memset(this.lin, 0, 1200);
);

// Write one sample into the detector's circular buffer.
// Call once per sample in @sample.
function lms_yin_write(x)
(
  this.buf[this.write_pos] = x;
  this.write_pos = (this.write_pos + 1) % this.buf_len;
);

// Run YIN pitch detection. Call once per @block.
// Results available in this.freq, this.confidence, this.midi_note, etc.
function lms_yin_detect()
  local(start, k, tau, j, sum, running_sum, best_tau, best_val,
        min_val, s0, s1, s2, denom, refined_tau, raw_freq,
        midi_f, delta)
(
  // --- Copy circular buffer segment to linear workspace ---
  start = (this.write_pos - this.W - this.tau_max + this.buf_len * 2) % this.buf_len;
  k = 0;
  loop(this.W + this.tau_max,
    this.lin[k] = this.buf[(start + k) % this.buf_len];
    k += 1;
  );

  // --- Step 1: Difference function d(tau) ---
  tau = 0;
  loop(this.tau_max + 1,
    tau == 0 ? (
      this.yin[0] = 0;
    ) : (
      sum = 0;
      j = 0;
      loop(this.W,
        delta = this.lin[j] - this.lin[j + tau];
        sum += delta * delta;
        j += 1;
      );
      this.yin[tau] = sum;
    );
    tau += 1;
  );

  // --- Step 2: Cumulative Mean Normalized Difference ---
  this.yin[0] = 1;
  running_sum = 0;
  tau = 1;
  loop(this.tau_max,
    running_sum += this.yin[tau];
    running_sum > 0 ? (
      this.yin[tau] = this.yin[tau] * tau / running_sum;
    ) : (
      this.yin[tau] = 1;
    );
    tau += 1;
  );

  // --- Step 3: Absolute threshold search ---
  best_tau = -1;
  best_val = 1;
  tau = this.tau_min;
  while (tau <= this.tau_max && best_tau < 0) (
    this.yin[tau] < this.threshold ? (
      // Walk forward to local minimum of this dip
      while (tau + 1 <= this.tau_max && this.yin[tau + 1] < this.yin[tau]) (
        tau += 1;
      );
      best_tau = tau;
      best_val = this.yin[tau];
    ) : (
      tau += 1;
    );
  );

  // Fallback: global minimum if nothing crossed threshold
  best_tau < 0 ? (
    min_val = 2;
    tau = this.tau_min;
    loop(this.tau_max - this.tau_min + 1,
      this.yin[tau] < min_val ? (
        min_val = this.yin[tau];
        best_tau = tau;
        best_val = min_val;
      );
      tau += 1;
    );
  );

  // --- Step 4: Parabolic interpolation ---
  refined_tau = best_tau;
  best_tau > this.tau_min && best_tau < this.tau_max ? (
    s0 = this.yin[best_tau - 1];
    s1 = this.yin[best_tau];
    s2 = this.yin[best_tau + 1];
    denom = 2 * (2 * s1 - s2 - s0);
    abs(denom) > 0.0001 ? (
      refined_tau = best_tau + (s2 - s0) / denom;
    );
  );

  // --- Step 5: Confidence ---
  this.confidence = 1 - best_val;
  this.confidence < 0 ? this.confidence = 0;
  this.confidence > 1 ? this.confidence = 1;

  // --- Step 6: Frequency ---
  refined_tau > 0 ? (
    raw_freq = srate / refined_tau;
  ) : (
    raw_freq = 0;
    this.confidence = 0;
  );

  // Range check
  (raw_freq < 70 || raw_freq > 1100) ? (
    raw_freq = 0;
    this.confidence = 0;
  );

  // --- Step 7: Smoothing ---
  this.confidence > 0.5 && raw_freq > 0 ? (
    this.prev_freq > 0 ? (
      this.freq = this.smooth_alpha * raw_freq + (1 - this.smooth_alpha) * this.prev_freq;
    ) : (
      this.freq = raw_freq;
    );
    this.prev_freq = this.freq;
  ) : (
    this.freq = 0;
    // Don't reset prev_freq — resume smoothly when pitch returns
  );

  // --- Step 8: MIDI conversion ---
  this.freq > 0 ? (
    midi_f = 69 + 12 * log(this.freq / 440) * LMS_INV_LOG2;
    this.midi_note = midi_f;
    this.midi_int = floor(midi_f + 0.5);
    this.cents = (midi_f - this.midi_int) * 100;
  ) : (
    this.midi_note = 0;
    this.midi_int = 0;
    this.cents = 0;
  );
);


// ---- B: Dual-Tap Pitch Shifter ----

// Initialize pitch shifter. buf_offset = starting memory address.
// Reserves 4096 slots.
function lms_pshift_init(buf_offset)
(
  this.buf = buf_offset;
  this.buf_len = 4096;
  this.buf_mask = this.buf_len - 1;
  this.write_pos = 0;

  // Two read pointers offset by half buffer
  this.read_a = 0;
  this.read_b = this.buf_len * 0.5;

  // Crossfade phase (0.0 to 1.0)
  this.xfade_phase = 0;
  this.xfade_inc = 1.0 / this.buf_len;

  // Zero the buffer
  memset(this.buf, 0, this.buf_len);
);

// Set the detected pitch period (in samples). Call in @block.
// period = srate / detected_freq, or 0 if no pitch detected.
// When pitch is known, grain size adapts so each grain spans an
// integer number of pitch cycles. This reduces comb filtering
// because the two read taps see matching waveform shapes.
function lms_pshift_set_period(period)
  local(grain_periods)
(
  period > 20 && period < 800 ? (
    // Target grain = largest multiple of period that fits in buf_len/2.
    // This keeps grains long (smooth crossfade) while aligning to pitch.
    grain_periods = floor((this.buf_len * 0.5) / period);
    grain_periods < 2 ? grain_periods = 2;
    this.xfade_inc = 1.0 / (grain_periods * period);
  ) : (
    // No pitch — full buffer grain (original behavior)
    this.xfade_inc = 1.0 / this.buf_len;
  );
);

// Process one sample through the pitch shifter.
// ratio: playback speed ratio (1.0 = no shift, >1 = up, <1 = down)
// Returns the pitch-shifted output sample.
function lms_pshift_proc(x, ratio)
  local(prev_phase, w, win_a, win_b, out_a, out_b)
(
  // Write input to circular buffer
  this.buf[this.write_pos] = x;

  // Advance crossfade phase
  prev_phase = this.xfade_phase;
  this.xfade_phase += this.xfade_inc;
  this.xfade_phase >= 1.0 ? this.xfade_phase -= 1.0;

  // Sin^2 / Cos^2 crossfade windows (sum to 1.0)
  w = sin($pi * this.xfade_phase);
  win_a = w * w;
  win_b = 1.0 - win_a;

  // Advance read pointers at shifted rate
  this.read_a += ratio;
  this.read_b += ratio;
  this.read_a >= this.buf_len ? this.read_a -= this.buf_len;
  this.read_a < 0 ? this.read_a += this.buf_len;
  this.read_b >= this.buf_len ? this.read_b -= this.buf_len;
  this.read_b < 0 ? this.read_b += this.buf_len;

  // Reset pointer A when its window crosses zero (phase wraps past 1.0)
  prev_phase > 0.95 && this.xfade_phase < 0.05 ? (
    this.read_a = this.write_pos - this.buf_len * 0.5;
    this.read_a < 0 ? this.read_a += this.buf_len;
  );

  // Reset pointer B when its window crosses zero (phase crosses 0.5)
  prev_phase < 0.5 && this.xfade_phase >= 0.5 ? (
    this.read_b = this.write_pos - this.buf_len * 0.5;
    this.read_b < 0 ? this.read_b += this.buf_len;
  );

  // Read with cubic interpolation
  out_a = lms_interp_cubic(this.buf, this.read_a, this.buf_len);
  out_b = lms_interp_cubic(this.buf, this.read_b, this.buf_len);

  // Advance write pointer
  this.write_pos = (this.write_pos + 1) & this.buf_mask;

  // Crossfaded output
  win_a * out_a + win_b * out_b;
);


// ---- C: Scale Snap ----

// Snap a frequency to the nearest note in the given scale.
// freq: input frequency in Hz
// root: root note (0=C, 1=C#, ... 11=B)
// scale_mask: bitmask of active scale degrees (e.g. LMS_SCALE_MAJOR)
// Returns the target frequency in Hz.
function lms_snap_to_scale(freq, root, scale_mask)
  local(midi_f, rounded, best, best_dist, i, candidate, note_class, dist)
(
  midi_f = 69 + 12 * log(freq / 440) * LMS_INV_LOG2;
  rounded = floor(midi_f + 0.5);

  best = rounded;
  best_dist = 100;

  i = -2;
  loop(5,
    candidate = rounded + i;
    note_class = (candidate - root + 120) % 12;
    // Check if this note is in the scale
    (floor(scale_mask / (2 ^ note_class)) % 2) == 1 ? (
      dist = abs(midi_f - candidate);
      dist < best_dist ? (
        best_dist = dist;
        best = candidate;
      );
    );
    i += 1;
  );

  // Convert back to Hz
  440 * (2 ^ ((best - 69) / 12));
);


// ============================================================================
//  SECTION 13: Cabinet Simulation (density-aware speaker + mic sim)
//
//  Provides: preset table, preset loading, speaker breakup, cab bypass.
//  Each cab instance maintains up to 8 biquad bands + breakup state.
//
//  7 real-world cabinet models extracted from LMS amp sims, now shared
//  and selectable from any amp. Speaker breakup is density-driven:
//  harder playing compresses the cone, darkens the top end, and excites
//  cabinet resonance — exactly like a real speaker under load.
//
//  Usage:
//    @init:
//      lms_cab_table_init();                    // once — populates preset table
//      cab.lms_cab_init();                      // per-instance
//    @slider / @block:
//      cab.lms_cab_set(preset_id);              // 0-7 (0=off)
//    @sample:
//      x = cab.lms_cab_proc(x, density);        // density from triode tracker
// ============================================================================

// ---- Cab constants ----
CAB_MAX_BANDS    = 8;    // Mesa V30 uses all 8
CAB_BAND_STRIDE  = 4;    // (type, freq, param1, param2)
CAB_PRESET_SIZE  = 34;   // 2 header + 8*4 band data
CAB_PRESET_COUNT = 12;   // 0=Off + 11 cabs
CAB_TABLE_BASE   = 800000;

// Band types
CAB_BT_NONE = 0;
CAB_BT_HP   = 1;
CAB_BT_LP   = 2;
CAB_BT_PK   = 3;

// ---- Populate the global cab preset table in memory. Call once per @init. ----
function lms_cab_table_init()
  local(p, b)
(
  // ---- Preset 0: OFF (bypass) ----
  p = CAB_TABLE_BASE + 0 * CAB_PRESET_SIZE;
  p[0] = 0;     // band_count = 0
  p[1] = 0;     // breakup_freq = 0

  // ---- Preset 1: 1x12 Greenback Open (Frenchie) ----
  p = CAB_TABLE_BASE + 1 * CAB_PRESET_SIZE;
  p[0] = 6; p[1] = 3000;
  b = p + 2;
  b[0]=1; b[1]=100;  b[2]=0.50; b[3]=0;       // HP 100Hz
  b[4]=3; b[5]=700;  b[6]=2.0;  b[7]=1.2;     // PK 700Hz +2dB
  b[8]=3; b[9]=1600; b[10]=-3.0; b[11]=0.8;   // PK 1600Hz -3dB
  b[12]=3; b[13]=3000; b[14]=4.0; b[15]=1.5;  // PK 3000Hz +4dB (cone breakup)
  b[16]=2; b[17]=5500; b[18]=0.60; b[19]=0;   // LP 5500Hz
  b[20]=3; b[21]=90; b[22]=2.0; b[23]=2.5;    // RES 90Hz +2dB (open-back)

  // ---- Preset 2: 1x12 Jensen C12N Open (Deluxe) ----
  p = CAB_TABLE_BASE + 2 * CAB_PRESET_SIZE;
  p[0] = 6; p[1] = 2500;
  b = p + 2;
  b[0]=1; b[1]=65;   b[2]=0.75; b[3]=0;       // HP 65Hz
  b[4]=3; b[5]=95;   b[6]=2.2;  b[7]=1.9;     // PK 95Hz +2.2dB
  b[8]=3; b[9]=650;  b[10]=-2.5; b[11]=0.75;  // PK 650Hz -2.5dB
  b[12]=3; b[13]=2500; b[14]=2.5; b[15]=1.2;  // PK 2500Hz +2.5dB (cone breakup)
  b[16]=2; b[17]=5500; b[18]=0.65; b[19]=0;   // LP 5500Hz
  b[20]=3; b[21]=100; b[22]=1.8; b[23]=1.8;   // RES 100Hz +1.8dB (open-back)

  // ---- Preset 3: 1x12 Alnico Blue Open (AC15) ----
  p = CAB_TABLE_BASE + 3 * CAB_PRESET_SIZE;
  p[0] = 7; p[1] = 2500;
  b = p + 2;
  b[0]=1; b[1]=100;  b[2]=0.50; b[3]=0;       // HP 100Hz
  b[4]=3; b[5]=200;  b[6]=2.0;  b[7]=1.0;     // PK 200Hz +2dB
  b[8]=3; b[9]=800;  b[10]=-2.0; b[11]=1.2;   // PK 800Hz -2dB
  b[12]=3; b[13]=2500; b[14]=4.0; b[15]=1.8;  // PK 2500Hz +4dB (cone breakup)
  b[16]=3; b[17]=4500; b[18]=-3.0; b[19]=1.0; // PK 4500Hz -3dB
  b[20]=2; b[21]=5500; b[22]=0.55; b[23]=0;   // LP 5500Hz
  b[24]=3; b[25]=180; b[26]=1.5; b[27]=2.0;   // RES 180Hz +1.5dB (open-back)

  // ---- Preset 4: 2x12 Jensen C12N Open (Twin) ----
  p = CAB_TABLE_BASE + 4 * CAB_PRESET_SIZE;
  p[0] = 6; p[1] = 2800;
  b = p + 2;
  b[0]=1; b[1]=60;   b[2]=0.70; b[3]=0;       // HP 60Hz
  b[4]=3; b[5]=90;   b[6]=2.5;  b[7]=2.0;     // PK 90Hz +2.5dB
  b[8]=3; b[9]=600;  b[10]=-2.0; b[11]=0.8;   // PK 600Hz -2dB
  b[12]=3; b[13]=2800; b[14]=3.0; b[15]=1.3;  // PK 2800Hz +3dB (cone breakup)
  b[16]=2; b[17]=6000; b[18]=0.65; b[19]=0;   // LP 6000Hz
  b[20]=3; b[21]=90; b[22]=2.0; b[23]=2.0;    // RES 90Hz +2dB (open-back)

  // ---- Preset 5: 4x12 G12T-75 Closed (Marshall) ----
  p = CAB_TABLE_BASE + 5 * CAB_PRESET_SIZE;
  p[0] = 6; p[1] = 3500;
  b = p + 2;
  b[0]=1; b[1]=80;   b[2]=0.55; b[3]=0;       // HP 80Hz
  b[4]=3; b[5]=100;  b[6]=3.0;  b[7]=1.8;     // PK 100Hz +3dB
  b[8]=3; b[9]=1200; b[10]=-4.0; b[11]=0.9;   // PK 1200Hz -4dB (mid scoop)
  b[12]=3; b[13]=3500; b[14]=5.0; b[15]=1.4;  // PK 3500Hz +5dB (cone breakup)
  b[16]=2; b[17]=6500; b[18]=0.65; b[19]=0;   // LP 6500Hz
  b[20]=3; b[21]=110; b[22]=1.5; b[23]=3.0;   // RES 110Hz +1.5dB (closed-back)

  // ---- Preset 6: 4x12 V30 Closed (Mesa) ----
  p = CAB_TABLE_BASE + 6 * CAB_PRESET_SIZE;
  p[0] = 8; p[1] = 4000;
  b = p + 2;
  b[0]=1; b[1]=85;   b[2]=0.58; b[3]=0;       // HP 85Hz
  b[4]=3; b[5]=105;  b[6]=2.5;  b[7]=2.2;     // PK 105Hz +2.5dB
  b[8]=3; b[9]=350;  b[10]=-2.0; b[11]=0.8;   // PK 350Hz -2dB (closed-back scoop)
  b[12]=3; b[13]=800; b[14]=-3.0; b[15]=0.7;  // PK 800Hz -3dB (V30 voice coil dip)
  b[16]=3; b[17]=2200; b[18]=2.0; b[19]=1.5;  // PK 2200Hz +2dB (Mesa bark)
  b[20]=3; b[21]=4000; b[22]=6.0; b[23]=1.6;  // PK 4000Hz +6dB (V30 cone breakup)
  b[24]=2; b[25]=7000; b[26]=0.68; b[27]=0;   // LP 7000Hz
  b[28]=3; b[29]=120; b[30]=1.5; b[31]=3.0;   // RES 120Hz +1.5dB (closed-back)

  // ---- Preset 7: 8x10 Sealed (Ampeg SVT) ----
  p = CAB_TABLE_BASE + 7 * CAB_PRESET_SIZE;
  p[0] = 7; p[1] = 1800;
  b = p + 2;
  b[0]=1; b[1]=40;   b[2]=0.45; b[3]=0;       // HP 40Hz (deep extension)
  b[4]=3; b[5]=80;   b[6]=4.0;  b[7]=1.2;     // PK 80Hz +4dB (low-end thump)
  b[8]=3; b[9]=400;  b[10]=-3.0; b[11]=0.8;   // PK 400Hz -3dB (SVT mid scoop)
  b[12]=3; b[13]=1800; b[14]=3.0; b[15]=1.5;  // PK 1800Hz +3dB (upper-mid grind)
  b[16]=3; b[17]=2800; b[18]=-2.0; b[19]=1.0; // PK 2800Hz -2dB (presence dip)
  b[20]=2; b[21]=4000; b[22]=0.55; b[23]=0;   // LP 4000Hz (early rolloff)
  b[24]=3; b[25]=60; b[26]=1.5; b[27]=3.0;    // RES 60Hz +1.5dB (sealed air spring)

  // ---- Preset 8: 4x12 Sheffield 1200 Closed (5150) ----
  p = CAB_TABLE_BASE + 8 * CAB_PRESET_SIZE;
  p[0] = 7; p[1] = 3200;
  b = p + 2;
  b[0]=1; b[1]=75;   b[2]=0.55; b[3]=0;       // HP 75Hz (tight closed-back)
  b[4]=3; b[5]=100;  b[6]=2.8;  b[7]=2.0;     // PK 100Hz +2.8dB (cab thump)
  b[8]=3; b[9]=500;  b[10]=-2.5; b[11]=0.9;   // PK 500Hz -2.5dB (boxiness scoop)
  b[12]=3; b[13]=1500; b[14]=-1.5; b[15]=1.0;  // PK 1500Hz -1.5dB (honk reduction)
  b[16]=3; b[17]=3200; b[18]=4.5; b[19]=1.5;  // PK 3200Hz +4.5dB (cone breakup bite)
  b[20]=2; b[21]=6000; b[22]=0.60; b[23]=0;   // LP 6000Hz (smooth top)
  b[24]=3; b[25]=100; b[26]=1.8; b[27]=3.0;   // RES 100Hz +1.8dB (closed-back, tight)

  // ---- Preset 9: 1x15 Open (Bassman) ----
  p = CAB_TABLE_BASE + 9 * CAB_PRESET_SIZE;
  p[0] = 7; p[1] = 1200;
  b = p + 2;
  b[0]=1; b[1]=35;   b[2]=0.45; b[3]=0;       // HP 35Hz (deep 15" extension)
  b[4]=3; b[5]=80;   b[6]=3.5;  b[7]=1.5;     // PK 80Hz +3.5dB (fundamental thump)
  b[8]=3; b[9]=250;  b[10]=-2.0; b[11]=0.8;   // PK 250Hz -2dB (boxiness scoop)
  b[12]=3; b[13]=600; b[14]=-1.5; b[15]=1.0;  // PK 600Hz -1.5dB (mid scoop, 15" character)
  b[16]=3; b[17]=1200; b[18]=2.5; b[19]=1.5;  // PK 1200Hz +2.5dB (cone breakup, lower than 10"/12")
  b[20]=2; b[21]=3500; b[22]=0.50; b[23]=0;   // LP 3500Hz (early rolloff, big cone)
  b[24]=3; b[25]=70; b[26]=2.5; b[27]=2.0;    // RES 70Hz +2.5dB (open-back bloom)

  // ---- Preset 10: 4x10 Sealed (Orange OBC410 / bass cab) ----
  // Sealed 4x10: punchy, focused, fast transients. 10" speakers roll off early.
  // Classic bass cab tone — tight low end, midrange punch, no flub.
  p = CAB_TABLE_BASE + 10 * CAB_PRESET_SIZE;
  p[0] = 7; p[1] = 1200;
  b = p + 2;
  b[0]=1; b[1]=50;   b[2]=0.50; b[3]=0;       // HP 50Hz (sealed cab, tighter than ported)
  b[4]=3; b[5]=100;  b[6]=3.0;  b[7]=1.2;     // PK 100Hz +3dB (fundamental punch)
  b[8]=3; b[9]=250;  b[10]=2.0; b[11]=0.8;    // PK 250Hz +2dB (midrange body, 10" character)
  b[12]=3; b[13]=800; b[14]=-1.5; b[15]=1.0;  // PK 800Hz -1.5dB (slight boxiness scoop)
  b[16]=3; b[17]=2000; b[18]=2.0; b[19]=1.5;  // PK 2kHz +2dB (attack/presence from 10" cones)
  b[20]=2; b[21]=4500; b[22]=0.55; b[23]=0;   // LP 4500Hz (10" speakers roll off early)
  b[24]=3; b[25]=90; b[26]=3.0; b[27]=2.5;    // RES 90Hz +3dB (sealed cab resonance, tight)

  // ---- Preset 11: Orange PPC412 (closed-back 4x12, V30s, Orange voicing) ----
  // THE Orange cabinet. Closed-back birch ply, Celestion V30s.
  // Compared to generic V30 cab: more low-mid focus, pronounced 1-2kHz bark,
  // tighter bass from closed back, warmer top end. The Orange "voice".
  p = CAB_TABLE_BASE + 11 * CAB_PRESET_SIZE;
  p[0] = 7; p[1] = 1200;
  b = p + 2;
  b[0]=1; b[1]=70;   b[2]=0.55; b[3]=0;       // HP 70Hz (closed-back, tight)
  b[4]=3; b[5]=120;  b[6]=2.5;  b[7]=1.5;     // PK 120Hz +2.5dB (closed-back low-end punch)
  b[8]=3; b[9]=350;  b[10]=2.0; b[11]=0.7;    // PK 350Hz +2dB (Orange low-mid thickness)
  b[12]=3; b[13]=700; b[14]=-1.0; b[15]=1.0;  // PK 700Hz -1dB (mild boxiness scoop)
  b[16]=3; b[17]=1500; b[18]=3.0; b[19]=1.8;  // PK 1.5kHz +3dB (the Orange BARK — V30 cone breakup in birch ply)
  b[20]=2; b[21]=5500; b[22]=0.55; b[23]=0;   // LP 5500Hz (V30 rolloff, slightly warmer than open-back)
  b[24]=3; b[25]=110; b[26]=2.0; b[27]=2.0;   // RES 110Hz +2dB (closed-back resonance, focused)
);


// ---- Impedance ratings per cab preset (ohms). ----
// Returns the nominal impedance for a given cab preset.
function lms_cab_get_ohms(preset_id)
  local(ohms)
(
  ohms = 8;  // fallback
  preset_id == 0  ? ohms = 0;   // Off — no load
  preset_id == 1  ? ohms = 16;  // 1x12 Greenback (Celestion G12M)
  preset_id == 2  ? ohms = 8;   // 1x12 Jensen C12N
  preset_id == 3  ? ohms = 16;  // 1x12 Alnico Blue (Celestion Blue)
  preset_id == 4  ? ohms = 8;   // 2x12 Jensen (two 16 parallel)
  preset_id == 5  ? ohms = 16;  // 4x12 G12T-75 (Marshall)
  preset_id == 6  ? ohms = 8;   // 4x12 V30 (Mesa Recto cab)
  preset_id == 7  ? ohms = 4;   // 8x10 Sealed (SVT 810)
  preset_id == 8  ? ohms = 16;  // 4x12 Sheffield (5150 cab)
  preset_id == 9  ? ohms = 8;   // 1x15 Open (Bassman)
  preset_id == 10 ? ohms = 8;   // 4x10 Sealed (Orange OBC410)
  preset_id == 11 ? ohms = 16;  // Orange PPC412
  ohms;
);

// ---- Compute combined load impedance for one or two cabs. ----
// Two cabs in parallel: Z = (Za * Zb) / (Za + Zb)
// Returns 0 if no cabs are active.
function lms_cab_compute_load(ohms_a, ohms_b)
  local(load)
(
  ohms_a > 0 && ohms_b > 0 ? (
    load = (ohms_a * ohms_b) / (ohms_a + ohms_b);
  ) : ohms_a > 0 ? (
    load = ohms_a;
  ) : ohms_b > 0 ? (
    load = ohms_b;
  ) : (
    load = 0;
  );
  load;
);


// ---- Initialize a cab instance — zero all biquad state, set to bypass. ----
function lms_cab_init()
(
  // 8 static EQ biquads
  this.b1.lms_bq_init(); this.b2.lms_bq_init();
  this.b3.lms_bq_init(); this.b4.lms_bq_init();
  this.b5.lms_bq_init(); this.b6.lms_bq_init();
  this.b7.lms_bq_init(); this.b8.lms_bq_init();

  // Breakup: bandpass extractor + dynamic LP + dynamic resonance
  this.brk_bp.lms_bq_init();
  this.brk_lp.lms_bq_init();
  this.brk_res.lms_bq_init();

  // Mic position: hi-shelf (off-axis darkening) + lo-shelf (proximity rolloff)
  this.mic_hi.lms_bq_init();
  this.mic_lo.lms_bq_init();
  this.cab_mic_pos = -1;  // force first set

  // Breakup envelope state
  this.brk_env = 0;
  this.brk_att = exp(-1 / (srate * 0.001));   // 1ms attack
  this.brk_rel = exp(-1 / (srate * 0.030));   // 30ms release

  // Tracking state
  this.cab_current_preset = -1;  // force first set
  this.cab_band_count = 0;
  this.cab_breakup_freq = 0;
  this.cab_lp_base_freq = 6000;
  this.cab_lp_base_q = 0.65;
  this.cab_res_base_freq = 100;
  this.cab_res_base_gain = 1.5;
  this.cab_res_base_q = 2.0;
  this.last_dyn_lp_freq = 0;
  this.last_dyn_res_gain = 0;
);


// ---- Internal: configure one biquad from preset band data ----
function lms_cab_set_band(btype, freq, param1, param2)
(
  btype == CAB_BT_HP ? (
    this.lms_bq_set_hp(freq, param1);
  ) : btype == CAB_BT_LP ? (
    this.lms_bq_set_lp(freq, param1);
  ) : btype == CAB_BT_PK ? (
    this.lms_bq_set_peak(freq, param1, param2);
  ) : (
    // passthrough (CAB_BT_NONE or unknown)
    this.b0 = 1; this.b1 = 0; this.b2 = 0;
    this.a1 = 0; this.a2 = 0;
  );
);


// ---- Load preset into this instance's biquads. ----
// preset_id: 0=bypass, 1-7=cab voicing
function lms_cab_set(preset_id)
  local(p, b, bc, btype, freq, param1, param2, i, lp_found)
(
  preset_id != this.cab_current_preset ? (
    this.cab_current_preset = preset_id;

    // Reset to passthrough
    this.b1.lms_bq_init(); this.b2.lms_bq_init();
    this.b3.lms_bq_init(); this.b4.lms_bq_init();
    this.b5.lms_bq_init(); this.b6.lms_bq_init();
    this.b7.lms_bq_init(); this.b8.lms_bq_init();
    this.cab_band_count = 0;
    this.cab_breakup_freq = 0;

    preset_id > 0 && preset_id < CAB_PRESET_COUNT ? (
      p = CAB_TABLE_BASE + preset_id * CAB_PRESET_SIZE;
      bc = p[0];
      this.cab_band_count = bc;
      this.cab_breakup_freq = p[1];
      b = p + 2;
      lp_found = 0;

      // Band 1
      bc >= 1 ? (
        btype = b[0]; freq = b[1]; param1 = b[2]; param2 = b[3];
        this.b1.lms_cab_set_band(btype, freq, param1, param2);
        btype == CAB_BT_LP ? ( this.cab_lp_base_freq = freq; this.cab_lp_base_q = param1; lp_found = 1; );
      );
      // Band 2
      bc >= 2 ? (
        btype = b[4]; freq = b[5]; param1 = b[6]; param2 = b[7];
        this.b2.lms_cab_set_band(btype, freq, param1, param2);
        btype == CAB_BT_LP ? ( this.cab_lp_base_freq = freq; this.cab_lp_base_q = param1; lp_found = 1; );
      );
      // Band 3
      bc >= 3 ? (
        btype = b[8]; freq = b[9]; param1 = b[10]; param2 = b[11];
        this.b3.lms_cab_set_band(btype, freq, param1, param2);
        btype == CAB_BT_LP ? ( this.cab_lp_base_freq = freq; this.cab_lp_base_q = param1; lp_found = 1; );
      );
      // Band 4
      bc >= 4 ? (
        btype = b[12]; freq = b[13]; param1 = b[14]; param2 = b[15];
        this.b4.lms_cab_set_band(btype, freq, param1, param2);
        btype == CAB_BT_LP ? ( this.cab_lp_base_freq = freq; this.cab_lp_base_q = param1; lp_found = 1; );
      );
      // Band 5
      bc >= 5 ? (
        btype = b[16]; freq = b[17]; param1 = b[18]; param2 = b[19];
        this.b5.lms_cab_set_band(btype, freq, param1, param2);
        btype == CAB_BT_LP ? ( this.cab_lp_base_freq = freq; this.cab_lp_base_q = param1; lp_found = 1; );
      );
      // Band 6
      bc >= 6 ? (
        btype = b[20]; freq = b[21]; param1 = b[22]; param2 = b[23];
        this.b6.lms_cab_set_band(btype, freq, param1, param2);
        btype == CAB_BT_LP ? ( this.cab_lp_base_freq = freq; this.cab_lp_base_q = param1; lp_found = 1; );
      );
      // Band 7
      bc >= 7 ? (
        btype = b[24]; freq = b[25]; param1 = b[26]; param2 = b[27];
        this.b7.lms_cab_set_band(btype, freq, param1, param2);
        btype == CAB_BT_LP ? ( this.cab_lp_base_freq = freq; this.cab_lp_base_q = param1; lp_found = 1; );
      );
      // Band 8
      bc >= 8 ? (
        btype = b[28]; freq = b[29]; param1 = b[30]; param2 = b[31];
        this.b8.lms_cab_set_band(btype, freq, param1, param2);
        btype == CAB_BT_LP ? ( this.cab_lp_base_freq = freq; this.cab_lp_base_q = param1; lp_found = 1; );
      );

      // Find the last PK band for resonance tracking (always last band)
      // Scan backwards for first PK
      bc >= 1 ? (
        i = bc - 1;
        btype = b[i * CAB_BAND_STRIDE];
        btype == CAB_BT_PK ? (
          this.cab_res_base_freq = b[i * CAB_BAND_STRIDE + 1];
          this.cab_res_base_gain = b[i * CAB_BAND_STRIDE + 2];
          this.cab_res_base_q = b[i * CAB_BAND_STRIDE + 3];
        );
      );

      // Configure breakup bandpass
      this.cab_breakup_freq > 0 ? (
        this.brk_bp.lms_bq_set_bp(this.cab_breakup_freq, 1.5);
      );

      // Init dynamic filters at base values
      lp_found ? (
        this.brk_lp.lms_bq_set_lp(this.cab_lp_base_freq, this.cab_lp_base_q);
        this.last_dyn_lp_freq = this.cab_lp_base_freq;
      );
      this.brk_res.lms_bq_set_peak(this.cab_res_base_freq, 0, this.cab_res_base_q);
      this.last_dyn_res_gain = 0;
    );
  );
);


// ---- Set mic position. 0=on-axis (bright), 100=off-axis (dark, distant). ----
// Off-axis: presence rolls off, proximity bass thins out.
// Zero latency — just recalculates two biquad coefficients.
function lms_cab_set_mic(mic_pos)
  local(norm, hi_cut, lo_cut)
(
  mic_pos != this.cab_mic_pos ? (
    this.cab_mic_pos = mic_pos;
    norm = mic_pos / 100;  // 0.0 to 1.0

    // Hi-shelf: 0dB on-axis, up to -6dB at 3kHz off-axis
    hi_cut = -norm * 6.0;
    hi_cut < -0.1 ? (
      this.mic_hi.lms_bq_set_hishelf(3000, hi_cut, 0.7);
    ) : (
      this.mic_hi.lms_bq_init();  // passthrough
    );

    // Lo-shelf: 0dB close, up to -3dB at 200Hz distant (proximity effect reversal)
    lo_cut = -norm * 3.0;
    lo_cut < -0.1 ? (
      this.mic_lo.lms_bq_set_loshelf(200, lo_cut, 0.7);
    ) : (
      this.mic_lo.lms_bq_init();  // passthrough
    );
  );
);


// ---- Process one sample through cab + speaker breakup. ----
// density: from the amp's triode density tracker (1.0-2.5 range)
// Returns processed sample, or passthrough if preset==0.
function lms_cab_proc(x, density)
  local(out, brk_band, brk_ax, brk_drive, brk_sat,
        dyn_lp_freq, dyn_res_gain)
(
  this.cab_band_count == 0 ? x : (
    out = x;

    // --- Speaker breakup: parallel saturation in cone breakup band ---
    this.cab_breakup_freq > 0 ? (
      brk_band = this.brk_bp.lms_bq_proc(out);

      // Envelope follower on breakup band
      brk_ax = abs(brk_band);
      brk_ax > this.brk_env ? (
        this.brk_env = this.brk_att * this.brk_env + (1 - this.brk_att) * brk_ax;
      ) : (
        this.brk_env = this.brk_rel * this.brk_env + (1 - this.brk_rel) * brk_ax;
      );

      // Density-scaled breakup drive
      brk_drive = 1.0 + (density - 1.0) * 2.0;
      brk_drive = max(1.0, min(4.0, brk_drive));

      // Soft saturate the breakup band, mix back as parallel harmonics
      brk_sat = lms_tanh(brk_band * brk_drive) - brk_band;
      out += brk_sat * 0.15;
    );

    // --- Static EQ chain (preset bands) ---
    this.cab_band_count >= 1 ? out = this.b1.lms_bq_proc(out);
    this.cab_band_count >= 2 ? out = this.b2.lms_bq_proc(out);
    this.cab_band_count >= 3 ? out = this.b3.lms_bq_proc(out);
    this.cab_band_count >= 4 ? out = this.b4.lms_bq_proc(out);
    this.cab_band_count >= 5 ? out = this.b5.lms_bq_proc(out);
    this.cab_band_count >= 6 ? out = this.b6.lms_bq_proc(out);
    this.cab_band_count >= 7 ? out = this.b7.lms_bq_proc(out);
    this.cab_band_count >= 8 ? out = this.b8.lms_bq_proc(out);

    // --- Dynamic LP: speaker gets darker when pushed ---
    dyn_lp_freq = this.cab_lp_base_freq - (density - 1.0) * this.cab_lp_base_freq * 0.25;
    dyn_lp_freq = max(this.cab_lp_base_freq * 0.60, min(this.cab_lp_base_freq, dyn_lp_freq));
    abs(dyn_lp_freq - this.last_dyn_lp_freq) > 20 ? (
      this.brk_lp.lms_bq_set_lp(dyn_lp_freq, this.cab_lp_base_q);
      this.last_dyn_lp_freq = dyn_lp_freq;
    );
    out = this.brk_lp.lms_bq_proc(out);

    // --- Dynamic resonance: cab resonance excited by excursion ---
    dyn_res_gain = (density - 1.0) * 2.0;
    dyn_res_gain = max(0, min(3.0, dyn_res_gain));
    abs(dyn_res_gain - this.last_dyn_res_gain) > 0.2 ? (
      this.brk_res.lms_bq_set_peak(this.cab_res_base_freq, dyn_res_gain, this.cab_res_base_q);
      this.last_dyn_res_gain = dyn_res_gain;
    );
    out = this.brk_res.lms_bq_proc(out);

    // --- Mic position: off-axis darkening + proximity rolloff ---
    out = this.mic_hi.lms_bq_proc(out);
    out = this.mic_lo.lms_bq_proc(out);

    out;
  );
);


// ---- GUI: Cab selector widget (8 options: Off + 7 cabs) ----
// Returns new value. Left-click cycles forward, right-click cycles back.
function lms_draw_cab_sel(mx, my, mw, mh, val)
(
  gfx_r = COL_BAR_BG_R; gfx_g = COL_BAR_BG_G; gfx_b = COL_BAR_BG_B;
  gfx_rect(mx, my, mw, mh);
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_rect(mx, my, mw, 1); gfx_rect(mx, my + mh - 1, mw, 1);
  gfx_rect(mx, my, 1, mh); gfx_rect(mx + mw - 1, my, 1, mh);
  gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
  gfx_setfont(1, "Arial", F_LABEL);
  gfx_x = mx + floor(5 * S); gfx_y = my + floor((mh - F_LABEL) / 2);
  gfx_drawstr("Cab A");
  gfx_r = COL_ACCENT_R; gfx_g = COL_ACCENT_G; gfx_b = COL_ACCENT_B;
  gfx_x = mx + mw - floor(90 * S); gfx_y = my + floor((mh - F_LABEL) / 2);
  val == 0 ? gfx_drawstr("Off");
  val == 1 ? gfx_drawstr("1x12 Greenback");
  val == 2 ? gfx_drawstr("1x12 Jensen");
  val == 3 ? gfx_drawstr("1x12 Blue");
  val == 4 ? gfx_drawstr("2x12 Jensen");
  val == 5 ? gfx_drawstr("4x12 G12T-75");
  val == 6 ? gfx_drawstr("4x12 V30");
  val == 7 ? gfx_drawstr("8x10 Sealed");
  val == 8 ? gfx_drawstr("4x12 Sheffield");
  val == 9 ? gfx_drawstr("1x15 Open");
  val == 10 ? gfx_drawstr("4x10 Sealed");
  val == 11 ? gfx_drawstr("Orange PPC412");
  (mouse_cap & 1) && !(last_cap & 1) &&
    mouse_x >= mx && mouse_x <= mx + mw &&
    mouse_y >= my && mouse_y <= my + mh ? (
      val = (val + 1) % CAB_PRESET_COUNT;
  );
  (mouse_cap & 2) && !(last_cap & 2) &&
    mouse_x >= mx && mouse_x <= mx + mw &&
    mouse_y >= my && mouse_y <= my + mh ? (
      val = val - 1; val < 0 ? val = CAB_PRESET_COUNT - 1;
  );
  val;
);


// ---- GUI: Cab B selector widget (same as Cab A but labeled "Cab B") ----
function lms_draw_cab_sel_b(mx, my, mw, mh, val)
(
  gfx_r = COL_BAR_BG_R; gfx_g = COL_BAR_BG_G; gfx_b = COL_BAR_BG_B;
  gfx_rect(mx, my, mw, mh);
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_rect(mx, my, mw, 1); gfx_rect(mx, my + mh - 1, mw, 1);
  gfx_rect(mx, my, 1, mh); gfx_rect(mx + mw - 1, my, 1, mh);
  gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
  gfx_setfont(1, "Arial", F_LABEL);
  gfx_x = mx + floor(5 * S); gfx_y = my + floor((mh - F_LABEL) / 2);
  gfx_drawstr("Cab B");
  gfx_r = COL_ACCENT_R; gfx_g = COL_ACCENT_G; gfx_b = COL_ACCENT_B;
  gfx_x = mx + mw - floor(90 * S); gfx_y = my + floor((mh - F_LABEL) / 2);
  val == 0 ? gfx_drawstr("Off");
  val == 1 ? gfx_drawstr("1x12 Greenback");
  val == 2 ? gfx_drawstr("1x12 Jensen");
  val == 3 ? gfx_drawstr("1x12 Blue");
  val == 4 ? gfx_drawstr("2x12 Jensen");
  val == 5 ? gfx_drawstr("4x12 G12T-75");
  val == 6 ? gfx_drawstr("4x12 V30");
  val == 7 ? gfx_drawstr("8x10 Sealed");
  val == 8 ? gfx_drawstr("4x12 Sheffield");
  val == 9 ? gfx_drawstr("1x15 Open");
  val == 10 ? gfx_drawstr("4x10 Sealed");
  val == 11 ? gfx_drawstr("Orange PPC412");
  (mouse_cap & 1) && !(last_cap & 1) &&
    mouse_x >= mx && mouse_x <= mx + mw &&
    mouse_y >= my && mouse_y <= my + mh ? (
      val = (val + 1) % CAB_PRESET_COUNT;
  );
  (mouse_cap & 2) && !(last_cap & 2) &&
    mouse_x >= mx && mouse_x <= mx + mw &&
    mouse_y >= my && mouse_y <= my + mh ? (
      val = val - 1; val < 0 ? val = CAB_PRESET_COUNT - 1;
  );
  val;
);


// ---- GUI: Compact chromatic tuner strip ----
// Draws note name + cents bar + frequency. Call from @gfx.
// freq, conf, midi_int, cents = smoothed display values from YIN detector.
// S = scale factor (from gfx_w / nominal_width).
function lms_draw_tuner(tx, ty, tw, th, freq, conf, midi_int, cents, S)
  local(note_class, octave, active, acc_abs, nr, ng, nb,
        cm_x, cm_w, cm_h, cm_cy, bar_frac, bar_x, bar_w,
        f_note, f_small, f_tiny, tick_x)
(
  f_note = max(10, floor(18 * S));
  f_small = max(7, floor(11 * S));
  f_tiny = max(7, floor(9 * S));

  // Background
  gfx_r = 0.06; gfx_g = 0.06; gfx_b = 0.08;
  gfx_rect(tx, ty, tw, th);
  gfx_r = 0.15; gfx_g = 0.15; gfx_b = 0.20;
  gfx_rect(tx, ty + th - 1, tw, 1);

  active = freq > 20 && conf > 0.3;

  // --- Note name (left side) ---
  note_class = midi_int % 12;
  octave = floor(midi_int / 12) - 1;

  active ? (
    acc_abs = abs(cents);
    acc_abs < 10 ? (
      nr = 0.25; ng = 0.80; nb = 0.50;  // green — in tune
    ) : acc_abs < 25 ? (
      nr = 0.95; ng = 0.78; nb = 0.35;  // gold — close
    ) : (
      nr = 0.95; ng = 0.45; nb = 0.15;  // orange — off
    );
  ) : (
    nr = 0.25; ng = 0.25; nb = 0.30;  // dim
  );

  gfx_r = nr; gfx_g = ng; gfx_b = nb;
  gfx_setfont(1, "Arial", f_note);
  gfx_x = tx + floor(6 * S); gfx_y = ty + floor((th - f_note) / 2);

  active ? (
    note_class == 0  ? gfx_drawstr("C");
    note_class == 1  ? gfx_drawstr("C#");
    note_class == 2  ? gfx_drawstr("D");
    note_class == 3  ? gfx_drawstr("D#");
    note_class == 4  ? gfx_drawstr("E");
    note_class == 5  ? gfx_drawstr("F");
    note_class == 6  ? gfx_drawstr("F#");
    note_class == 7  ? gfx_drawstr("G");
    note_class == 8  ? gfx_drawstr("G#");
    note_class == 9  ? gfx_drawstr("A");
    note_class == 10 ? gfx_drawstr("A#");
    note_class == 11 ? gfx_drawstr("B");
    gfx_setfont(1, "Arial", f_small);
    gfx_drawnumber(octave, 0);
  ) : (
    gfx_drawstr("--");
  );

  // --- Cents meter (center) ---
  cm_x = tx + floor(60 * S);
  cm_w = tw - floor(130 * S);
  cm_h = max(4, floor(8 * S));
  cm_cy = ty + floor((th - cm_h) / 2);

  // Meter background
  gfx_r = 0.10; gfx_g = 0.10; gfx_b = 0.13;
  gfx_rect(cm_x, cm_cy, cm_w, cm_h);

  // Center tick
  tick_x = cm_x + floor(cm_w / 2);
  gfx_r = 0.30; gfx_g = 0.30; gfx_b = 0.35;
  gfx_rect(tick_x, cm_cy, 1, cm_h);

  // Indicator bar
  active ? (
    bar_frac = cents / 50;  // -1 to +1
    bar_frac = max(-1, min(1, bar_frac));
    bar_frac >= 0 ? (
      bar_x = tick_x;
      bar_w = floor(bar_frac * cm_w / 2);
    ) : (
      bar_w = floor(-bar_frac * cm_w / 2);
      bar_x = tick_x - bar_w;
    );
    bar_w = max(1, bar_w);
    gfx_r = nr; gfx_g = ng; gfx_b = nb;
    gfx_rect(bar_x, cm_cy, bar_w, cm_h);

    // Bright center line when near zero
    acc_abs < 5 ? (
      gfx_r = 0.25; gfx_g = 0.95; gfx_b = 0.50;
      gfx_rect(tick_x - 1, cm_cy - 1, 3, cm_h + 2);
    );
  );

  // Cents labels
  gfx_setfont(1, "Arial", f_tiny);
  gfx_r = 0.30; gfx_g = 0.30; gfx_b = 0.35;
  gfx_x = cm_x; gfx_y = cm_cy - f_tiny - floor(1 * S);
  gfx_drawstr("-50");
  gfx_x = cm_x + cm_w - floor(16 * S); gfx_y = cm_cy - f_tiny - floor(1 * S);
  gfx_drawstr("+50");

  // --- Frequency readout (right side) ---
  gfx_setfont(1, "Arial", f_small);
  active ? (
    gfx_r = 0.50; gfx_g = 0.50; gfx_b = 0.55;
    gfx_x = tx + tw - floor(60 * S); gfx_y = ty + floor((th - f_small) / 2);
    gfx_drawnumber(freq, 1);
    gfx_drawstr(" Hz");
  ) : (
    gfx_r = 0.25; gfx_g = 0.25; gfx_b = 0.30;
    gfx_x = tx + tw - floor(48 * S); gfx_y = ty + floor((th - f_small) / 2);
    gfx_drawstr("--- Hz");
  );

  // "TUNER" label
  gfx_setfont(1, "Arial", f_tiny);
  gfx_r = 0.35; gfx_g = 0.35; gfx_b = 0.40;
  gfx_x = cm_x + floor(cm_w / 2) - floor(12 * S);
  gfx_y = cm_cy + cm_h + floor(1 * S);
  gfx_drawstr("TUNER");
);
