desc:LMS - Smart Gate (Density-Aware Noise Gate)
//tags: gate noise drum density-aware spatial
//author: LMS + Claude
//version: 1.0
//license: GPL-3.0
filename:0,shakebot_logo.png

import lms_core.jsfx-inc
options:gmem=DrumBanger

// Core
slider1:0<-12,12,0.1>-Input Gain (dB)
slider2:0<0,1,1{Single,Drum}>-Mode
slider3:50<0,100,1>-Gate Threshold (%)

// Gate envelope
slider4:5<0,20,0.1>-Pre-Open (ms)
slider5:50<10,500,1>-Hold (ms)
slider6:200<20,2000,1>-Release (ms)
slider7:-80<-80,0,1>-Range (dB)
slider16:2<0.1,10,0.1>-Fade In (ms)

// Density tuning
slider8:30<0,100,1>-Density Sensitivity (%)
slider9:50<0,100,1>-Hysteresis (%)

// Sidechain
slider10:80<20,500,1>-Sidechain HPF (Hz)

// Drum mode
slider11:0<0,3,1{Kick,Snare,Tom,OH}>-Drum Type
slider12:1<1,8,1>-Tom Distance (1=near snare)
slider13:60<0,100,1>-Bleed Reject (%)

// Output
slider14:0<-24,0,0.1>-Gate GR (dB)
slider15:100<0,100,1>-Mix (%)

@init

  // Density tracker (4-band spectral analysis from lms_core.jsfx-inc)
  hd.lms_opto_hd_init();

  // Sidechain HPF (removes rumble from gate sidechain)
  sc_hpf.lms_bq_init();
  sc_hpf.lms_bq_set_hp(80, 0.707);

  // Gate state
  gate_gain = 0.0;       // 0 = closed, 1 = open (smoothed)
  gate_state = 0;        // 0=CLOSED, 1=OPENING, 2=OPEN, 3=HOLD, 4=RELEASE
  hold_counter = 0;
  gate_env = 0;          // sidechain envelope
  gate_should_open = 0;
  gate_should_close = 0;

  // Look-ahead delay buffer (stereo, max 20ms)
  // The sidechain sees the signal NOW, but audio output is delayed
  // so the gate decision happens BEFORE the audio arrives
  LA_MAX = ceil(srate * 0.020);  // 20ms max
  LA_BUF_L = 850000;
  LA_BUF_R = 850000 + LA_MAX;
  memset(LA_BUF_L, 0, LA_MAX);
  memset(LA_BUF_R, 0, LA_MAX);
  la_pos = 0;
  la_samples = 0;

  // Monotonic sample counter (synced across all instances in same audio thread)
  sample_clock = 0;

  // Transient edge detection (for timestamp broadcast)
  was_above = 0;

  // Phase calibration state
  cal_state = 0;        // 0=IDLE, 1=ARMED, 2=DONE
  // cal_offset restored from @serialize — do NOT zero here
  cal_oh_slot = -1;     // first OH slot
  cal_oh_slot2 = -1;    // second OH slot (if stereo pair)
  cal_oh_seq = 0;       // OH1 transient sequence at arm time
  cal_oh_seq2 = 0;      // OH2 transient sequence at arm time
  cal_oh_count = 0;     // how many OHs found (1 or 2)
  cal_my_timestamp = 0;
  cal_oh_timestamp = 0;
  cal_armed_time = 0;
  cal_timeout = srate * 5;  // 5 second timeout
  cal_request_age = 0;

  // Phase correction delay buffer (stereo, max 10ms)
  PC_MAX = ceil(srate * 0.010);
  PC_BUF_L = 860000;
  PC_BUF_R = 860000 + PC_MAX;
  memset(PC_BUF_L, 0, PC_MAX);
  memset(PC_BUF_R, 0, PC_MAX);
  pc_pos = 0;
  pc_samples = 0;

  // Derived params
  in_gain = 1.0;
  mode = 0;
  gate_thresh = 0.25;
  fadein_coeff = 0;
  rel_coeff = 0;
  hold_samples = 0;
  range_lin = 0.0001;
  density_sens = 0.3;
  hysteresis_pct = 0.5;
  drum_type = 0;
  tom_distance = 1;
  bleed_reject = 0.6;
  mix = 1.0;

  // Drum mode peer state (populated in @block)
  peer_count = 0;
  peer_max_env = 0;
  peer_owner_type = -1;
  peer_owner_dist = 0;

  // GFX display state
  gfx_gate_gain = 0;
  gfx_density = 1.0;
  gfx_env = 0;
  gfx_eff_thresh = 0;
  gfx_smooth = 0.85;

  // Peer display (up to 8 peers for GFX)
  gfx_peer_type_0 = -1; gfx_peer_type_1 = -1; gfx_peer_type_2 = -1; gfx_peer_type_3 = -1;
  gfx_peer_type_4 = -1; gfx_peer_type_5 = -1; gfx_peer_type_6 = -1; gfx_peer_type_7 = -1;
  gfx_peer_open_0 = 0; gfx_peer_open_1 = 0; gfx_peer_open_2 = 0; gfx_peer_open_3 = 0;
  gfx_peer_open_4 = 0; gfx_peer_open_5 = 0; gfx_peer_open_6 = 0; gfx_peer_open_7 = 0;
  gfx_peer_dist_0 = 0; gfx_peer_dist_1 = 0; gfx_peer_dist_2 = 0; gfx_peer_dist_3 = 0;
  gfx_peer_dist_4 = 0; gfx_peer_dist_5 = 0; gfx_peer_dist_6 = 0; gfx_peer_dist_7 = 0;
  gfx_peer_slot_0 = -1; gfx_peer_slot_1 = -1; gfx_peer_slot_2 = -1; gfx_peer_slot_3 = -1;
  gfx_peer_slot_4 = -1; gfx_peer_slot_5 = -1; gfx_peer_slot_6 = -1; gfx_peer_slot_7 = -1;
  gfx_peer_thresh_0 = 50; gfx_peer_thresh_1 = 50; gfx_peer_thresh_2 = 50; gfx_peer_thresh_3 = 50;
  gfx_peer_thresh_4 = 50; gfx_peer_thresh_5 = 50; gfx_peer_thresh_6 = 50; gfx_peer_thresh_7 = 50;
  gfx_peer_phase_0 = 0; gfx_peer_phase_1 = 0; gfx_peer_phase_2 = 0; gfx_peer_phase_3 = 0;
  gfx_peer_phase_4 = 0; gfx_peer_phase_5 = 0; gfx_peer_phase_6 = 0; gfx_peer_phase_7 = 0;
  gfx_peer_ts_0 = 0; gfx_peer_ts_1 = 0; gfx_peer_ts_2 = 0; gfx_peer_ts_3 = 0;
  gfx_peer_ts_4 = 0; gfx_peer_ts_5 = 0; gfx_peer_ts_6 = 0; gfx_peer_ts_7 = 0;
  gfx_peer_seq_0 = 0; gfx_peer_seq_1 = 0; gfx_peer_seq_2 = 0; gfx_peer_seq_3 = 0;
  gfx_peer_seq_4 = 0; gfx_peer_seq_5 = 0; gfx_peer_seq_6 = 0; gfx_peer_seq_7 = 0;
  gfx_peer_count = 0;

  // Phase view state
  pv_open = 0;
  // Smoothed wobble values per peer (for animation)
  pv_wobble_0 = 1; pv_wobble_1 = 1; pv_wobble_2 = 1; pv_wobble_3 = 1;
  pv_wobble_4 = 1; pv_wobble_5 = 1; pv_wobble_6 = 1; pv_wobble_7 = 1;

  // Threshold popup state (right-click on peer row)
  tp_open = 0;
  tp_peer_idx = 0;
  tp_peer_slot = -1;
  tp_x = 0;
  tp_y = 0;
  tp_dragging = 0;

  notice_show = 0;
  buy_show = 0;

  // ============================================================
  // BROADCAST SYSTEM — Instance Registry
  // ============================================================
  BC_BASE = 100000;
  BC_MY_TYPE = 21;            // Smart Gate
  BC_SLOT_SIZE = 512;
  BC_MAX_INST = 32;
  BC_PARAM_COUNT = 13;        // sliders 1-13 (14 = read-only GR, 15 = mix applied locally)
  BC_MY_REGION = BC_BASE + BC_MY_TYPE * 16384;
  BC_STALE_TIMEOUT = 2;

  bc_my_id == 0 ? bc_my_id = floor(rand() * 1073741824) + 1;
  bc_my_slot = -1;
  bc_follow_slot = -1;
  bc_steal_pending = 0;
  bc_steal_target = 0;
  bc_panel_expanded = 0;
  bc_page = 0;
  bc_steal_mode = 0;
  bc_instance_count = 0;

  BC_STALE_HB = 840000;
  BC_STALE_CT = 840032;
  i = 0;
  loop(BC_MAX_INST,
    BC_STALE_HB[i] = -1;
    BC_STALE_CT[i] = 0;
    i += 1;
  );

  bc_i = 0;
  loop(BC_MAX_INST,
    bc_my_slot < 0 ? (
      sb = BC_MY_REGION + bc_i * BC_SLOT_SIZE;
      sid = gmem[sb + 1];
      (sid == 0 || sid == bc_my_id) ? (
        bc_my_slot = bc_i;
      );
    );
    bc_i += 1;
  );

  bc_my_slot >= 0 ? (
    sb = BC_MY_REGION + bc_my_slot * BC_SLOT_SIZE;
    gmem[sb + 0] = 0;
    gmem[sb + 1] = bc_my_id;
    gmem[sb + 2] = BC_MY_TYPE;
    gmem[sb + 3] = 0;
    gmem[sb + 4] = BC_PARAM_COUNT;
  );

@slider
  in_gain = lms_db2lin(slider1);
  mode = slider2;
  gate_thresh = (slider3 / 100) * (slider3 / 100);
  // Pre-open: how far ahead the gate opens (in samples, clamped to buffer size)
  la_samples = min(LA_MAX - 1, floor(srate * slider4 / 1000));
  // Tell REAPER about total latency (look-ahead + phase correction)
  pc_samples = mode == 1 && drum_type < 3 ? cal_offset : 0;
  pdc_delay = la_samples + pc_samples;
  pdc_top_ch = 2;
  // Fade-in: how fast the gate transitions from closed to open
  fadein_coeff = exp(-1 / (srate * max(0.1, slider16) / 1000));
  hold_samples = floor(srate * slider5 / 1000);
  rel_coeff = exp(-1 / (srate * slider6 / 1000));
  range_lin = lms_db2lin(slider7);
  density_sens = slider8 / 100;
  hysteresis_pct = slider9 / 100;
  sc_hpf.lms_bq_set_hp(slider10, 0.707);
  drum_type = slider11;
  tom_distance = slider12;
  bleed_reject = slider13 / 100;
  mix = slider15 / 100;

// ============================================================
// @BLOCK — Recalc, drum peer scan, broadcast
// ============================================================
@block
// ---- Recalculate from sliders ----
in_gain = lms_db2lin(slider1);
mode = slider2;
gate_thresh = (slider3 / 100) * (slider3 / 100);
la_samples = min(LA_MAX - 1, floor(srate * slider4 / 1000));
pc_samples = mode == 1 && drum_type < 3 ? cal_offset : 0;
pdc_delay = la_samples + pc_samples;
pdc_top_ch = 2;
fadein_coeff = exp(-1 / (srate * max(0.1, slider16) / 1000));
hold_samples = floor(srate * slider5 / 1000);
rel_coeff = exp(-1 / (srate * slider6 / 1000));
range_lin = lms_db2lin(slider7);
density_sens = slider8 / 100;
hysteresis_pct = slider9 / 100;
sc_hpf.lms_bq_set_hp(slider10, 0.707);
drum_type = slider11;
tom_distance = slider12;
bleed_reject = slider13 / 100;
mix = slider15 / 100;

// ---- Broadcast: slot ownership ----
bc_my_slot >= 0 ? (
  sb = BC_MY_REGION + bc_my_slot * BC_SLOT_SIZE;
  gmem[sb + 1] != bc_my_id ? (
    bc_my_id = floor(rand() * 1073741824) + 1;
    bc_my_slot = -1;
    bc_i = 0;
    loop(BC_MAX_INST,
      bc_my_slot < 0 ? (
        tsb = BC_MY_REGION + bc_i * BC_SLOT_SIZE;
        (gmem[tsb + 1] == 0) ? bc_my_slot = bc_i;
      );
      bc_i += 1;
    );
    bc_my_slot >= 0 ? (
      sb = BC_MY_REGION + bc_my_slot * BC_SLOT_SIZE;
      gmem[sb + 0] = 0;
      gmem[sb + 1] = bc_my_id;
      gmem[sb + 2] = BC_MY_TYPE;
      gmem[sb + 3] = bc_following;
      gmem[sb + 4] = BC_PARAM_COUNT;
    );
  );
);

// ---- Broadcast: follow ----
bc_my_slot >= 0 && bc_following > 0 ? (
  bc_found_leader = 0;
  bc_scan = 0;
  loop(BC_MAX_INST,
    bc_scan != bc_my_slot ? (
      lsb = BC_MY_REGION + bc_scan * BC_SLOT_SIZE;
      gmem[lsb + 1] == bc_following ? (
        bc_found_leader = 1;
        bc_follow_slot = bc_scan;
        lbase = lsb + 8;
        slider1  = gmem[lbase + 0];
        slider2  = gmem[lbase + 1];
        slider3  = gmem[lbase + 2];
        slider4  = gmem[lbase + 3];
        slider5  = gmem[lbase + 4];
        slider6  = gmem[lbase + 5];
        slider7  = gmem[lbase + 6];
        slider8  = gmem[lbase + 7];
        slider9  = gmem[lbase + 8];
        slider10 = gmem[lbase + 9];
        slider11 = gmem[lbase + 10];
        slider12 = gmem[lbase + 11];
        slider13 = gmem[lbase + 12];
        bc_scan = BC_MAX_INST;
      );
    );
    bc_scan += 1;
  );
  !bc_found_leader ? (
    bc_following = 0;
    bc_follow_slot = -1;
  );
);

// ---- Broadcast: steal ----
bc_my_slot >= 0 && bc_steal_pending ? (
  bc_scan = 0;
  loop(BC_MAX_INST,
    lsb = BC_MY_REGION + bc_scan * BC_SLOT_SIZE;
    gmem[lsb + 1] == bc_steal_target ? (
      lbase = lsb + 8;
      slider1  = gmem[lbase + 0];
      slider2  = gmem[lbase + 1];
      slider3  = gmem[lbase + 2];
      slider4  = gmem[lbase + 3];
      slider5  = gmem[lbase + 4];
      slider6  = gmem[lbase + 5];
      slider7  = gmem[lbase + 6];
      slider8  = gmem[lbase + 7];
      slider9  = gmem[lbase + 8];
      slider10 = gmem[lbase + 9];
      slider11 = gmem[lbase + 10];
      slider12 = gmem[lbase + 11];
      slider13 = gmem[lbase + 12];
      bc_scan = BC_MAX_INST;
    );
    bc_scan += 1;
  );
  bc_steal_pending = 0;
  bc_steal_target = 0;
  bc_steal_mode = 0;
);

// ---- Broadcast: heartbeat + param write ----
bc_my_slot >= 0 ? (
  sb = BC_MY_REGION + bc_my_slot * BC_SLOT_SIZE;
  gmem[sb + 0] += 1;
  gmem[sb + 3] = bc_following;
  pbase = sb + 8;
  gmem[pbase + 0]  = slider1;
  gmem[pbase + 1]  = slider2;
  gmem[pbase + 2]  = slider3;
  gmem[pbase + 3]  = slider4;
  gmem[pbase + 4]  = slider5;
  gmem[pbase + 5]  = slider6;
  gmem[pbase + 6]  = slider7;
  gmem[pbase + 7]  = slider8;
  gmem[pbase + 8]  = slider9;
  gmem[pbase + 9]  = slider10;
  gmem[pbase + 10] = slider11;
  gmem[pbase + 11] = slider12;
  gmem[pbase + 12] = slider13;
);

// ---- Broadcast: drum mode state (always write so peers can see us) ----
bc_my_slot >= 0 ? (
  sb = BC_MY_REGION + bc_my_slot * BC_SLOT_SIZE;
  ebase = sb + 200;
  gmem[ebase + 0] = drum_type;
  gmem[ebase + 1] = tom_distance;
  gmem[ebase + 2] = hd.env_total;
  gmem[ebase + 3] = hd.density;
  gmem[ebase + 4] = gate_gain > 0.5 ? 1 : 0;
  gmem[ebase + 5] = slider3;   // broadcast our threshold so peers can display it
  gmem[ebase + 11] = cal_offset; // broadcast our phase offset for peers to display

  // Check for remote threshold write from another instance
  // ebase+6 = flag (1 = pending write), ebase+7 = new threshold value
  gmem[ebase + 6] > 0 ? (
    slider3 = max(0, min(100, gmem[ebase + 7]));
    slider_automate(2^2);
    gmem[ebase + 6] = 0;  // clear the flag
  );

  // OH: clear calibration request after 2 blocks
  drum_type == 3 && gmem[ebase + 10] > 0 ? (
    cal_request_age += 1;
    cal_request_age > 2 ? (
      gmem[ebase + 10] = 0;
      cal_request_age = 0;
    );
  );
);

// ---- Drum mode: scan peers ----
mode == 1 ? (
  peer_count = 0;
  peer_max_env = 0;
  peer_owner_type = -1;
  peer_owner_dist = 0;

  bc_scan = 0;
  loop(BC_MAX_INST,
    bc_scan != bc_my_slot ? (
      psb = BC_MY_REGION + bc_scan * BC_SLOT_SIZE;
      pid = gmem[psb + 1];
      pid > 0 ? (
        pbase = psb + 200;
        p_type = gmem[pbase + 0];
        p_dist = gmem[pbase + 1];
        p_env  = gmem[pbase + 2];
        p_dens = gmem[pbase + 3];
        p_open = gmem[pbase + 4];

        // Track strongest peer
        p_env > peer_max_env ? (
          peer_max_env = p_env;
          peer_owner_type = p_type;
          peer_owner_dist = p_dist;
        );

        // OH auto-arm: if an OH sent a calibration request, arm ourselves
        p_type == 3 && gmem[pbase + 10] > 0 ? (
          drum_type < 3 && cal_state == 0 ? (
            cal_state = 1;
            cal_oh_slot = bc_scan;
            cal_oh_seq = gmem[pbase + 9];
            cal_oh_slot2 = -1;
            cal_oh_seq2 = 0;
            cal_oh_count = 1;
            cal_my_seq = bc_my_slot >= 0 ? gmem[BC_MY_REGION + bc_my_slot * BC_SLOT_SIZE + 200 + 9] : 0;
            cal_armed_time = sample_clock;
          );
        );

        // Collect OH slots: first into slot, second into slot2
        cal_state == 1 && p_type == 3 ? (
          cal_oh_slot < 0 ? (
            cal_oh_slot = bc_scan;
            cal_oh_seq = gmem[pbase + 9];
            cal_oh_count = 1;
            cal_my_seq = bc_my_slot >= 0 ? gmem[BC_MY_REGION + bc_my_slot * BC_SLOT_SIZE + 200 + 9] : 0;
          ) : bc_scan != cal_oh_slot && cal_oh_slot2 < 0 ? (
            cal_oh_slot2 = bc_scan;
            cal_oh_seq2 = gmem[pbase + 9];
            cal_oh_count = 2;
          );
        );

        // Read peer's threshold + phase offset + transient data
        p_thresh = gmem[pbase + 5];
        p_phase = gmem[pbase + 11];
        p_ts = gmem[pbase + 8];
        p_seq = gmem[pbase + 9];

        // Store for GFX (up to 8 peers)
        peer_count == 0 ? (gfx_peer_type_0 = p_type; gfx_peer_open_0 = p_open; gfx_peer_dist_0 = p_dist; gfx_peer_slot_0 = bc_scan; gfx_peer_thresh_0 = p_thresh; gfx_peer_phase_0 = p_phase; gfx_peer_ts_0 = p_ts; gfx_peer_seq_0 = p_seq);
        peer_count == 1 ? (gfx_peer_type_1 = p_type; gfx_peer_open_1 = p_open; gfx_peer_dist_1 = p_dist; gfx_peer_slot_1 = bc_scan; gfx_peer_thresh_1 = p_thresh; gfx_peer_phase_1 = p_phase; gfx_peer_ts_1 = p_ts; gfx_peer_seq_1 = p_seq);
        peer_count == 2 ? (gfx_peer_type_2 = p_type; gfx_peer_open_2 = p_open; gfx_peer_dist_2 = p_dist; gfx_peer_slot_2 = bc_scan; gfx_peer_thresh_2 = p_thresh; gfx_peer_phase_2 = p_phase; gfx_peer_ts_2 = p_ts; gfx_peer_seq_2 = p_seq);
        peer_count == 3 ? (gfx_peer_type_3 = p_type; gfx_peer_open_3 = p_open; gfx_peer_dist_3 = p_dist; gfx_peer_slot_3 = bc_scan; gfx_peer_thresh_3 = p_thresh; gfx_peer_phase_3 = p_phase; gfx_peer_ts_3 = p_ts; gfx_peer_seq_3 = p_seq);
        peer_count == 4 ? (gfx_peer_type_4 = p_type; gfx_peer_open_4 = p_open; gfx_peer_dist_4 = p_dist; gfx_peer_slot_4 = bc_scan; gfx_peer_thresh_4 = p_thresh; gfx_peer_phase_4 = p_phase; gfx_peer_ts_4 = p_ts; gfx_peer_seq_4 = p_seq);
        peer_count == 5 ? (gfx_peer_type_5 = p_type; gfx_peer_open_5 = p_open; gfx_peer_dist_5 = p_dist; gfx_peer_slot_5 = bc_scan; gfx_peer_thresh_5 = p_thresh; gfx_peer_phase_5 = p_phase; gfx_peer_ts_5 = p_ts; gfx_peer_seq_5 = p_seq);
        peer_count == 6 ? (gfx_peer_type_6 = p_type; gfx_peer_open_6 = p_open; gfx_peer_dist_6 = p_dist; gfx_peer_slot_6 = bc_scan; gfx_peer_thresh_6 = p_thresh; gfx_peer_phase_6 = p_phase; gfx_peer_ts_6 = p_ts; gfx_peer_seq_6 = p_seq);
        peer_count == 7 ? (gfx_peer_type_7 = p_type; gfx_peer_open_7 = p_open; gfx_peer_dist_7 = p_dist; gfx_peer_slot_7 = bc_scan; gfx_peer_thresh_7 = p_thresh; gfx_peer_phase_7 = p_phase; gfx_peer_ts_7 = p_ts; gfx_peer_seq_7 = p_seq);

        peer_count += 1;
      );
    );
    bc_scan += 1;
  );
  gfx_peer_count = min(8, peer_count);
);

// ---- Broadcast: stale detection ----
bc_instance_count = 0;
bc_scan = 0;
loop(BC_MAX_INST,
  tsb = BC_MY_REGION + bc_scan * BC_SLOT_SIZE;
  tsid = gmem[tsb + 1];
  tsid > 0 ? (
    bc_scan == bc_my_slot ? (
      bc_instance_count += 1;
    ) : (
      tshb = gmem[tsb + 0];
      tshb == BC_STALE_HB[bc_scan] ? (
        BC_STALE_CT[bc_scan] += samplesblock / srate;
        BC_STALE_CT[bc_scan] > BC_STALE_TIMEOUT ? (
          gmem[tsb + 1] = 0;
          BC_STALE_CT[bc_scan] = 0;
        );
      ) : (
        BC_STALE_HB[bc_scan] = tshb;
        BC_STALE_CT[bc_scan] = 0;
        bc_instance_count += 1;
      );
    );
  );
  bc_scan += 1;
);

// ============================================================
// @SAMPLE — Density gate + drum inference + state machine
// ============================================================
@sample

  sample_clock += 1;

  dry_l = spl0; dry_r = spl1;
  l = spl0 * in_gain;
  r = spl1 * in_gain;

  // ---- LOOK-AHEAD BUFFER ----
  // Sidechain analyzes the signal NOW. Audio output is delayed by pre-open ms.
  // The gate decision happens BEFORE the audio arrives. "I saw it coming."
  // Write current sample into delay buffer
  LA_BUF_L[la_pos] = l;
  LA_BUF_R[la_pos] = r;
  // Read the delayed sample (la_samples behind)
  la_read = la_pos - la_samples;
  la_read < 0 ? la_read += LA_MAX;
  la_l = LA_BUF_L[la_read];
  la_r = LA_BUF_R[la_read];
  la_pos += 1;
  la_pos >= LA_MAX ? la_pos = 0;

  // Sidechain: mono sum → HPF → density tracker (runs on CURRENT signal, not delayed)
  sc_mono = (l + r) * 0.5;
  sc_mono = sc_hpf.lms_bq_proc(sc_mono);
  hd.lms_opto_hd_proc(sc_mono);

  // Sidechain envelope (instant attack, smooth release)
  sc_abs = abs(sc_mono);
  sc_abs > gate_env ? (
    gate_env = sc_abs;
  ) : (
    gate_env = rel_coeff * gate_env;
  );

  // ---- GATE DECISION ----
  // OH (drum_type==3) stays in drum mode for broadcasting but gates independently
  mode == 0 || (mode == 1 && drum_type == 3) ? (
    // SINGLE MODE or OH: density-weighted threshold, no peer cross-mic comparison
    density_factor = (hd.density - 1.0) / 1.5;
    density_factor = max(0, min(1, density_factor));
    effective_thresh = gate_thresh * (1.0 - density_sens * density_factor);

    gate_should_open = gate_env > effective_thresh;
    gate_should_close = gate_env < effective_thresh * (1 - hysteresis_pct);
  ) : (
    // DRUM MODE close mics: spatial inference with bleed rejection
    density_factor = (hd.density - 1.0) / 1.5;
    density_factor = max(0, min(1, density_factor));
    effective_thresh = gate_thresh * (1.0 - density_sens * density_factor);

    has_transient = gate_env > effective_thresh;

    // Cross-mic comparison
    peer_count > 0 && has_transient ? (
      my_env = max(0.0001, hd.env_total);
      ratio = my_env / max(0.0001, peer_max_env);

      // Distance weighting for toms
      drum_type == 2 ? (
        dist_factor = 1.0 / tom_distance;
        rej = bleed_reject * (1.0 - dist_factor * 0.3);
      ) : (
        rej = bleed_reject;
      );

      // Decision thresholds
      ratio > (1.0 - rej) ? (
        gate_should_open = 1;
      ) : ratio > 0.5 * (1.0 - rej) ? (
        gate_should_open = 1;
      ) : (
        gate_should_open = 0;
      );
    ) : (
      gate_should_open = has_transient;
    );
    gate_should_close = !gate_should_open && gate_env < effective_thresh * (1 - hysteresis_pct);
  );

  // Store effective threshold for GFX
  gfx_eff_thresh = effective_thresh;

  // ---- TRANSIENT TIMESTAMP BROADCAST ----
  // Detect rising edge: envelope just crossed above threshold
  mode == 1 && bc_my_slot >= 0 ? (
    above_now = gate_env > effective_thresh ? 1 : 0;
    above_now && !was_above ? (
      // New transient onset — broadcast timestamp
      ts_sb = BC_MY_REGION + bc_my_slot * BC_SLOT_SIZE + 200;
      gmem[ts_sb + 8] = sample_clock;   // transient timestamp
      gmem[ts_sb + 9] += 1;             // increment sequence counter
    );
    was_above = above_now;

    // ---- PHASE CALIBRATION MEASUREMENT ----
    cal_state == 1 && cal_oh_slot >= 0 ? (
      // Check for timeout
      (sample_clock - cal_armed_time) > cal_timeout ? (
        cal_state = 0;  // timed out
      ) : (
        // Check if OH1 fired a new transient
        oh_ebase = BC_MY_REGION + cal_oh_slot * BC_SLOT_SIZE + 200;
        oh_seq_now = gmem[oh_ebase + 9];
        oh_seq_now > cal_oh_seq ? (
          // OH1 fired! Did we also fire?
          my_ebase = BC_MY_REGION + bc_my_slot * BC_SLOT_SIZE + 200;
          my_seq_now = gmem[my_ebase + 9];
          my_seq_now > cal_my_seq ? (
            // Both fired — compute offset from OH1
            cal_oh_timestamp = gmem[oh_ebase + 8];
            cal_my_timestamp = gmem[my_ebase + 8];
            cal_off1 = cal_oh_timestamp - cal_my_timestamp;

            // Check OH2 if we have a stereo pair
            cal_oh_count == 2 && cal_oh_slot2 >= 0 ? (
              oh_ebase2 = BC_MY_REGION + cal_oh_slot2 * BC_SLOT_SIZE + 200;
              oh_seq_now2 = gmem[oh_ebase2 + 9];
              oh_seq_now2 > cal_oh_seq2 ? (
                // OH2 also fired — average both offsets
                cal_off2 = gmem[oh_ebase2 + 8] - cal_my_timestamp;
                cal_offset = ((cal_off1 + cal_off2) / 2 + 0.5) | 0;
              ) : (
                // OH2 hasn't fired yet — just use OH1
                cal_offset = cal_off1;
              );
            ) : (
              // Only one OH — use it directly
              cal_offset = cal_off1;
            );

            cal_offset = max(0, min(PC_MAX - 1, cal_offset));
            pc_samples = drum_type < 3 ? cal_offset : 0;
            cal_state = 2;  // DONE
          );
        );
      );
    );
  );

  // ---- GATE STATE MACHINE ----
  // 0=CLOSED, 1=OPENING (fade-in), 2=OPEN, 3=HOLD, 4=RELEASE
  // The gate decision runs on CURRENT signal. The audio is delayed by pre-open ms.
  // So when we decide to open, the gate is already fading in by the time the transient
  // arrives in the delayed audio. "I saw it coming."
  gate_state == 0 ? (
    gate_should_open ? gate_state = 1;
  ) : gate_state == 1 ? (
    // OPENING: fade from closed to open (fade-in time)
    gate_gain += (1.0 - gate_gain) * (1.0 - fadein_coeff);
    gate_gain >= 0.999 ? (gate_gain = 1.0; gate_state = 2);
  ) : gate_state == 2 ? (
    gate_gain = 1.0;
    gate_should_close ? (hold_counter = hold_samples; gate_state = 3);
  ) : gate_state == 3 ? (
    gate_gain = 1.0;
    hold_counter -= 1;
    gate_should_open ? gate_state = 2;
    hold_counter <= 0 ? gate_state = 4;
  ) : gate_state == 4 ? (
    gate_gain = gate_gain * rel_coeff + range_lin * (1 - rel_coeff);
    gate_should_open ? gate_state = 1;
    gate_gain <= range_lin + 0.0001 ? (gate_gain = range_lin; gate_state = 0);
  );

  // Apply gate to DELAYED audio (the gate opened pre-open ms ago, audio arrives now)
  gated_l = la_l * gate_gain;
  gated_r = la_r * gate_gain;

  // Mix (dry uses delayed signal too, so latency is consistent)
  spl0 = la_l * (1 - mix) + gated_l * mix;
  spl1 = la_r * (1 - mix) + gated_r * mix;

  // ---- PHASE CORRECTION DELAY ----
  // Delays close mic output to align with OH timing
  pc_samples > 0 ? (
    PC_BUF_L[pc_pos] = spl0;
    PC_BUF_R[pc_pos] = spl1;
    pc_read = pc_pos - pc_samples;
    pc_read < 0 ? pc_read += PC_MAX;
    spl0 = PC_BUF_L[pc_read];
    spl1 = PC_BUF_R[pc_read];
    pc_pos += 1;
    pc_pos >= PC_MAX ? pc_pos = 0;
  );

  // Metering
  slider14 = gate_gain > 0.001 ? 20 * log10(gate_gain) : -80;

  // Smooth GFX display
  gfx_gate_gain = gfx_gate_gain * gfx_smooth + gate_gain * (1 - gfx_smooth);
  gfx_density = gfx_density * gfx_smooth + hd.density * (1 - gfx_smooth);
  gfx_env = gfx_env * gfx_smooth + gate_env * (1 - gfx_smooth);

// ============================================================
// @GFX
// ============================================================
@gfx 560 430

// ============================================================================
//  SCALING
// ============================================================================
gfx_ext_retina > 0 ? gfx_ext_retina = 1;
S = gfx_w / 560;
S < 0.5 ? S = 0.5;

F_TITLE = max(10, floor(22 * S));
F_LABEL = max(8, floor(12 * S));
F_SMALL = max(7, floor(11 * S));
F_TINY  = max(7, floor(10 * S));

// ============================================================================
//  COLOR CONSTANTS
// ============================================================================
COL_BG_R = 0.04; COL_BG_G = 0.04; COL_BG_B = 0.06;
COL_PANEL_R = 0.08; COL_PANEL_G = 0.08; COL_PANEL_B = 0.11;
COL_PANEL_HI_R = 0.12; COL_PANEL_HI_G = 0.12; COL_PANEL_HI_B = 0.16;
COL_BORDER_R = 0.20; COL_BORDER_G = 0.20; COL_BORDER_B = 0.25;
COL_TITLE_R = 0.95; COL_TITLE_G = 0.78; COL_TITLE_B = 0.35;
COL_SEC_R = 0.55; COL_SEC_G = 0.50; COL_SEC_B = 0.40;
COL_TEXT_R = 0.78; COL_TEXT_G = 0.78; COL_TEXT_B = 0.82;
COL_DIM_R = 0.38; COL_DIM_G = 0.38; COL_DIM_B = 0.42;
COL_ACCENT_R = 0.95; COL_ACCENT_G = 0.45; COL_ACCENT_B = 0.15;
COL_GREEN_R = 0.25; COL_GREEN_G = 0.80; COL_GREEN_B = 0.50;
COL_CYAN_R = 0.20; COL_CYAN_G = 0.60; COL_CYAN_B = 0.85;
COL_BAR_BG_R = 0.12; COL_BAR_BG_G = 0.12; COL_BAR_BG_B = 0.16;

// ============================================================================
//  BACKGROUND
// ============================================================================
hdr_h = floor(44 * S);
gfx_r = COL_BG_R; gfx_g = COL_BG_G; gfx_b = COL_BG_B;
gfx_rect(0, 0, gfx_w, gfx_h);
gfx_r = 0.03; gfx_g = 0.03; gfx_b = 0.05;
gfx_rect(0, 0, gfx_w, hdr_h);
gfx_r = COL_TITLE_R * 0.6; gfx_g = COL_TITLE_G * 0.6; gfx_b = COL_TITLE_B * 0.6;
gfx_rect(0, hdr_h, gfx_w, max(1, floor(2 * S)));

// ============================================================================
//  HELPERS
// ============================================================================
function draw_bar(bx, by, bw, bh, val, vmin, vmax, label, show_val) (
  gfx_r = COL_BAR_BG_R; gfx_g = COL_BAR_BG_G; gfx_b = COL_BAR_BG_B;
  gfx_rect(bx, by, bw, bh);
  norm = (val - vmin) / (vmax - vmin);
  norm = max(0, min(1, norm));
  fill_w = norm * bw;
  fill_w > 0 ? (
    gfx_r = COL_CYAN_R * 0.6; gfx_g = COL_CYAN_G * 0.6; gfx_b = COL_CYAN_B * 0.6;
    gfx_rect(bx, by, fill_w, bh);
    gfx_r = COL_CYAN_R * 0.8; gfx_g = COL_CYAN_G * 0.8; gfx_b = COL_CYAN_B * 0.8;
    gfx_rect(bx, by, fill_w, floor(bh / 2));
    gfx_r = COL_CYAN_R; gfx_g = COL_CYAN_G; gfx_b = COL_CYAN_B;
    gfx_rect(bx, by, fill_w, 1);
  );
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_rect(bx, by, bw, 1); gfx_rect(bx, by + bh - 1, bw, 1);
  gfx_rect(bx, by, 1, bh); gfx_rect(bx + bw - 1, by, 1, bh);
  gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
  gfx_setfont(1, "Arial", F_LABEL);
  gfx_x = bx + floor(5 * S); gfx_y = by + floor((bh - F_LABEL) / 2);
  gfx_drawstr(label);
  show_val ? (
    gfx_setfont(1, "Arial", F_SMALL);
    gfx_x = bx + bw - floor(40 * S); gfx_y = by + floor((bh - F_SMALL) / 2);
    gfx_drawnumber(val, val == floor(val) ? 0 : 1);
  );
  mouse_cap & 1 ? (
    mouse_x >= bx && mouse_x <= bx + bw &&
    mouse_y >= by && mouse_y <= by + bh ? (
      new_norm = (mouse_x - bx) / bw;
      new_norm = max(0, min(1, new_norm));
      val = vmin + new_norm * (vmax - vmin);
    );
  );
  val;
);

function draw_panel(px, py, pw, ph, title) (
  gfx_r = COL_PANEL_R; gfx_g = COL_PANEL_G; gfx_b = COL_PANEL_B;
  gfx_rect(px, py, pw, ph);
  gfx_r = COL_PANEL_HI_R; gfx_g = COL_PANEL_HI_G; gfx_b = COL_PANEL_HI_B;
  gfx_rect(px, py, pw, floor(22 * S));
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_rect(px, py + floor(22 * S), pw, 1);
  gfx_r = COL_BORDER_R * 0.7; gfx_g = COL_BORDER_G * 0.7; gfx_b = COL_BORDER_B * 0.7;
  gfx_rect(px, py, pw, 1); gfx_rect(px, py, 1, ph);
  gfx_rect(px + pw - 1, py, 1, ph); gfx_rect(px, py + ph - 1, pw, 1);
  gfx_r = COL_SEC_R; gfx_g = COL_SEC_G; gfx_b = COL_SEC_B;
  gfx_setfont(1, "Arial", F_LABEL);
  gfx_x = px + floor(8 * S); gfx_y = py + floor(4 * S);
  gfx_drawstr(title);
);

function draw_toggle(tx, ty, is_on, label) (
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_circle(tx + floor(8 * S), ty + floor(8 * S), floor(7 * S), 0);
  is_on ? (
    gfx_r = COL_GREEN_R; gfx_g = COL_GREEN_G; gfx_b = COL_GREEN_B;
    gfx_circle(tx + floor(8 * S), ty + floor(8 * S), floor(5 * S), 1);
  ) : (
    gfx_r = 0.15; gfx_g = 0.15; gfx_b = 0.18;
    gfx_circle(tx + floor(8 * S), ty + floor(8 * S), floor(5 * S), 1);
  );
  gfx_r = is_on ? COL_TEXT_R : COL_DIM_R;
  gfx_g = is_on ? COL_TEXT_G : COL_DIM_G;
  gfx_b = is_on ? COL_TEXT_B : COL_DIM_B;
  gfx_setfont(1, "Arial", F_SMALL);
  gfx_x = tx + floor(20 * S); gfx_y = ty + floor(1 * S);
  gfx_drawstr(label);
  (mouse_cap & 1) && !(last_cap & 1) &&
    mouse_x >= tx && mouse_x <= tx + floor(80 * S) &&
    mouse_y >= ty && mouse_y <= ty + floor(16 * S) ? (
      is_on = 1 - is_on;
  );
  is_on;
);

// ============================================================================
//  LAYOUT
// ============================================================================
margin = floor(8 * S);
gap = floor(6 * S);
bar_h = floor(18 * S);
bar_sp = floor(21 * S);
pad = floor(4 * S);
pad2 = pad * 2;
body_y = floor(50 * S);

col_w = floor((gfx_w - margin * 2 - gap) / 2);
c1x = margin;
c2x = margin + col_w + gap;

// ============================================================================
//  LOGO + TITLE
// ============================================================================
gfx_getimgdim(0, logo_img_w, logo_img_h);
logo_img_w > 0 ? (
  logo_h = floor(32 * S);
  logo_w = floor(logo_h * (logo_img_w / logo_img_h));
  logo_x = floor(6 * S);
  logo_y = floor(((hdr_h - logo_h)) / 2);
  gfx_blit(0, 1, 0, 0, 0, logo_img_w, logo_img_h, logo_x, logo_y, logo_w, logo_h);
) : (
  logo_w = 0;
  logo_x = 0;
);
gfx_r = COL_TITLE_R; gfx_g = COL_TITLE_G; gfx_b = COL_TITLE_B;
gfx_setfont(1, "Arial", F_TITLE);
gfx_x = logo_x + logo_w + floor(8 * S); gfx_y = floor(6 * S);
gfx_drawstr("SMART GATE");
gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
gfx_setfont(1, "Arial", F_SMALL);
gfx_x = logo_x + logo_w + floor(8 * S); gfx_y = floor(26 * S);
gfx_drawstr("Density-Aware Noise Gate");

// ============================================================================
//  LEFT COLUMN: CONTROLS
// ============================================================================
ctrl_h = mode == 1 ? floor(310 * S) : floor(265 * S);
draw_panel(c1x, body_y, col_w, ctrl_h, "CONTROLS");
cy = body_y + floor(26 * S);

// Input Gain
_old = slider1; slider1 = draw_bar(c1x + pad, cy, col_w - pad2, bar_h, slider1, -12, 12, "Input dB", 1);
slider1 != _old ? slider_automate(2^0);
cy += bar_sp;

// Mode selector (Single/Drum, click to cycle)
mode_sel_w = col_w - pad2;
mode_sel_h = bar_h;
gfx_r = COL_BAR_BG_R; gfx_g = COL_BAR_BG_G; gfx_b = COL_BAR_BG_B;
gfx_rect(c1x + pad, cy, mode_sel_w, mode_sel_h);
gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
gfx_rect(c1x + pad, cy, mode_sel_w, 1); gfx_rect(c1x + pad, cy + mode_sel_h - 1, mode_sel_w, 1);
gfx_rect(c1x + pad, cy, 1, mode_sel_h); gfx_rect(c1x + pad + mode_sel_w - 1, cy, 1, mode_sel_h);
mode == 1 ? (
  gfx_r = COL_ACCENT_R * 0.25; gfx_g = COL_ACCENT_G * 0.25; gfx_b = COL_ACCENT_B * 0.15;
  gfx_rect(c1x + pad + 1, cy + 1, mode_sel_w - 2, mode_sel_h - 2);
);
gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
gfx_setfont(1, "Arial", F_LABEL);
gfx_x = c1x + pad + floor(5 * S); gfx_y = cy + floor((mode_sel_h - F_LABEL) / 2);
gfx_drawstr("Mode");
gfx_r = COL_ACCENT_R; gfx_g = COL_ACCENT_G; gfx_b = COL_ACCENT_B;
gfx_setfont(1, "Arial", F_SMALL);
gfx_x = c1x + pad + mode_sel_w - floor(55 * S); gfx_y = cy + floor((mode_sel_h - F_SMALL) / 2);
slider2 == 0 ? gfx_drawstr("SINGLE") : gfx_drawstr("DRUM");
(mouse_cap & 1) && !(last_cap & 1) &&
  mouse_x >= c1x + pad && mouse_x <= c1x + pad + mode_sel_w &&
  mouse_y >= cy && mouse_y <= cy + mode_sel_h ? (
  _old = slider2;
  slider2 = 1 - slider2;
  slider2 != _old ? slider_automate(2^1);
);
cy += bar_sp;

// Gate Threshold
_old = slider3; slider3 = draw_bar(c1x + pad, cy, col_w - pad2, bar_h, slider3, 0, 100, "Threshold %", 1);
slider3 != _old ? slider_automate(2^2);
cy += bar_sp;

// Pre-Open
_old = slider4; slider4 = draw_bar(c1x + pad, cy, col_w - pad2, bar_h, slider4, 0, 20, "Pre-Open ms", 1);
slider4 != _old ? slider_automate(2^3);
cy += bar_sp;

// Fade In
_old = slider16; slider16 = draw_bar(c1x + pad, cy, col_w - pad2, bar_h, slider16, 0.1, 10, "Fade In ms", 1);
slider16 != _old ? slider_automate(2^15);
cy += bar_sp;

// Hold
_old = slider5; slider5 = draw_bar(c1x + pad, cy, col_w - pad2, bar_h, slider5, 10, 500, "Hold ms", 1);
slider5 != _old ? slider_automate(2^4);
cy += bar_sp;

// Release
_old = slider6; slider6 = draw_bar(c1x + pad, cy, col_w - pad2, bar_h, slider6, 20, 2000, "Release ms", 1);
slider6 != _old ? slider_automate(2^5);
cy += bar_sp;

// Range
_old = slider7; slider7 = draw_bar(c1x + pad, cy, col_w - pad2, bar_h, slider7, -80, 0, "Range dB", 1);
slider7 != _old ? slider_automate(2^6);
cy += bar_sp;

// Density Sensitivity
_old = slider8; slider8 = draw_bar(c1x + pad, cy, col_w - pad2, bar_h, slider8, 0, 100, "Density Sens %", 1);
slider8 != _old ? slider_automate(2^7);
cy += bar_sp;

// Hysteresis
_old = slider9; slider9 = draw_bar(c1x + pad, cy, col_w - pad2, bar_h, slider9, 0, 100, "Hysteresis %", 1);
slider9 != _old ? slider_automate(2^8);
cy += bar_sp;

// Sidechain HPF
_old = slider10; slider10 = draw_bar(c1x + pad, cy, col_w - pad2, bar_h, slider10, 20, 500, "SC HPF Hz", 1);
slider10 != _old ? slider_automate(2^9);
cy += bar_sp;

// Mix
_old = slider15; slider15 = draw_bar(c1x + pad, cy, col_w - pad2, bar_h, slider15, 0, 100, "Mix %", 1);
slider15 != _old ? slider_automate(2^14);
cy += bar_sp;

// Drum mode controls (only when mode=Drum)
mode == 1 ? (
  // Drum Type selector (Kick/Snare/Tom)
  dt_sel_w = col_w - pad2;
  dt_sel_h = bar_h;
  gfx_r = COL_BAR_BG_R; gfx_g = COL_BAR_BG_G; gfx_b = COL_BAR_BG_B;
  gfx_rect(c1x + pad, cy, dt_sel_w, dt_sel_h);
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_rect(c1x + pad, cy, dt_sel_w, 1); gfx_rect(c1x + pad, cy + dt_sel_h - 1, dt_sel_w, 1);
  gfx_rect(c1x + pad, cy, 1, dt_sel_h); gfx_rect(c1x + pad + dt_sel_w - 1, cy, 1, dt_sel_h);
  gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
  gfx_setfont(1, "Arial", F_LABEL);
  gfx_x = c1x + pad + floor(5 * S); gfx_y = cy + floor((dt_sel_h - F_LABEL) / 2);
  gfx_drawstr("Drum Type");
  gfx_r = COL_ACCENT_R; gfx_g = COL_ACCENT_G; gfx_b = COL_ACCENT_B;
  gfx_setfont(1, "Arial", F_SMALL);
  gfx_x = c1x + pad + dt_sel_w - floor(50 * S); gfx_y = cy + floor((dt_sel_h - F_SMALL) / 2);
  slider11 == 0 ? gfx_drawstr("KICK");
  slider11 == 1 ? gfx_drawstr("SNARE");
  slider11 == 2 ? gfx_drawstr("TOM");
  slider11 == 3 ? gfx_drawstr("OH");
  (mouse_cap & 1) && !(last_cap & 1) &&
    mouse_x >= c1x + pad && mouse_x <= c1x + pad + dt_sel_w &&
    mouse_y >= cy && mouse_y <= cy + dt_sel_h ? (
    _old = slider11;
    slider11 = (slider11 + 1) % 4;
    slider11 != _old ? slider_automate(2^10);
  );
  (mouse_cap & 2) && !(last_cap & 2) &&
    mouse_x >= c1x + pad && mouse_x <= c1x + pad + dt_sel_w &&
    mouse_y >= cy && mouse_y <= cy + dt_sel_h ? (
    _old = slider11;
    slider11 = slider11 - 1; slider11 < 0 ? slider11 = 3;
    slider11 != _old ? slider_automate(2^10);
  );
  cy += bar_sp;

  // Tom Distance (only when drum_type == Tom)
  slider11 == 2 ? (
    _old = slider12; slider12 = draw_bar(c1x + pad, cy, col_w - pad2, bar_h, slider12, 1, 8, "Tom Distance", 1);
    slider12 != _old ? (slider12 = floor(slider12 + 0.5); slider_automate(2^11));
    cy += bar_sp;
  );

  // Bleed Reject
  _old = slider13; slider13 = draw_bar(c1x + pad, cy, col_w - pad2, bar_h, slider13, 0, 100, "Bleed Rej %", 1);
  slider13 != _old ? slider_automate(2^12);
  cy += bar_sp;

  // ---- PHASE CORRECTION SECTION ----
  // Phase offset readout (close mics only: Kick/Snare/Tom)
  drum_type < 3 ? (
    // Phase status bar background
    ph_bar_w = col_w - pad2;
    ph_bar_h = bar_h;
    gfx_r = COL_BAR_BG_R; gfx_g = COL_BAR_BG_G; gfx_b = COL_BAR_BG_B;
    gfx_rect(c1x + pad, cy, ph_bar_w, ph_bar_h);
    gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
    gfx_rect(c1x + pad, cy, ph_bar_w, 1); gfx_rect(c1x + pad, cy + ph_bar_h - 1, ph_bar_w, 1);
    gfx_rect(c1x + pad, cy, 1, ph_bar_h); gfx_rect(c1x + pad + ph_bar_w - 1, cy, 1, ph_bar_h);

    gfx_setfont(1, "Arial", F_LABEL);
    gfx_x = c1x + pad + floor(5 * S); gfx_y = cy + floor((ph_bar_h - F_LABEL) / 2);
    gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
    gfx_drawstr("Phase");

    gfx_setfont(1, "Arial", F_SMALL);
    cal_offset > 0 ? (
      // Show offset in ms and samples
      ph_ms = cal_offset / srate * 1000;
      gfx_r = COL_GREEN_R; gfx_g = COL_GREEN_G; gfx_b = COL_GREEN_B;
      gfx_x = c1x + pad + ph_bar_w - floor(90 * S); gfx_y = cy + floor((ph_bar_h - F_SMALL) / 2);
      gfx_drawnumber(ph_ms, 1);
      gfx_drawstr("ms (");
      gfx_drawnumber(cal_offset, 0);
      gfx_drawstr(" smp)");
    ) : (
      gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
      gfx_x = c1x + pad + ph_bar_w - floor(30 * S); gfx_y = cy + floor((ph_bar_h - F_SMALL) / 2);
      gfx_drawstr("---");
    );
    cy += bar_sp;

    // PHASE CORRECT TO OH button
    ph_btn_w = col_w - pad2 - floor(30 * S); // leave room for CLR
    ph_btn_h = bar_h;

    // Button background - state dependent
    cal_state == 1 ? (
      // ARMED: pulsing amber
      ph_pulse = 0.5 + 0.5 * sin(time_precise() * 6);
      gfx_r = 0.9 * ph_pulse; gfx_g = 0.6 * ph_pulse; gfx_b = 0.1 * ph_pulse;
    ) : cal_state == 2 ? (
      // DONE: green tint
      gfx_r = COL_GREEN_R * 0.3; gfx_g = COL_GREEN_G * 0.3; gfx_b = COL_GREEN_B * 0.3;
    ) : (
      // IDLE: dark
      gfx_r = 0.10; gfx_g = 0.12; gfx_b = 0.10;
    );
    gfx_rect(c1x + pad, cy, ph_btn_w, ph_btn_h);

    // Button border
    cal_state == 1 ? (
      gfx_r = 0.9; gfx_g = 0.6; gfx_b = 0.1;
    ) : cal_state == 2 ? (
      gfx_r = COL_GREEN_R; gfx_g = COL_GREEN_G; gfx_b = COL_GREEN_B;
    ) : (
      gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
    );
    gfx_rect(c1x + pad, cy, ph_btn_w, 1); gfx_rect(c1x + pad, cy + ph_btn_h - 1, ph_btn_w, 1);
    gfx_rect(c1x + pad, cy, 1, ph_btn_h); gfx_rect(c1x + pad + ph_btn_w - 1, cy, 1, ph_btn_h);

    // Button text
    gfx_setfont(1, "Arial", F_TINY);
    cal_state == 0 ? (
      gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
      gfx_x = c1x + pad + floor(5 * S); gfx_y = cy + floor((ph_btn_h - F_TINY) / 2);
      gfx_drawstr("PHASE CORRECT TO OH");
    ) : cal_state == 1 ? (
      gfx_r = 1; gfx_g = 0.9; gfx_b = 0.3;
      gfx_x = c1x + pad + floor(5 * S); gfx_y = cy + floor((ph_btn_h - F_TINY) / 2);
      gfx_drawstr("HIT A DRUM...");
    ) : (
      gfx_r = COL_GREEN_R; gfx_g = COL_GREEN_G; gfx_b = COL_GREEN_B;
      gfx_x = c1x + pad + floor(5 * S); gfx_y = cy + floor((ph_btn_h - F_TINY) / 2);
      gfx_drawstr("RECALIBRATE");
    );

    // Click handler: PHASE CORRECT TO OH
    (mouse_cap & 1) && !(last_cap & 1) &&
      mouse_x >= c1x + pad && mouse_x <= c1x + pad + ph_btn_w &&
      mouse_y >= cy && mouse_y <= cy + ph_btn_h ? (
      cal_state == 0 || cal_state == 2 ? (
        // Arm calibration
        cal_state = 1;
        cal_oh_slot = -1;
        cal_oh_slot2 = -1;
        cal_oh_count = 0;
        cal_armed_time = sample_clock;
      ) : cal_state == 1 ? (
        // Cancel if already armed
        cal_state = 0;
      );
    );

    // CLR button (right of phase correct button)
    ph_clr_x = c1x + pad + ph_btn_w + floor(3 * S);
    ph_clr_w = floor(27 * S);
    gfx_r = 0.15; gfx_g = 0.08; gfx_b = 0.08;
    gfx_rect(ph_clr_x, cy, ph_clr_w, ph_btn_h);
    gfx_r = 0.5; gfx_g = 0.15; gfx_b = 0.15;
    gfx_rect(ph_clr_x, cy, ph_clr_w, 1); gfx_rect(ph_clr_x, cy + ph_btn_h - 1, ph_clr_w, 1);
    gfx_rect(ph_clr_x, cy, 1, ph_btn_h); gfx_rect(ph_clr_x + ph_clr_w - 1, cy, 1, ph_btn_h);
    gfx_r = 0.9; gfx_g = 0.3; gfx_b = 0.3;
    gfx_setfont(1, "Arial", F_TINY);
    gfx_x = ph_clr_x + floor(3 * S); gfx_y = cy + floor((ph_btn_h - F_TINY) / 2);
    gfx_drawstr("CLR");

    // CLR click handler
    (mouse_cap & 1) && !(last_cap & 1) &&
      mouse_x >= ph_clr_x && mouse_x <= ph_clr_x + ph_clr_w &&
      mouse_y >= cy && mouse_y <= cy + ph_btn_h ? (
      cal_offset = 0;
      pc_samples = 0;
      cal_state = 0;
    );

  ) : drum_type == 3 ? (
    // OH instances: CAL ALL button
    ph_btn_w = col_w - pad2;
    ph_btn_h = bar_h;

    gfx_r = 0.10; gfx_g = 0.10; gfx_b = 0.15;
    gfx_rect(c1x + pad, cy, ph_btn_w, ph_btn_h);
    gfx_r = COL_CYAN_R * 0.5; gfx_g = COL_CYAN_G * 0.5; gfx_b = COL_CYAN_B * 0.5;
    gfx_rect(c1x + pad, cy, ph_btn_w, 1); gfx_rect(c1x + pad, cy + ph_btn_h - 1, ph_btn_w, 1);
    gfx_rect(c1x + pad, cy, 1, ph_btn_h); gfx_rect(c1x + pad + ph_btn_w - 1, cy, 1, ph_btn_h);
    gfx_r = COL_CYAN_R; gfx_g = COL_CYAN_G; gfx_b = COL_CYAN_B;
    gfx_setfont(1, "Arial", F_TINY);
    gfx_x = c1x + pad + floor(5 * S); gfx_y = cy + floor((ph_btn_h - F_TINY) / 2);
    gfx_drawstr("CAL ALL PHASE");

    // CAL ALL click handler
    (mouse_cap & 1) && !(last_cap & 1) &&
      mouse_x >= c1x + pad && mouse_x <= c1x + pad + ph_btn_w &&
      mouse_y >= cy && mouse_y <= cy + ph_btn_h ? (
      bc_my_slot >= 0 ? (
        cal_ebase = BC_MY_REGION + bc_my_slot * BC_SLOT_SIZE + 200;
        gmem[cal_ebase + 10] = 1;
        cal_request_age = 0;
      );
    );
    cy += bar_sp;

    // PHASE VIEW button
    pv_btn_w = col_w - pad2;
    pv_btn_h = bar_h;
    pv_open ? (
      gfx_r = COL_GREEN_R * 0.25; gfx_g = COL_GREEN_G * 0.25; gfx_b = COL_GREEN_B * 0.25;
    ) : (
      gfx_r = 0.08; gfx_g = 0.10; gfx_b = 0.12;
    );
    gfx_rect(c1x + pad, cy, pv_btn_w, pv_btn_h);
    pv_open ? (
      gfx_r = COL_GREEN_R; gfx_g = COL_GREEN_G; gfx_b = COL_GREEN_B;
    ) : (
      gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
    );
    gfx_rect(c1x + pad, cy, pv_btn_w, 1); gfx_rect(c1x + pad, cy + pv_btn_h - 1, pv_btn_w, 1);
    gfx_rect(c1x + pad, cy, 1, pv_btn_h); gfx_rect(c1x + pad + pv_btn_w - 1, cy, 1, pv_btn_h);
    pv_open ? (
      gfx_r = COL_GREEN_R; gfx_g = COL_GREEN_G; gfx_b = COL_GREEN_B;
    ) : (
      gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
    );
    gfx_setfont(1, "Arial", F_TINY);
    gfx_x = c1x + pad + floor(5 * S); gfx_y = cy + floor((pv_btn_h - F_TINY) / 2);
    gfx_drawstr("PHASE VIEW");

    // PHASE VIEW click handler
    (mouse_cap & 1) && !(last_cap & 1) &&
      mouse_x >= c1x + pad && mouse_x <= c1x + pad + pv_btn_w &&
      mouse_y >= cy && mouse_y <= cy + pv_btn_h ? (
      pv_open = !pv_open;
    );
  );
);

// ============================================================================
//  RIGHT COLUMN: STATE
// ============================================================================

// --- GATE METER ---
gate_meter_h = floor(60 * S);
draw_panel(c2x, body_y, col_w, gate_meter_h, "GATE");

meter_x = c2x + pad;
meter_y = body_y + floor(26 * S);
meter_w = col_w - pad2;
meter_h = floor(28 * S);

// Background
gfx_r = 0.08; gfx_g = 0.08; gfx_b = 0.10;
gfx_rect(meter_x, meter_y, meter_w, meter_h);

// Gate bar
gate_pct = gfx_gate_gain;
bar_w_gate = gate_pct * meter_w;
gate_pct > 0.8 ? (
  gfx_r = 0.2; gfx_g = 0.8; gfx_b = 0.3; gfx_a = 0.8;
) : gate_pct > 0.3 ? (
  gfx_r = 0.9; gfx_g = 0.7; gfx_b = 0.1; gfx_a = 0.8;
) : (
  gfx_r = 0.9; gfx_g = 0.2; gfx_b = 0.2; gfx_a = 0.8;
);
bar_w_gate > 0 ? (
  gfx_rect(meter_x, meter_y, bar_w_gate, meter_h);
);
gfx_a = 1;

// Gate state text
gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_setfont(1, "Arial", F_LABEL);
gfx_x = meter_x + floor(5 * S);
gfx_y = meter_y + floor(8 * S);
gate_state == 0 ? gfx_drawstr("CLOSED");
gate_state == 1 ? gfx_drawstr("OPENING");
gate_state == 2 ? gfx_drawstr("OPEN");
gate_state == 3 ? gfx_drawstr("HOLD");
gate_state == 4 ? gfx_drawstr("RELEASE");

// GR readout
gfx_setfont(1, "Arial", F_SMALL);
gfx_x = meter_x + meter_w - floor(60 * S);
gfx_y = meter_y + floor(8 * S);
gfx_drawnumber(slider14, 1);
gfx_drawstr(" dB");

// Border
gfx_r = 0.25; gfx_g = 0.25; gfx_b = 0.3;
gfx_rect(meter_x, meter_y, meter_w, meter_h, 0);

// --- DENSITY STATE ---
density_panel_y = body_y + gate_meter_h + gap;
density_panel_h = floor(80 * S);
draw_panel(c2x, density_panel_y, col_w, density_panel_h, "DENSITY");

dy = density_panel_y + floor(26 * S);
d_bar_w = floor(60 * S);
d_bar_h = floor(10 * S);
d_bx = c2x + pad + floor(30 * S);

// Lo
gfx_r = 0.12; gfx_g = 0.31; gfx_b = 0.86;
disp_lo = min(1, (hd.density - 1.0) / 1.5);
gfx_rect(d_bx, dy, d_bar_w * max(0, disp_lo), d_bar_h);
gfx_r = 0.2; gfx_g = 0.2; gfx_b = 0.25;
gfx_rect(d_bx, dy, d_bar_w, d_bar_h, 0);
gfx_r = 0.5; gfx_g = 0.5; gfx_b = 0.6;
gfx_setfont(1, "Arial", F_TINY);
gfx_x = c2x + pad; gfx_y = dy;
gfx_drawstr("LO");

dy += floor(13 * S);
gfx_r = 0.86; gfx_g = 0.63; gfx_b = 0.12;
gfx_rect(d_bx, dy, d_bar_w * min(1, max(0, hd.mid_density)), d_bar_h);
gfx_r = 0.2; gfx_g = 0.2; gfx_b = 0.25;
gfx_rect(d_bx, dy, d_bar_w, d_bar_h, 0);
gfx_r = 0.5; gfx_g = 0.5; gfx_b = 0.6;
gfx_x = c2x + pad; gfx_y = dy;
gfx_drawstr("MID");

dy += floor(13 * S);
gfx_r = 0.86; gfx_g = 0.24; gfx_b = 0.12;
gfx_rect(d_bx, dy, d_bar_w * min(1, max(0, hd.hi_density)), d_bar_h);
gfx_r = 0.2; gfx_g = 0.2; gfx_b = 0.25;
gfx_rect(d_bx, dy, d_bar_w, d_bar_h, 0);
gfx_r = 0.5; gfx_g = 0.5; gfx_b = 0.6;
gfx_x = c2x + pad; gfx_y = dy;
gfx_drawstr("HI");

dy += floor(13 * S);
gfx_r = 0.71; gfx_g = 0.16; gfx_b = 0.86;
gfx_rect(d_bx, dy, d_bar_w * min(1, max(0, hd.air_density)), d_bar_h);
gfx_r = 0.2; gfx_g = 0.2; gfx_b = 0.25;
gfx_rect(d_bx, dy, d_bar_w, d_bar_h, 0);
gfx_r = 0.5; gfx_g = 0.5; gfx_b = 0.6;
gfx_x = c2x + pad; gfx_y = dy;
gfx_drawstr("AIR");

// Density readout on right side
gfx_setfont(1, "Arial", F_TINY);
status_x = d_bx + d_bar_w + floor(15 * S);
status_y = density_panel_y + floor(26 * S);
gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
gfx_x = status_x; gfx_y = status_y;
gfx_drawstr("Density: ");
gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
gfx_drawnumber(gfx_density, 2);

gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
gfx_x = status_x; gfx_y = status_y + floor(13 * S);
gfx_drawstr("Env: ");
gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
gfx_drawnumber(gfx_env * 100, 1);

gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
gfx_x = status_x; gfx_y = status_y + floor(26 * S);
gfx_drawstr("Eff Thr: ");
gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
gfx_drawnumber(sqrt(gfx_eff_thresh) * 100, 1);
gfx_drawstr("%");

// --- SIDECHAIN ENVELOPE METER (mini) ---
sc_meter_y = density_panel_y + density_panel_h + gap;
sc_meter_h = floor(28 * S);
draw_panel(c2x, sc_meter_y, col_w, sc_meter_h + floor(22 * S), "SIDECHAIN");
gfx_r = 0.08; gfx_g = 0.08; gfx_b = 0.10;
gfx_rect(c2x + pad, sc_meter_y + floor(22 * S), col_w - pad2, sc_meter_h);
// Envelope bar
sc_env_norm = min(1.0, gfx_env * 4);
sc_env_fill = sc_env_norm * (col_w - pad2);
sc_env_fill > 0 ? (
  gfx_r = COL_CYAN_R * 0.5; gfx_g = COL_CYAN_G * 0.5; gfx_b = COL_CYAN_B * 0.5;
  gfx_rect(c2x + pad, sc_meter_y + floor(22 * S), sc_env_fill, sc_meter_h);
);
// Threshold line
t_norm = sqrt(gfx_eff_thresh);
t_line_x = c2x + pad + floor(t_norm * 4 * (col_w - pad2));
t_line_x = min(t_line_x, c2x + col_w - pad);
gfx_r = 1.0; gfx_g = 0.3; gfx_b = 0.3;
gfx_rect(t_line_x, sc_meter_y + floor(22 * S), max(1, floor(2 * S)), sc_meter_h);
// Border
gfx_r = 0.25; gfx_g = 0.25; gfx_b = 0.3;
gfx_rect(c2x + pad, sc_meter_y + floor(22 * S), col_w - pad2, sc_meter_h, 0);

// --- DRUM MODE PEERS (only when mode=Drum) ---
mode == 1 ? (
  peer_panel_y = sc_meter_y + sc_meter_h + floor(22 * S) + gap;
  peer_rows = max(1, gfx_peer_count);
  peer_panel_h = floor(22 * S) + peer_rows * floor(16 * S) + floor(8 * S);
  draw_panel(c2x, peer_panel_y, col_w, peer_panel_h, "DRUM PEERS");

  py = peer_panel_y + floor(26 * S);
  gfx_setfont(1, "Arial", F_TINY);

  gfx_peer_count == 0 ? (
    gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
    gfx_x = c2x + pad + floor(4 * S); gfx_y = py;
    gfx_drawstr("No peers found");
  );

  // Draw each peer
  peer_row_h = floor(16 * S);
  pi = 0;
  loop(gfx_peer_count,
    pi == 0 ? (pt = gfx_peer_type_0; po = gfx_peer_open_0; pd = gfx_peer_dist_0; ps = gfx_peer_slot_0; pth = gfx_peer_thresh_0; pph = gfx_peer_phase_0);
    pi == 1 ? (pt = gfx_peer_type_1; po = gfx_peer_open_1; pd = gfx_peer_dist_1; ps = gfx_peer_slot_1; pth = gfx_peer_thresh_1; pph = gfx_peer_phase_1);
    pi == 2 ? (pt = gfx_peer_type_2; po = gfx_peer_open_2; pd = gfx_peer_dist_2; ps = gfx_peer_slot_2; pth = gfx_peer_thresh_2; pph = gfx_peer_phase_2);
    pi == 3 ? (pt = gfx_peer_type_3; po = gfx_peer_open_3; pd = gfx_peer_dist_3; ps = gfx_peer_slot_3; pth = gfx_peer_thresh_3; pph = gfx_peer_phase_3);
    pi == 4 ? (pt = gfx_peer_type_4; po = gfx_peer_open_4; pd = gfx_peer_dist_4; ps = gfx_peer_slot_4; pth = gfx_peer_thresh_4; pph = gfx_peer_phase_4);
    pi == 5 ? (pt = gfx_peer_type_5; po = gfx_peer_open_5; pd = gfx_peer_dist_5; ps = gfx_peer_slot_5; pth = gfx_peer_thresh_5; pph = gfx_peer_phase_5);
    pi == 6 ? (pt = gfx_peer_type_6; po = gfx_peer_open_6; pd = gfx_peer_dist_6; ps = gfx_peer_slot_6; pth = gfx_peer_thresh_6; pph = gfx_peer_phase_6);
    pi == 7 ? (pt = gfx_peer_type_7; po = gfx_peer_open_7; pd = gfx_peer_dist_7; ps = gfx_peer_slot_7; pth = gfx_peer_thresh_7; pph = gfx_peer_phase_7);

    // Open/closed indicator
    po ? (
      gfx_r = COL_GREEN_R; gfx_g = COL_GREEN_G; gfx_b = COL_GREEN_B;
    ) : (
      gfx_r = 0.5; gfx_g = 0.15; gfx_b = 0.15;
    );
    gfx_circle(c2x + pad + floor(8 * S), py + floor(6 * S), floor(4 * S), 1);

    // Type label
    gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
    gfx_x = c2x + pad + floor(18 * S); gfx_y = py;
    pt == 0 ? gfx_drawstr("KICK");
    pt == 1 ? gfx_drawstr("SNARE");
    pt == 2 ? (
      gfx_drawstr("TOM d=");
      gfx_drawnumber(pd, 0);
    );
    pt == 3 ? gfx_drawstr("OH");

    // Threshold readout
    gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
    gfx_drawstr(" T:");
    gfx_drawnumber(pth, 0);

    // Phase indicator (close mics only: pt < 3)
    pt < 3 ? (
      pph > 0 ? (
        // Aligned — green dot
        gfx_r = COL_GREEN_R; gfx_g = COL_GREEN_G; gfx_b = COL_GREEN_B;
      ) : (
        // No correction — dim gray dot
        gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
      );
      gfx_circle(c2x + col_w - floor(55 * S), py + floor(6 * S), floor(3 * S), 1);
    );

    // State
    gfx_x = c2x + col_w - floor(45 * S); gfx_y = py;
    po ? (
      gfx_r = COL_GREEN_R; gfx_g = COL_GREEN_G; gfx_b = COL_GREEN_B;
      gfx_drawstr("OPEN");
    ) : (
      gfx_r = 0.5; gfx_g = 0.15; gfx_b = 0.15;
      gfx_drawstr("GATED");
    );

    // Right-click on peer row: open threshold popup
    (mouse_cap & 2) && !(last_cap & 2) &&
      mouse_x >= c2x && mouse_x < c2x + col_w &&
      mouse_y >= py && mouse_y < py + peer_row_h ? (
      tp_open = 1;
      tp_peer_idx = pi;
      tp_peer_slot = ps;
      tp_x = min(mouse_x, gfx_w - floor(55 * S));
      tp_y = max(0, min(mouse_y - floor(70 * S), gfx_h - floor(145 * S)));
      tp_dragging = 0;
    );

    py += peer_row_h;
    pi += 1;
  );
);

// --- THRESHOLD POPUP OVERLAY (right-click on peer) ---
tp_open ? (
  // Read current value from peer's gmem
  tp_sb = BC_MY_REGION + tp_peer_slot * BC_SLOT_SIZE;
  tp_cur_thresh = gmem[tp_sb + 200 + 5];  // ebase + 5 = threshold
  tp_cur_thresh = max(0, min(100, tp_cur_thresh));

  // Get peer type for label
  tp_pt = gmem[tp_sb + 200 + 0];

  // Popup background
  tp_w = floor(55 * S);
  tp_h = floor(140 * S);
  gfx_r = 0.10; gfx_g = 0.10; gfx_b = 0.14; gfx_a = 0.95;
  gfx_rect(tp_x, tp_y, tp_w, tp_h);
  gfx_a = 1;

  // Border
  gfx_r = COL_ACCENT_R; gfx_g = COL_ACCENT_G; gfx_b = COL_ACCENT_B;
  gfx_rect(tp_x, tp_y, tp_w, 1);
  gfx_rect(tp_x, tp_y + tp_h - 1, tp_w, 1);
  gfx_rect(tp_x, tp_y, 1, tp_h);
  gfx_rect(tp_x + tp_w - 1, tp_y, 1, tp_h);

  // Label: peer type + threshold value
  gfx_setfont(1, "Arial", F_TINY);
  gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
  gfx_x = tp_x + floor(4 * S); gfx_y = tp_y + floor(4 * S);
  tp_pt == 0 ? gfx_drawstr("KICK");
  tp_pt == 1 ? gfx_drawstr("SNR");
  tp_pt == 2 ? gfx_drawstr("TOM");
  tp_pt == 3 ? gfx_drawstr("OH");
  gfx_r = COL_ACCENT_R; gfx_g = COL_ACCENT_G; gfx_b = COL_ACCENT_B;
  gfx_x = tp_x + floor(4 * S); gfx_y = tp_y + floor(14 * S);
  gfx_drawstr("T:");
  gfx_drawnumber(tp_cur_thresh, 0);
  gfx_drawstr("%");

  // Vertical slider track
  tp_sl_x = tp_x + floor(10 * S);
  tp_sl_y = tp_y + floor(28 * S);
  tp_sl_w = floor(35 * S);
  tp_sl_h = floor(105 * S);

  // Track background
  gfx_r = 0.06; gfx_g = 0.06; gfx_b = 0.08;
  gfx_rect(tp_sl_x, tp_sl_y, tp_sl_w, tp_sl_h);

  // Fill from bottom
  tp_cur_thresh > 0 ? (
    tp_fill_h = (tp_cur_thresh / 100) * tp_sl_h;
    tp_bright = tp_cur_thresh / 100;
    gfx_r = COL_ACCENT_R * tp_bright; gfx_g = COL_ACCENT_G * tp_bright; gfx_b = COL_ACCENT_B * tp_bright;
    gfx_rect(tp_sl_x, tp_sl_y + tp_sl_h - tp_fill_h, tp_sl_w, tp_fill_h);
  );

  // Thumb line
  tp_thumb_y = tp_sl_y + tp_sl_h - (tp_cur_thresh / 100) * tp_sl_h;
  gfx_r = 1; gfx_g = 1; gfx_b = 1;
  gfx_rect(tp_sl_x, tp_thumb_y - 1, tp_sl_w, 3);

  // Slider border
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_rect(tp_sl_x, tp_sl_y, tp_sl_w, tp_sl_h, 0);

  // Drag interaction
  mouse_cap & 1 ? (
    mouse_x >= tp_sl_x && mouse_x < tp_sl_x + tp_sl_w &&
    mouse_y >= tp_sl_y && mouse_y < tp_sl_y + tp_sl_h ? (
      tp_dragging = 1;
    );
    tp_dragging ? (
      tp_new = ((tp_sl_y + tp_sl_h - mouse_y) / tp_sl_h) * 100;
      tp_new = max(0, min(100, (tp_new + 0.5) | 0));
      // Write to peer's remote threshold channel
      tp_wsb = BC_MY_REGION + tp_peer_slot * BC_SLOT_SIZE + 200;
      gmem[tp_wsb + 7] = tp_new;   // value
      gmem[tp_wsb + 6] = 1;        // flag: pending write
    );
  ) : (
    tp_dragging = 0;
  );

  // Close on left-click outside popup (not while dragging)
  (mouse_cap & 1) && !(last_cap & 1) && !tp_dragging ? (
    !(mouse_x >= tp_x && mouse_x < tp_x + tp_w &&
      mouse_y >= tp_y && mouse_y < tp_y + tp_h) ? (
      tp_open = 0;
    );
  );

  // Close on right-click outside peer panel
  (mouse_cap & 2) && !(last_cap & 2) ? (
    !(mouse_x >= c2x && mouse_x < c2x + col_w &&
      mouse_y >= peer_panel_y && mouse_y < peer_panel_y + peer_panel_h) ? (
      tp_open = 0;
    );
  );
);

// ============================================================================
//  INSTANCE MANAGER PANEL
// ============================================================================
bc_rows_per_page = 5;
bc_row_h = floor(14 * S);
bc_bar_h = floor(30 * S);
bc_btn_h = floor(20 * S);
bc_panel_h = bc_panel_expanded ? (bc_bar_h + bc_rows_per_page * bc_row_h + floor(18 * S)) : bc_bar_h;
bc_panel_y = gfx_h - bc_panel_h;

gfx_r = 0.04; gfx_g = 0.04; gfx_b = 0.06;
gfx_rect(0, bc_panel_y, gfx_w, bc_panel_h);
gfx_r = 0.15; gfx_g = 0.15; gfx_b = 0.20;
gfx_rect(0, bc_panel_y, gfx_w, 1);

gfx_setfont(1, "Arial", F_SMALL);
gfx_r = 0.95; gfx_g = 0.45; gfx_b = 0.15;
gfx_x = floor(8 * S); gfx_y = bc_panel_y + floor(8 * S);
bc_my_slot >= 0 ? (
  gfx_drawstr("I");
  gfx_drawnumber(bc_my_slot + 1, 0);
  gfx_drawstr("/");
  gfx_drawnumber(bc_instance_count, 0);
) : (
  gfx_drawstr("--");
);

bc_following > 0 ? (
  gfx_r = 0.2; gfx_g = 0.8; gfx_b = 0.3;
  gfx_drawstr("  Following: I");
  bc_fs = 0;
  loop(BC_MAX_INST,
    fsb = BC_MY_REGION + bc_fs * BC_SLOT_SIZE;
    gmem[fsb + 1] == bc_following ? (
      gfx_drawnumber(bc_fs + 1, 0);
      bc_fs = BC_MAX_INST;
    );
    bc_fs += 1;
  );
) : (
  gfx_r = 0.3; gfx_g = 0.3; gfx_b = 0.4;
  gfx_drawstr("  Following: --");
);

exp_x = gfx_w - floor(200 * S);
exp_y = bc_panel_y + floor(4 * S);
exp_w = floor(65 * S);
exp_h = floor(20 * S);
gfx_r = 0.12; gfx_g = 0.12; gfx_b = 0.16;
gfx_rect(exp_x, exp_y, exp_w, exp_h);
gfx_r = 0.5; gfx_g = 0.5; gfx_b = 0.6;
gfx_x = exp_x + floor(5 * S); gfx_y = exp_y + floor(4 * S);
bc_panel_expanded ? gfx_drawstr("COLLAPSE") : gfx_drawstr("EXPAND");
(mouse_cap & 1) && !(last_cap & 1) &&
  mouse_x >= exp_x && mouse_x < exp_x + exp_w &&
  mouse_y >= exp_y && mouse_y < exp_y + exp_h ? (
  bc_panel_expanded = !bc_panel_expanded;
  bc_steal_mode = 0;
);

stl_x = gfx_w - floor(125 * S);
stl_y = bc_panel_y + floor(4 * S);
stl_w = floor(50 * S);
stl_h = floor(20 * S);
bc_steal_mode ? (
  gfx_r = 0.6; gfx_g = 0.2; gfx_b = 0.1;
) : (
  gfx_r = 0.2; gfx_g = 0.1; gfx_b = 0.1;
);
gfx_rect(stl_x, stl_y, stl_w, stl_h);
gfx_r = 0.9; gfx_g = 0.5; gfx_b = 0.2;
gfx_x = stl_x + floor(6 * S); gfx_y = stl_y + floor(4 * S);
gfx_drawstr("STEAL");
(mouse_cap & 1) && !(last_cap & 1) &&
  mouse_x >= stl_x && mouse_x < stl_x + stl_w &&
  mouse_y >= stl_y && mouse_y < stl_y + stl_h ? (
  bc_steal_mode = !bc_steal_mode;
  !bc_panel_expanded ? bc_panel_expanded = 1;
);

bc_following > 0 ? (
  unf_x = gfx_w - floor(65 * S);
  unf_y = bc_panel_y + floor(4 * S);
  unf_w = floor(55 * S);
  unf_h = floor(20 * S);
  gfx_r = 0.1; gfx_g = 0.2; gfx_b = 0.1;
  gfx_rect(unf_x, unf_y, unf_w, unf_h);
  gfx_r = 0.5; gfx_g = 0.9; gfx_b = 0.5;
  gfx_x = unf_x + floor(4 * S); gfx_y = unf_y + floor(4 * S);
  gfx_drawstr("UNFLW");
  (mouse_cap & 1) && !(last_cap & 1) &&
    mouse_x >= unf_x && mouse_x < unf_x + unf_w &&
    mouse_y >= unf_y && mouse_y < unf_y + unf_h ? (
    bc_following = 0;
    bc_follow_slot = -1;
  );
);

bc_panel_expanded ? (
  row_y = bc_panel_y + bc_bar_h;
  row_h = bc_row_h;
  bc_my_page = bc_my_slot >= 0 ? floor(bc_my_slot / bc_rows_per_page) : 0;
  bc_page < 0 ? bc_page = 0;
  bc_active_slots = 0;
  bc_si = 0;
  loop(BC_MAX_INST,
    gmem[BC_MY_REGION + bc_si * BC_SLOT_SIZE + 1] > 0 ? bc_active_slots += 1;
    bc_si += 1;
  );
  bc_total_pages = max(1, ceil(bc_active_slots / bc_rows_per_page));
  bc_page >= bc_total_pages ? bc_page = bc_total_pages - 1;
  pg_btn_w = floor(18 * S); pg_btn_h = floor(14 * S);
  pg_prev_x = floor(8 * S); pg_prev_y = bc_panel_y + bc_bar_h + bc_rows_per_page * row_h + floor(2 * S);
  bc_total_pages > 1 ? (
    gfx_r = 0.25; gfx_g = 0.25; gfx_b = 0.32;
    gfx_rect(pg_prev_x, pg_prev_y, pg_btn_w, pg_btn_h);
    gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.8;
    gfx_x = pg_prev_x + floor(4 * S); gfx_y = pg_prev_y + floor(2 * S);
    gfx_drawstr("<");
    (mouse_cap & 1) && !(last_cap & 1) &&
      mouse_x >= pg_prev_x && mouse_x < pg_prev_x + pg_btn_w &&
      mouse_y >= pg_prev_y && mouse_y < pg_prev_y + pg_btn_h ? (
      bc_page > 0 ? bc_page -= 1;
    );
    gfx_r = 0.25; gfx_g = 0.25; gfx_b = 0.32;
    gfx_rect(pg_prev_x + pg_btn_w + 2, pg_prev_y, pg_btn_w, pg_btn_h);
    gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.8;
    gfx_x = pg_prev_x + pg_btn_w + floor(6 * S); gfx_y = pg_prev_y + floor(2 * S);
    gfx_drawstr(">");
    (mouse_cap & 1) && !(last_cap & 1) &&
      mouse_x >= pg_prev_x + pg_btn_w + 2 && mouse_x < pg_prev_x + pg_btn_w * 2 + 2 &&
      mouse_y >= pg_prev_y && mouse_y < pg_prev_y + pg_btn_h ? (
      bc_page < bc_total_pages - 1 ? bc_page += 1;
    );
    gfx_r = 0.4; gfx_g = 0.4; gfx_b = 0.5;
    gfx_x = pg_prev_x + pg_btn_w * 2 + floor(8 * S); gfx_y = pg_prev_y + floor(2 * S);
    gfx_drawnumber(bc_page + 1, 0);
    gfx_drawstr("/");
    gfx_drawnumber(bc_total_pages, 0);
    bc_page != bc_my_page ? (
      you_x = pg_prev_x + pg_btn_w * 2 + floor(40 * S);
      gfx_r = 0.15; gfx_g = 0.15; gfx_b = 0.20;
      gfx_rect(you_x, pg_prev_y, floor(30 * S), pg_btn_h);
      gfx_r = 0.95; gfx_g = 0.45; gfx_b = 0.15;
      gfx_x = you_x + floor(3 * S); gfx_y = pg_prev_y + floor(2 * S);
      gfx_drawstr("YOU");
      (mouse_cap & 1) && !(last_cap & 1) &&
        mouse_x >= you_x && mouse_x < you_x + floor(30 * S) &&
        mouse_y >= pg_prev_y && mouse_y < pg_prev_y + pg_btn_h ? (
        bc_page = bc_my_page;
      );
    );
  );
  bc_page_start = bc_page * bc_rows_per_page;
  bc_page_end = bc_page_start + bc_rows_per_page - 1;
  bc_visible = 0;
  bc_s = 0;
  loop(BC_MAX_INST,
    isb = BC_MY_REGION + bc_s * BC_SLOT_SIZE;
    isid = gmem[isb + 1];
    isid > 0 ? (
      bc_visible >= bc_page_start && bc_visible <= bc_page_end ? (
        draw_row_y = row_y + (bc_visible - bc_page_start) * row_h;
        mouse_y >= draw_row_y && mouse_y < draw_row_y + row_h &&
          mouse_x >= floor(8 * S) && mouse_x < gfx_w - floor(8 * S) &&
          bc_s != bc_my_slot ? (
          gfx_r = 0.10; gfx_g = 0.10; gfx_b = 0.14;
          gfx_rect(floor(4 * S), draw_row_y, gfx_w - floor(8 * S), row_h);
        );
        gfx_setfont(1, "Arial", F_TINY);
        bc_s == bc_my_slot ? (
          gfx_r = 0.95; gfx_g = 0.45; gfx_b = 0.15;
        ) : (
          gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.8;
        );
        gfx_x = floor(12 * S); gfx_y = draw_row_y + floor(1 * S);
        gfx_drawstr("I");
        gfx_drawnumber(bc_s + 1, 0);
        gfx_drawstr("  ");
        bc_s == bc_my_slot ? (
          gfx_drawstr("[YOU]");
        ) : (
          iwho = gmem[isb + 3];
          bc_has_follower = 0;
          bc_fsc = 0;
          loop(BC_MAX_INST,
            fsb2 = BC_MY_REGION + bc_fsc * BC_SLOT_SIZE;
            gmem[fsb2 + 1] > 0 && gmem[fsb2 + 3] == isid ? bc_has_follower = 1;
            bc_fsc += 1;
          );
          iwho > 0 ? (
            gfx_r = 0.4; gfx_g = 0.6; gfx_b = 0.9;
            gfx_drawstr("[FOLLOWER]");
          ) : bc_has_follower ? (
            gfx_r = 0.95; gfx_g = 0.78; gfx_b = 0.35;
            gfx_drawstr("[LEADER]");
          ) : (
            gfx_r = 0.38; gfx_g = 0.38; gfx_b = 0.45;
            gfx_drawstr("[UNASSIGNED]");
          );
          gfx_r = 0.35; gfx_g = 0.45; gfx_b = 0.35;
          bc_steal_mode ? (
            gfx_drawstr("  click: steal");
          ) : (
            gfx_drawstr("  click: follow");
          );
          (mouse_cap & 1) && !(last_cap & 1) &&
            mouse_y >= draw_row_y && mouse_y < draw_row_y + row_h &&
            mouse_x >= floor(8 * S) && mouse_x < gfx_w - floor(8 * S) ? (
            bc_steal_mode ? (
              bc_steal_target = isid;
              bc_steal_pending = 1;
              bc_steal_mode = 0;
            ) : (
              bc_can_follow = 1;
              bc_cursor = isid;
              bc_hops = 0;
              while(bc_cursor > 0 && bc_hops < BC_MAX_INST) (
                bc_cursor == bc_my_id ? (
                  bc_can_follow = 0;
                  bc_cursor = 0;
                ) : (
                  bc_next = 0;
                  bc_cs = 0;
                  loop(BC_MAX_INST,
                    csb = BC_MY_REGION + bc_cs * BC_SLOT_SIZE;
                    gmem[csb + 1] == bc_cursor ? (
                      bc_next = gmem[csb + 3];
                      bc_cs = BC_MAX_INST;
                    );
                    bc_cs += 1;
                  );
                  bc_cursor = bc_next;
                );
                bc_hops += 1;
              );
              bc_can_follow ? (
                bc_following = isid;
              );
            );
          );
        );
      );
      bc_visible += 1;
    );
    bc_s += 1;
  );
);

// ============================================================================
//  PHASE VIEW OVERLAY (OH instances only)
// ============================================================================
pv_open && mode == 1 && drum_type == 3 ? (
  // Semi-transparent background
  gfx_r = 0.03; gfx_g = 0.03; gfx_b = 0.05; gfx_a = 0.92;
  gfx_rect(0, 0, gfx_w, gfx_h);
  gfx_a = 1;

  // Title
  gfx_setfont(1, "Arial", F_TITLE);
  gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
  gfx_x = floor(15 * S); gfx_y = floor(10 * S);
  gfx_drawstr("PHASE VIEW");
  gfx_setfont(1, "Arial", F_SMALL);
  gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
  gfx_x = floor(15 * S); gfx_y = floor(32 * S);
  gfx_drawstr("Circles show phase alignment of close mics to this overhead");

  // Close button (X) top right
  pv_close_x = gfx_w - floor(30 * S);
  pv_close_y = floor(8 * S);
  pv_close_sz = floor(18 * S);
  gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
  gfx_x = pv_close_x + floor(4 * S); gfx_y = pv_close_y + floor(2 * S);
  gfx_setfont(1, "Arial", F_LABEL);
  gfx_drawstr("X");
  (mouse_cap & 1) && !(last_cap & 1) &&
    mouse_x >= pv_close_x && mouse_x <= pv_close_x + pv_close_sz &&
    mouse_y >= pv_close_y && mouse_y <= pv_close_y + pv_close_sz ? (
    pv_open = 0;
  );

  // Read our own transient timestamp for live delta comparison
  pv_my_ts = 0;
  bc_my_slot >= 0 ? (
    pv_my_ebase = BC_MY_REGION + bc_my_slot * BC_SLOT_SIZE + 200;
    pv_my_ts = gmem[pv_my_ebase + 8];
  );

  // Count close mic peers (not other OHs) for layout
  pv_close_count = 0;
  pvi = 0;
  loop(gfx_peer_count,
    pvi == 0 ? pv_pt = gfx_peer_type_0;
    pvi == 1 ? pv_pt = gfx_peer_type_1;
    pvi == 2 ? pv_pt = gfx_peer_type_2;
    pvi == 3 ? pv_pt = gfx_peer_type_3;
    pvi == 4 ? pv_pt = gfx_peer_type_4;
    pvi == 5 ? pv_pt = gfx_peer_type_5;
    pvi == 6 ? pv_pt = gfx_peer_type_6;
    pvi == 7 ? pv_pt = gfx_peer_type_7;
    pv_pt < 3 ? pv_close_count += 1;
    pvi += 1;
  );

  // Layout: arrange circles in a row, centered
  pv_area_y = floor(55 * S);
  pv_area_h = gfx_h - pv_area_y - floor(20 * S);
  pv_max_r = min(floor(pv_area_h * 0.35), floor(gfx_w / max(1, pv_close_count) * 0.35));
  pv_max_r = min(pv_max_r, floor(50 * S));
  pv_spacing = gfx_w / max(1, pv_close_count + 1);
  pv_center_y = pv_area_y + floor(pv_area_h * 0.4);

  // Time reference for animation
  pv_time = time_precise();

  // Draw each close mic peer as a circle
  pv_ci = 0;  // close mic index (for positioning)
  pvi = 0;
  loop(gfx_peer_count,
    // Load peer data
    pvi == 0 ? (pv_pt = gfx_peer_type_0; pv_ph = gfx_peer_phase_0; pv_ts = gfx_peer_ts_0; pv_sq = gfx_peer_seq_0);
    pvi == 1 ? (pv_pt = gfx_peer_type_1; pv_ph = gfx_peer_phase_1; pv_ts = gfx_peer_ts_1; pv_sq = gfx_peer_seq_1);
    pvi == 2 ? (pv_pt = gfx_peer_type_2; pv_ph = gfx_peer_phase_2; pv_ts = gfx_peer_ts_2; pv_sq = gfx_peer_seq_2);
    pvi == 3 ? (pv_pt = gfx_peer_type_3; pv_ph = gfx_peer_phase_3; pv_ts = gfx_peer_ts_3; pv_sq = gfx_peer_seq_3);
    pvi == 4 ? (pv_pt = gfx_peer_type_4; pv_ph = gfx_peer_phase_4; pv_ts = gfx_peer_ts_4; pv_sq = gfx_peer_seq_4);
    pvi == 5 ? (pv_pt = gfx_peer_type_5; pv_ph = gfx_peer_phase_5; pv_ts = gfx_peer_ts_5; pv_sq = gfx_peer_seq_5);
    pvi == 6 ? (pv_pt = gfx_peer_type_6; pv_ph = gfx_peer_phase_6; pv_ts = gfx_peer_ts_6; pv_sq = gfx_peer_seq_6);
    pvi == 7 ? (pv_pt = gfx_peer_type_7; pv_ph = gfx_peer_phase_7; pv_ts = gfx_peer_ts_7; pv_sq = gfx_peer_seq_7);

    pv_pt < 3 ? (
      // This is a close mic — draw its circle
      pv_cx = pv_spacing * (pv_ci + 1);

      // Compute phase metric: how far off is this peer?
      // pv_ph = peer's cal_offset (0 = uncalibrated, >0 = calibrated)
      // We also look at raw timestamp delta for live feedback
      pv_raw_delta = 0;
      pv_ts > 0 && pv_my_ts > 0 ? (
        pv_raw_delta = abs(pv_my_ts - pv_ts);
        // Clamp to reasonable range (10ms max = PC_MAX)
        pv_raw_delta = min(pv_raw_delta, PC_MAX);
      );

      // Phase quality: 0.0 = totally out of phase, 1.0 = perfectly aligned
      pv_ph > 0 ? (
        // Calibrated — quality is high, wobble is minimal
        pv_quality = 1.0;
      ) : (
        // Uncalibrated — quality based on raw delta
        pv_raw_delta > 0 ? (
          // Normalize: 0 samples = perfect, PC_MAX samples = worst
          pv_quality = max(0, 1.0 - (pv_raw_delta / PC_MAX));
        ) : (
          // No data yet — unknown, show as mid-wobble
          pv_quality = 0.3;
        );
      );

      // Smooth the wobble target (for animation)
      pvi == 0 ? (pv_wobble_0 += (pv_quality - pv_wobble_0) * 0.08; pv_wob = pv_wobble_0);
      pvi == 1 ? (pv_wobble_1 += (pv_quality - pv_wobble_1) * 0.08; pv_wob = pv_wobble_1);
      pvi == 2 ? (pv_wobble_2 += (pv_quality - pv_wobble_2) * 0.08; pv_wob = pv_wobble_2);
      pvi == 3 ? (pv_wobble_3 += (pv_quality - pv_wobble_3) * 0.08; pv_wob = pv_wobble_3);
      pvi == 4 ? (pv_wobble_4 += (pv_quality - pv_wobble_4) * 0.08; pv_wob = pv_wobble_4);
      pvi == 5 ? (pv_wobble_5 += (pv_quality - pv_wobble_5) * 0.08; pv_wob = pv_wobble_5);
      pvi == 6 ? (pv_wobble_6 += (pv_quality - pv_wobble_6) * 0.08; pv_wob = pv_wobble_6);
      pvi == 7 ? (pv_wobble_7 += (pv_quality - pv_wobble_7) * 0.08; pv_wob = pv_wobble_7);

      // Wobble amplitude: 1.0 = smooth circle, 0.0 = max wobble
      pv_wobble_amp = (1.0 - pv_wob) * 0.35;

      // Color: red (out of phase) -> amber -> green (in phase)
      pv_wob < 0.4 ? (
        // Red zone
        pv_cr = 0.9; pv_cg = 0.15; pv_cb = 0.15;
      ) : pv_wob < 0.75 ? (
        // Amber zone — blend red to amber
        pv_blend = (pv_wob - 0.4) / 0.35;
        pv_cr = 0.9; pv_cg = 0.15 + 0.55 * pv_blend; pv_cb = 0.1;
      ) : (
        // Green zone — blend amber to green
        pv_blend = (pv_wob - 0.75) / 0.25;
        pv_cr = 0.9 - 0.65 * pv_blend; pv_cg = 0.7 + 0.1 * pv_blend; pv_cb = 0.1 + 0.4 * pv_blend;
      );

      // Draw the wobbling circle using polygon segments
      pv_segments = 48;
      pv_seg_i = 0;
      loop(pv_segments,
        pv_angle = pv_seg_i / pv_segments * 2 * $pi;
        pv_angle2 = (pv_seg_i + 1) / pv_segments * 2 * $pi;

        // Wobble: perturb radius with multiple sine waves at different frequencies
        pv_r_perturb1 = sin(pv_angle * 3 + pv_time * 4.5) * pv_wobble_amp;
        pv_r_perturb2 = sin(pv_angle * 5 + pv_time * 7.2 + 1.3) * pv_wobble_amp * 0.6;
        pv_r_perturb3 = sin(pv_angle * 7 + pv_time * 3.1 + 2.7) * pv_wobble_amp * 0.3;
        pv_r1 = pv_max_r * (1.0 + pv_r_perturb1 + pv_r_perturb2 + pv_r_perturb3);

        pv_r_perturb1b = sin(pv_angle2 * 3 + pv_time * 4.5) * pv_wobble_amp;
        pv_r_perturb2b = sin(pv_angle2 * 5 + pv_time * 7.2 + 1.3) * pv_wobble_amp * 0.6;
        pv_r_perturb3b = sin(pv_angle2 * 7 + pv_time * 3.1 + 2.7) * pv_wobble_amp * 0.3;
        pv_r2 = pv_max_r * (1.0 + pv_r_perturb1b + pv_r_perturb2b + pv_r_perturb3b);

        // Triangle from center to two edge points
        pv_x1 = pv_cx + cos(pv_angle) * pv_r1;
        pv_y1 = pv_center_y + sin(pv_angle) * pv_r1;
        pv_x2 = pv_cx + cos(pv_angle2) * pv_r2;
        pv_y2 = pv_center_y + sin(pv_angle2) * pv_r2;

        gfx_r = pv_cr * 0.4; gfx_g = pv_cg * 0.4; gfx_b = pv_cb * 0.4; gfx_a = 0.7;
        gfx_triangle(pv_cx, pv_center_y, pv_x1, pv_y1, pv_x2, pv_y2);

        // Edge line (brighter)
        gfx_r = pv_cr; gfx_g = pv_cg; gfx_b = pv_cb; gfx_a = 0.9;
        gfx_line(pv_x1, pv_y1, pv_x2, pv_y2);

        pv_seg_i += 1;
      );
      gfx_a = 1;

      // Inner glow at center
      gfx_r = pv_cr * 0.6; gfx_g = pv_cg * 0.6; gfx_b = pv_cb * 0.6; gfx_a = 0.5;
      gfx_circle(pv_cx, pv_center_y, floor(pv_max_r * 0.3), 1);
      gfx_a = 1;

      // Label: drum type
      gfx_setfont(1, "Arial", F_LABEL);
      gfx_r = 1; gfx_g = 1; gfx_b = 1;
      pv_pt == 0 ? (
        gfx_x = pv_cx - floor(15 * S); gfx_y = pv_center_y - floor(F_LABEL / 2);
        gfx_drawstr("KICK");
      );
      pv_pt == 1 ? (
        gfx_x = pv_cx - floor(20 * S); gfx_y = pv_center_y - floor(F_LABEL / 2);
        gfx_drawstr("SNARE");
      );
      pv_pt == 2 ? (
        gfx_x = pv_cx - floor(12 * S); gfx_y = pv_center_y - floor(F_LABEL / 2);
        gfx_drawstr("TOM");
      );

      // Offset text below circle
      gfx_setfont(1, "Arial", F_SMALL);
      pv_ph > 0 ? (
        // Calibrated — show green "ALIGNED" + offset
        gfx_r = COL_GREEN_R; gfx_g = COL_GREEN_G; gfx_b = COL_GREEN_B;
        pv_ms_disp = pv_ph / srate * 1000;
        gfx_x = pv_cx - floor(25 * S); gfx_y = pv_center_y + pv_max_r + floor(12 * S);
        gfx_drawstr("ALIGNED");
        gfx_x = pv_cx - floor(22 * S); gfx_y = pv_center_y + pv_max_r + floor(25 * S);
        gfx_drawnumber(pv_ms_disp, 1);
        gfx_drawstr("ms offset");
      ) : pv_raw_delta > 0 ? (
        // Uncalibrated but have data — show amber with raw delta
        gfx_r = 0.9; gfx_g = 0.7; gfx_b = 0.2;
        pv_ms_disp = pv_raw_delta / srate * 1000;
        gfx_x = pv_cx - floor(18 * S); gfx_y = pv_center_y + pv_max_r + floor(12 * S);
        gfx_drawnumber(pv_ms_disp, 1);
        gfx_drawstr("ms");
        gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
        gfx_x = pv_cx - floor(25 * S); gfx_y = pv_center_y + pv_max_r + floor(25 * S);
        gfx_drawstr("UNCORRECTED");
      ) : (
        // No data
        gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
        gfx_x = pv_cx - floor(18 * S); gfx_y = pv_center_y + pv_max_r + floor(12 * S);
        gfx_drawstr("NO DATA");
      );

      pv_ci += 1;
    );
    pvi += 1;
  );
);

last_cap = mouse_cap;

// --- BUY + NOTICE BUTTONS ---
notice_btn_x = gfx_w - floor(60 * S);
notice_btn_y = bc_panel_y - floor(18 * S);
buy_btn_x = notice_btn_x - floor(50 * S);
buy_btn_y = notice_btn_y;
gfx_r = 0.6; gfx_g = 0.5; gfx_b = 0.3;
gfx_rect(buy_btn_x, buy_btn_y, floor(45 * S), floor(15 * S));
gfx_r = 0; gfx_g = 0; gfx_b = 0;
gfx_x = buy_btn_x + floor(4 * S); gfx_y = buy_btn_y + floor(2 * S);
gfx_drawstr("BUY");
(mouse_cap & 1) && mouse_x >= buy_btn_x && mouse_x <= buy_btn_x + floor(45 * S) && mouse_y >= buy_btn_y && mouse_y <= buy_btn_y + floor(15 * S) && !buy_clicked ? (
  buy_show = !buy_show; buy_show ? notice_show = 0;
  buy_clicked = 1;
);
!(mouse_cap & 1) ? buy_clicked = 0;
gfx_r = 0.6; gfx_g = 0.5; gfx_b = 0.3;
gfx_rect(notice_btn_x, notice_btn_y, floor(55 * S), floor(15 * S));
gfx_r = 0; gfx_g = 0; gfx_b = 0;
gfx_x = notice_btn_x + floor(4 * S); gfx_y = notice_btn_y + floor(2 * S);
gfx_drawstr("NOTICE");
(mouse_cap & 1) && mouse_x >= notice_btn_x && mouse_x <= notice_btn_x + floor(55 * S) && mouse_y >= notice_btn_y && mouse_y <= notice_btn_y + floor(15 * S) && !notice_clicked ? (
  notice_show = !notice_show; notice_show ? buy_show = 0;
  notice_clicked = 1;
);
!(mouse_cap & 1) ? notice_clicked = 0;
buy_show ? (
  gfx_r = 0.05; gfx_g = 0.05; gfx_b = 0.05; gfx_a = 0.95;
  gfx_rect(0, 0, gfx_w, gfx_h); gfx_a = 1;
  gfx_r = 0.9; gfx_g = 0.8; gfx_b = 0.5;
  gfx_x = floor(15 * S); gfx_y = floor(10 * S);
  gfx_drawstr("SUPPORT LMS");
  gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.7;
  gfx_x = floor(15 * S); gfx_y = floor(35 * S);
  gfx_drawstr("These plugins are offered for free use by anyone not able to afford it.");
  gfx_x = floor(15 * S); gfx_y = floor(50 * S);
  gfx_drawstr("No need to prove anything to us. But if you can afford to buy this suite,");
  gfx_x = floor(15 * S); gfx_y = floor(65 * S);
  gfx_drawstr("we would sure appreciate it. 50 dollars gets you every update and every");
  gfx_x = floor(15 * S); gfx_y = floor(80 * S);
  gfx_drawstr("plugin added to this suite forever. Its in its baby stages and these will");
  gfx_x = floor(15 * S); gfx_y = floor(95 * S);
  gfx_drawstr("only get doper over time. We also offer 6 months installments. But if you");
  gfx_x = floor(15 * S); gfx_y = floor(110 * S);
  gfx_drawstr("cant afford it just use it. We love you. We are all gonna make it.");
);
notice_show ? (
  gfx_r = 0.05; gfx_g = 0.05; gfx_b = 0.05; gfx_a = 0.95;
  gfx_rect(0, 0, gfx_w, gfx_h); gfx_a = 1;
  gfx_r = 0.9; gfx_g = 0.8; gfx_b = 0.5;
  gfx_x = floor(15 * S); gfx_y = floor(10 * S);
  gfx_drawstr("NOTICE");
  gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.7;
  gfx_x = floor(15 * S); gfx_y = floor(35 * S);
  gfx_drawstr("LMS plugins are made with assistance from Claude by Anthropic.");
  gfx_x = floor(15 * S); gfx_y = floor(50 * S);
  gfx_drawstr("All DSP algorithms, GFX layout, and broadcast system designed by");
  gfx_x = floor(15 * S); gfx_y = floor(65 * S);
  gfx_drawstr("Bryan (LMS) with Claude as a coding partner.");
  gfx_x = floor(15 * S); gfx_y = floor(85 * S);
  gfx_drawstr("This plugin is part of the LMS suite for REAPER.");
);

@serialize
file_var(0, bc_following);
file_var(0, bc_my_id);
file_var(0, cal_offset);
