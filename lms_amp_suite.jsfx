desc:LMS - CHRIS' BEDROOM — Four Amp Models
//tags: amp guitar bass distortion reverb
//author: LMS + Claude

import lms_core.jsfx-inc
options:gmem=DrumBanger

// === INPUT COMPRESSOR ===
slider1:-18<-40,0,0.1>-Comp Threshold (dB)
slider2:4<1,20,0.1>-Comp Ratio
slider3:75<0,100,0.1>-Comp Output (%)

// === AMP SELECT ===
slider4:0<0,3,1{Triple Rectified SOB,Punk Idol,The Fridge,The Frenchie}>-Amp Model

// === GAIN ===
slider5:40<0,100,0.1>-Input Gain (%)
slider22:60<0,100,0.1>-Gain (%)
slider23:0<0,2,1{Clean,Crunch,Lead}>-Channel (SOB/Punk)

// === TONE STACK ===
slider6:50<0,100,0.1>-Bass
slider7:55<0,100,0.1>-Mid
slider8:50<0,100,0.1>-Treble
slider9:40<0,100,0.1>-Presence

// === AMP-SPECIFIC CONTROLS ===
slider10:0<0,1,1{Silicon,Tube}>-Rectifier (SOB)
slider11:0<0,1,1{Lo,Hi}>-Input (Punk Idol)
slider12:2<0,4,1{220Hz,450Hz,800Hz,1.6kHz,3kHz}>-Mid Freq (Fridge)
slider13:0<0,1,1{Off,On}>-Ultra Lo (Fridge)
slider14:0<0,1,1{Off,On}>-Ultra Hi (Fridge)

// === OUTPUT ===
slider15:75<0,100,0.1>-Master Vol (%)
slider16:1<0,1,1{Direct,Mic'd}>-Cabinet

// === ROOM ===
slider17:0<0,100,0.1>-Room Mix (%)
slider18:50<0,100,0.1>-Room Decay (%)
slider19:60<0,100,0.1>-Room Damp (%)
slider20:0<0,5,1{Bedroom,Garage,Basement,Studio,Stage,Hall}>-Room Type
slider21:100<0,100,0.1>-Dry/Wet (%)

@init

  // ============================================================
  // DSP INSTANCES
  // ============================================================

  // Input compressor (front-door protection)
  in_comp.lms_comp_init();

  // Pre-distortion EQ (input voicing before clipping)
  pre_eq.lms_bq_init();

  // Tone stack — 4 biquad bands (shared across all models, different params)
  bass_eq.lms_bq_init();
  mid_eq.lms_bq_init();
  treb_eq.lms_bq_init();
  pres_eq.lms_bq_init();

  // Fridge aux EQ (Ultra Lo/Hi switches)
  fridge_ulo.lms_bq_init();
  fridge_uhi.lms_bq_init();
  fridge_notch.lms_bq_init();

  // Cabinet simulation — generic (SOB/Fridge/Frenchie)
  cab_lo.lms_bq_init();
  cab_hi.lms_bq_init();

  // JCM800 preamp triode stages
  jcm_v1b.lms_triode_v1b_init();   // V1B: unbypassed cathode, soft
  jcm_v1a.lms_triode_v1a_init();   // V1A: bypassed cathode, hard (Hi input only)

  // JCM800 input coupling cap (100Hz HP — before V1B)
  jcm_input_hp.lms_bq_init();
  jcm_input_hp.lms_bq_set_hp(100, 0.7);

  // JCM800 passive tone stack
  jcm_ts.lms_tonestack_jcm_init();

  // JCM800 EL34 power amp
  jcm_pa.lms_el34_init();

  // JCM800 4×12 cabinet (Celestion G12T-75)
  jcm_cab.lms_cab_412_init();

  // DC blocker — essential after asymmetric clipping
  dc.lms_dc_init();

  // Sag simulator (SOB tube rectifier mode)
  sag.lms_sag_init();
  sag.lms_sag_set(22);   // 22ms attack — Mesa-style bloom

  // Opto comp (Frenchie natural compression)
  frenchie_opto.lms_opto_init();

  // Room tone filter on reverb tail
  room_tone.lms_tone_init();

  // ============================================================
  // ROOM REVERB BUFFERS — Schroeder (6 comb + 4 allpass)
  // ============================================================
  buf_pos = 0;

  cb_l0 = buf_pos; buf_pos += 2048;
  cb_l1 = buf_pos; buf_pos += 2048;
  cb_l2 = buf_pos; buf_pos += 2048;
  cb_l3 = buf_pos; buf_pos += 2048;
  cb_l4 = buf_pos; buf_pos += 2048;
  cb_l5 = buf_pos; buf_pos += 2048;

  cb_r0 = buf_pos; buf_pos += 2048;
  cb_r1 = buf_pos; buf_pos += 2048;
  cb_r2 = buf_pos; buf_pos += 2048;
  cb_r3 = buf_pos; buf_pos += 2048;
  cb_r4 = buf_pos; buf_pos += 2048;
  cb_r5 = buf_pos; buf_pos += 2048;

  ap_l0 = buf_pos; buf_pos += 1024;
  ap_l1 = buf_pos; buf_pos += 1024;
  ap_l2 = buf_pos; buf_pos += 1024;
  ap_l3 = buf_pos; buf_pos += 1024;

  ap_r0 = buf_pos; buf_pos += 1024;
  ap_r1 = buf_pos; buf_pos += 1024;
  ap_r2 = buf_pos; buf_pos += 1024;
  ap_r3 = buf_pos; buf_pos += 1024;

  cp_l0=0; cp_l1=0; cp_l2=0; cp_l3=0; cp_l4=0; cp_l5=0;
  cp_r0=0; cp_r1=0; cp_r2=0; cp_r3=0; cp_r4=0; cp_r5=0;
  ap_pos_l0=0; ap_pos_l1=0; ap_pos_l2=0; ap_pos_l3=0;
  ap_pos_r0=0; ap_pos_r1=0; ap_pos_r2=0; ap_pos_r3=0;

  clp_l0=0; clp_l1=0; clp_l2=0; clp_l3=0; clp_l4=0; clp_l5=0;
  clp_r0=0; clp_r1=0; clp_r2=0; clp_r3=0; clp_r4=0; clp_r5=0;

  // Room type delay bases — mutually prime
  room_base0 = 557; room_base1 = 617; room_base2 = 691;
  room_base3 = 773; room_base4 = 839; room_base5 = 911;
  ap_base0 = 113; ap_base1 = 151; ap_base2 = 167; ap_base3 = 211;

  notice_show = 0;
  notice_clicked = 0;
  last_cap = 0;

  // ============================================================
  // BROADCAST SYSTEM
  // ============================================================
  BC_BASE = 100000;
  BC_MY_TYPE = 10;
  BC_SLOT_SIZE = 512;
  BC_MAX_INST = 32;
  BC_PARAM_COUNT = 23;
  BC_MY_REGION = BC_BASE + BC_MY_TYPE * 16384;
  BC_STALE_TIMEOUT = 2;

  bc_my_id == 0 ? bc_my_id = floor(rand() * 1073741824) + 1;
  bc_my_slot = -1;
  bc_follow_slot = -1;
  bc_steal_pending = 0;
  bc_steal_target = 0;
  bc_panel_expanded = 0;
  bc_page = 0;
  bc_steal_mode = 0;
  bc_instance_count = 0;

  BC_STALE_HB = 640000;
  BC_STALE_CT = 640032;
  i = 0;
  loop(BC_MAX_INST,
    BC_STALE_HB[i] = -1;
    BC_STALE_CT[i] = 0;
    i += 1;
  );

  bc_i = 0;
  loop(BC_MAX_INST,
    bc_my_slot < 0 ? (
      sb = BC_MY_REGION + bc_i * BC_SLOT_SIZE;
      sid = gmem[sb + 1];
      (sid == 0 || sid == bc_my_id) ? bc_my_slot = bc_i;
    );
    bc_i += 1;
  );

  bc_my_slot >= 0 ? (
    sb = BC_MY_REGION + bc_my_slot * BC_SLOT_SIZE;
    gmem[sb + 0] = 0;
    gmem[sb + 1] = bc_my_id;
    gmem[sb + 2] = BC_MY_TYPE;
    gmem[sb + 3] = 0;
    gmem[sb + 4] = BC_PARAM_COUNT;
  );

@slider
  comp_thresh = slider1;
  comp_ratio  = slider2;
  comp_out    = slider3 / 100;
  amp_model   = slider4;
  in_gain     = slider5 / 100;
  bass_amt    = (slider6 - 50) / 50;
  mid_amt     = (slider7 - 50) / 50;
  treb_amt    = (slider8 - 50) / 50;
  pres_amt    = slider9 / 100;
  sob_rect    = slider10;
  punk_input  = slider11;
  fridge_mf   = slider12;
  fridge_ulo_on = slider13;
  fridge_uhi_on = slider14;
  master      = slider15 / 100;
  cab_on      = slider16;
  room_mix    = slider17 / 100;
  room_dec    = slider18 / 100;
  room_damp   = slider19 / 100;
  room_type   = slider20;
  dry_wet     = slider21 / 100;
  amp_gain    = slider22 / 100;
  amp_channel = slider23;

  // Input compressor
  in_comp.lms_comp_set(comp_thresh, comp_ratio, 5, 80);

  // Frenchie opto: always set (light compression even at low thresh)
  frenchie_opto.lms_opto_set(-24, 3, 8);

  // Pre-EQ per amp model
  amp_model == 0 ? (
    // SOB: tighten low end before clipping (88Hz shelf, subtle cut)
    pre_eq.lms_bq_set_loshelf(88, -3, 0.6);
  ) : amp_model == 1 ? (
    // JCM800: input coupling cap — 68k input resistor, 0.68µF cap → ~100Hz HP
    // This is a real component in the signal path, not a tone control
    pre_eq.lms_bq_set_hp(100, 0.7);
  ) : amp_model == 2 ? (
    // Fridge: pass-through pre-EQ (SVT has no input voicing)
    pre_eq.lms_bq_set_lp(20000, 0.7);
  ) : (
    // Frenchie: natural 5F1 input rolloff (~coupling cap behaviour)
    pre_eq.lms_bq_set_lp(12000, 0.5);
  );

  // Tone stack EQ parameters per model
  amp_model == 0 ? (
    // SOB: Mesa Boogie Modern channel
    // Bass: shelving at 88Hz (tight, not flabby)
    // Mid: peak at 700Hz Q=0.8 (the scoop zone — mid_amt cuts here)
    // Treble: shelf at 936Hz (Modern ch pivot point — shifted from 1.27k)
    // Presence: tight shelf at 2400Hz Q=2.0 (Mesa Modern presence character)
    bass_eq.lms_bq_set_loshelf(88, bass_amt * 10, 0.6);
    mid_eq.lms_bq_set_peak(700, mid_amt * 10, 0.8);
    treb_eq.lms_bq_set_hishelf(936, treb_amt * 10, 0.707);
    pres_eq.lms_bq_set_hishelf(2400, pres_amt * 8, 2.0);
  ) : amp_model == 1 ? (
    // Punk Idol: JCM800 — passive tone stack + EL34 power amp
    // bass_amt/mid_amt/treb_amt are 0..1 pot positions (not ±, unlike other models)
    jcm_ts.lms_tonestack_jcm_set(
      slider6 / 100,    // bass pot 0..1
      slider7 / 100,    // mid pot 0..1
      slider8 / 100     // treble pot 0..1
    );
    // Power amp: presence from slider9, drive from amp_gain
    jcm_pa.lms_el34_set(amp_gain, pres_amt);
  ) : amp_model == 2 ? (
    // Fridge: Ampeg SVT — bass-optimized, mid selector
    // Bass: 80Hz shelf (SVT goes LOW)
    // Mid: peak at selected freq (220/450/800/1600/3000)
    // Treble: 6kHz shelf
    // Presence: minimal — Fridge doesn't really have presence
    fridge_mf == 0 ? mid_freq = 220;
    fridge_mf == 1 ? mid_freq = 450;
    fridge_mf == 2 ? mid_freq = 800;
    fridge_mf == 3 ? mid_freq = 1600;
    fridge_mf == 4 ? mid_freq = 3000;
    bass_eq.lms_bq_set_loshelf(80, bass_amt * 12, 0.6);
    mid_eq.lms_bq_set_peak(mid_freq, mid_amt * 15, 2.0);
    treb_eq.lms_bq_set_hishelf(6000, treb_amt * 10, 0.707);
    pres_eq.lms_bq_set_hishelf(8000, pres_amt * 6, 1.2);
    // Ultra Lo: +2dB @ 40Hz, -10dB @ 500Hz (loshelf + notch)
    fridge_ulo_on == 1 ? (
      fridge_ulo.lms_bq_set_loshelf(40, 2, 0.7);
      fridge_notch.lms_bq_set_peak(500, -10, 1.5);
    ) : (
      fridge_ulo.lms_bq_set_loshelf(40, 0, 0.7);
      fridge_notch.lms_bq_set_peak(500, 0, 1.5);
    );
    // Ultra Hi: +9dB @ 8kHz
    fridge_uhi_on == 1 ? (
      fridge_uhi.lms_bq_set_hishelf(8000, 9, 0.7);
    ) : (
      fridge_uhi.lms_bq_set_hishelf(8000, 0, 0.7);
    );
  ) : (
    // Frenchie: Fender Champ — single LP tone knob (no bass/mid/treble)
    // pres_amt doubles as tone: 0=dark jazz, 1=bright sparkle
    // bass_amt/treb_amt unused — Champ has ONE knob
    // Tone maps: 0→2000Hz (dark), 1→12000Hz (bright)
    champ_tone_freq = 2000 + pres_amt * 10000;
    bass_eq.lms_bq_set_loshelf(120, bass_amt * 4, 0.6);  // very gentle
    mid_eq.lms_bq_set_peak(600, 0, 1.0);                 // flat
    treb_eq.lms_bq_set_hishelf(4000, treb_amt * 4, 0.7); // very gentle
    pres_eq.lms_bq_set_lp(champ_tone_freq, 0.6);         // THE tone knob
  );

  // Cabinet EQ per model
  amp_model == 0 ? (
    // SOB: Mesa 4×12 — HP 80Hz, LP 6500Hz (Mesa cabs go brighter)
    cab_lo.lms_bq_set_hp(80, 0.6);
    cab_hi.lms_bq_set_lp(6500, 0.7);
  ) : amp_model == 1 ? (
    // Punk Idol: Marshall 4×12 — HP 120Hz, LP 5000Hz (darker, boxier)
    cab_lo.lms_bq_set_hp(120, 0.6);
    cab_hi.lms_bq_set_lp(5000, 0.7);
  ) : amp_model == 2 ? (
    // Fridge: Ampeg 8×10 bass cab — HP 40Hz, LP 4000Hz
    cab_lo.lms_bq_set_hp(40, 0.5);
    cab_hi.lms_bq_set_lp(4000, 0.7);
  ) : (
    // Frenchie: 1×8" Champ cab — HP 80Hz, LP 8000Hz (small speaker, wide HF)
    cab_lo.lms_bq_set_hp(80, 0.6);
    cab_hi.lms_bq_set_lp(8000, 0.6);
  );

  // Room
  room_tone.lms_tone_set(400 + (1 - room_damp) * 4000);

@block
  comp_thresh = slider1;
  comp_ratio  = slider2;
  comp_out    = slider3 / 100;
  amp_model   = slider4;
  in_gain     = slider5 / 100;
  bass_amt    = (slider6 - 50) / 50;
  mid_amt     = (slider7 - 50) / 50;
  treb_amt    = (slider8 - 50) / 50;
  pres_amt    = slider9 / 100;
  sob_rect    = slider10;
  punk_input  = slider11;
  fridge_mf   = slider12;
  fridge_ulo_on = slider13;
  fridge_uhi_on = slider14;
  master      = slider15 / 100;
  cab_on      = slider16;
  room_mix    = slider17 / 100;
  room_dec    = slider18 / 100;
  room_damp   = slider19 / 100;
  room_type   = slider20;
  dry_wet     = slider21 / 100;
  amp_gain    = slider22 / 100;
  amp_channel = slider23;

  in_comp.lms_comp_set(comp_thresh, comp_ratio, 5, 80);

  amp_model == 0 ? (
    pre_eq.lms_bq_set_loshelf(88, -3, 0.6);
  ) : amp_model == 1 ? (
    pre_eq.lms_bq_set_hp(100, 0.7);
  ) : amp_model == 2 ? (
    pre_eq.lms_bq_set_lp(20000, 0.7);
  ) : (
    pre_eq.lms_bq_set_lp(12000, 0.5);
  );

  amp_model == 0 ? (
    bass_eq.lms_bq_set_loshelf(88, bass_amt * 10, 0.6);
    mid_eq.lms_bq_set_peak(700, mid_amt * 10, 0.8);
    treb_eq.lms_bq_set_hishelf(936, treb_amt * 10, 0.707);
    pres_eq.lms_bq_set_hishelf(2400, pres_amt * 8, 2.0);
  ) : amp_model == 1 ? (
    jcm_ts.lms_tonestack_jcm_set(slider6 / 100, slider7 / 100, slider8 / 100);
    jcm_pa.lms_el34_set(amp_gain, pres_amt);
  ) : amp_model == 2 ? (
    fridge_mf == 0 ? mid_freq = 220;
    fridge_mf == 1 ? mid_freq = 450;
    fridge_mf == 2 ? mid_freq = 800;
    fridge_mf == 3 ? mid_freq = 1600;
    fridge_mf == 4 ? mid_freq = 3000;
    bass_eq.lms_bq_set_loshelf(80, bass_amt * 12, 0.6);
    mid_eq.lms_bq_set_peak(mid_freq, mid_amt * 15, 2.0);
    treb_eq.lms_bq_set_hishelf(6000, treb_amt * 10, 0.707);
    pres_eq.lms_bq_set_hishelf(8000, pres_amt * 6, 1.2);
    fridge_ulo_on == 1 ? (
      fridge_ulo.lms_bq_set_loshelf(40, 2, 0.7);
      fridge_notch.lms_bq_set_peak(500, -10, 1.5);
    ) : (
      fridge_ulo.lms_bq_set_loshelf(40, 0, 0.7);
      fridge_notch.lms_bq_set_peak(500, 0, 1.5);
    );
    fridge_uhi_on == 1 ? (
      fridge_uhi.lms_bq_set_hishelf(8000, 9, 0.7);
    ) : (
      fridge_uhi.lms_bq_set_hishelf(8000, 0, 0.7);
    );
  ) : (
    champ_tone_freq = 2000 + pres_amt * 10000;
    bass_eq.lms_bq_set_loshelf(120, bass_amt * 4, 0.6);
    mid_eq.lms_bq_set_peak(600, 0, 1.0);
    treb_eq.lms_bq_set_hishelf(4000, treb_amt * 4, 0.7);
    pres_eq.lms_bq_set_lp(champ_tone_freq, 0.6);
  );

  amp_model == 0 ? (
    cab_lo.lms_bq_set_hp(80, 0.6);
    cab_hi.lms_bq_set_lp(6500, 0.7);
  ) : amp_model == 1 ? (
    cab_lo.lms_bq_set_hp(120, 0.6);
    cab_hi.lms_bq_set_lp(5000, 0.7);
  ) : amp_model == 2 ? (
    cab_lo.lms_bq_set_hp(40, 0.5);
    cab_hi.lms_bq_set_lp(4000, 0.7);
  ) : (
    cab_lo.lms_bq_set_hp(80, 0.6);
    cab_hi.lms_bq_set_lp(8000, 0.6);
  );

  room_tone.lms_tone_set(400 + (1 - room_damp) * 4000);

  // Room delay lengths — 6 types
  room_type == 0 ? room_scale = 0.18;  // Bedroom: boxy, tight
  room_type == 1 ? room_scale = 0.32;  // Garage: small room, slapback
  room_type == 2 ? room_scale = 0.50;  // Basement: mid-size, dense
  room_type == 3 ? room_scale = 0.70;  // Studio: controlled, tight
  room_type == 4 ? room_scale = 1.0;   // Stage: medium
  room_type == 5 ? room_scale = 1.5;   // Hall: large

  size_scale = 0.2 + room_mix * 0.8;
  cb_len0 = max(4, floor(room_base0 * room_scale * size_scale));
  cb_len1 = max(4, floor(room_base1 * room_scale * size_scale));
  cb_len2 = max(4, floor(room_base2 * room_scale * size_scale));
  cb_len3 = max(4, floor(room_base3 * room_scale * size_scale));
  cb_len4 = max(4, floor(room_base4 * room_scale * size_scale));
  cb_len5 = max(4, floor(room_base5 * room_scale * size_scale));

  ap_len0 = max(4, floor(ap_base0 * room_scale));
  ap_len1 = max(4, floor(ap_base1 * room_scale));
  ap_len2 = max(4, floor(ap_base2 * room_scale));
  ap_len3 = max(4, floor(ap_base3 * room_scale));

  // Larger rooms get extra decay boost
  room_type >= 4 ? decay_boost = 0.06 + (room_type - 4) * 0.06 : decay_boost = 0.0;
  comb_fb = min(0.96, room_dec * 0.85 + decay_boost);
  damp_coeff = 1 - room_damp * 0.8;
  ap_coeff = 0.6;

  // ============================================================
  // BROADCAST
  // ============================================================
  bc_my_slot >= 0 ? (
    sb = BC_MY_REGION + bc_my_slot * BC_SLOT_SIZE;
    gmem[sb + 1] != bc_my_id ? (
      bc_my_id = floor(rand() * 1073741824) + 1;
      bc_my_slot = -1;
      bc_i = 0;
      loop(BC_MAX_INST,
        bc_my_slot < 0 ? (
          tsb = BC_MY_REGION + bc_i * BC_SLOT_SIZE;
          (gmem[tsb + 1] == 0) ? bc_my_slot = bc_i;
        );
        bc_i += 1;
      );
      bc_my_slot >= 0 ? (
        sb = BC_MY_REGION + bc_my_slot * BC_SLOT_SIZE;
        gmem[sb + 0] = 0;
        gmem[sb + 1] = bc_my_id;
        gmem[sb + 2] = BC_MY_TYPE;
        gmem[sb + 3] = bc_following;
        gmem[sb + 4] = BC_PARAM_COUNT;
      );
    );
  );

  bc_my_slot >= 0 && bc_following > 0 ? (
    bc_found_leader = 0;
    bc_scan = 0;
    loop(BC_MAX_INST,
      bc_scan != bc_my_slot ? (
        lsb = BC_MY_REGION + bc_scan * BC_SLOT_SIZE;
        gmem[lsb + 1] == bc_following ? (
          bc_found_leader = 1;
          lbase = lsb + 8;
          slider1  = gmem[lbase + 0];  slider2  = gmem[lbase + 1];
          slider3  = gmem[lbase + 2];  slider4  = gmem[lbase + 3];
          slider5  = gmem[lbase + 4];  slider6  = gmem[lbase + 5];
          slider7  = gmem[lbase + 6];  slider8  = gmem[lbase + 7];
          slider9  = gmem[lbase + 8];  slider10 = gmem[lbase + 9];
          slider11 = gmem[lbase + 10]; slider12 = gmem[lbase + 11];
          slider13 = gmem[lbase + 12]; slider14 = gmem[lbase + 13];
          slider15 = gmem[lbase + 14]; slider16 = gmem[lbase + 15];
          slider17 = gmem[lbase + 16]; slider18 = gmem[lbase + 17];
          slider19 = gmem[lbase + 18]; slider20 = gmem[lbase + 19];
          slider21 = gmem[lbase + 20]; slider22 = gmem[lbase + 21];
          slider23 = gmem[lbase + 22];
          bc_scan = BC_MAX_INST;
        );
      );
      bc_scan += 1;
    );
    !bc_found_leader ? (
      bc_following = 0;
      bc_follow_slot = -1;
    );
  );

  bc_my_slot >= 0 && bc_steal_pending ? (
    bc_scan = 0;
    loop(BC_MAX_INST,
      lsb = BC_MY_REGION + bc_scan * BC_SLOT_SIZE;
      gmem[lsb + 1] == bc_steal_target ? (
        lbase = lsb + 8;
        slider1  = gmem[lbase + 0];  slider2  = gmem[lbase + 1];
        slider3  = gmem[lbase + 2];  slider4  = gmem[lbase + 3];
        slider5  = gmem[lbase + 4];  slider6  = gmem[lbase + 5];
        slider7  = gmem[lbase + 6];  slider8  = gmem[lbase + 7];
        slider9  = gmem[lbase + 8];  slider10 = gmem[lbase + 9];
        slider11 = gmem[lbase + 10]; slider12 = gmem[lbase + 11];
        slider13 = gmem[lbase + 12]; slider14 = gmem[lbase + 13];
        slider15 = gmem[lbase + 14]; slider16 = gmem[lbase + 15];
        slider17 = gmem[lbase + 16]; slider18 = gmem[lbase + 17];
        slider19 = gmem[lbase + 18]; slider20 = gmem[lbase + 19];
        slider21 = gmem[lbase + 20]; slider22 = gmem[lbase + 21];
        slider23 = gmem[lbase + 22];
        bc_scan = BC_MAX_INST;
      );
      bc_scan += 1;
    );
    bc_steal_pending = 0;
    bc_steal_target = 0;
    bc_steal_mode = 0;
  );

  bc_my_slot >= 0 ? (
    sb = BC_MY_REGION + bc_my_slot * BC_SLOT_SIZE;
    gmem[sb + 0] += 1;
    gmem[sb + 3] = bc_following;
    pbase = sb + 8;
    gmem[pbase + 0]  = slider1;  gmem[pbase + 1]  = slider2;
    gmem[pbase + 2]  = slider3;  gmem[pbase + 3]  = slider4;
    gmem[pbase + 4]  = slider5;  gmem[pbase + 5]  = slider6;
    gmem[pbase + 6]  = slider7;  gmem[pbase + 7]  = slider8;
    gmem[pbase + 8]  = slider9;  gmem[pbase + 9]  = slider10;
    gmem[pbase + 10] = slider11; gmem[pbase + 11] = slider12;
    gmem[pbase + 12] = slider13; gmem[pbase + 13] = slider14;
    gmem[pbase + 14] = slider15; gmem[pbase + 15] = slider16;
    gmem[pbase + 16] = slider17; gmem[pbase + 17] = slider18;
    gmem[pbase + 18] = slider19; gmem[pbase + 19] = slider20;
    gmem[pbase + 20] = slider21; gmem[pbase + 21] = slider22;
    gmem[pbase + 22] = slider23;
  );

  bc_instance_count = 0;
  bc_scan = 0;
  loop(BC_MAX_INST,
    tsb = BC_MY_REGION + bc_scan * BC_SLOT_SIZE;
    tsid = gmem[tsb + 1];
    tsid > 0 ? (
      bc_scan == bc_my_slot ? (
        bc_instance_count += 1;
      ) : (
        tshb = gmem[tsb + 0];
        tshb == BC_STALE_HB[bc_scan] ? (
          BC_STALE_CT[bc_scan] += samplesblock / srate;
          BC_STALE_CT[bc_scan] > BC_STALE_TIMEOUT ? (
            gmem[tsb + 1] = 0;
            BC_STALE_CT[bc_scan] = 0;
          );
        ) : (
          BC_STALE_HB[bc_scan] = tshb;
          BC_STALE_CT[bc_scan] = 0;
          bc_instance_count += 1;
        );
      );
    );
    bc_scan += 1;
  );

@sample
  dry_l = spl0;
  dry_r = spl1;

  // ============================================================
  // INPUT COMPRESSOR — protection before amp stage
  // ============================================================
  in_comp.lms_comp_proc(spl0, spl1);
  spl0 *= in_comp.gr * comp_out;
  spl1 *= in_comp.gr * comp_out;

  l = spl0;
  r = spl1;

  // ============================================================
  // PRE-DISTORTION VOICING (input filter before clipping)
  // ============================================================
  l = pre_eq.lms_bq_proc_l(l);
  r = pre_eq.lms_bq_proc_r(r);

  // Mono sum for amp (guitar amps are mono)
  // in_gain scales the signal level hitting the input stage (like a pad/boost)
  mono = (l + r) * 0.5 * (0.5 + in_gain * 1.5);
  // amp_gain = dedicated Gain knob — controls saturation/distortion depth
  drive_amt = amp_gain * 2.5;

  // ============================================================
  // AMP SATURATION — per model
  // ============================================================
  amp_model == 0 ? (
    // TRIPLE RECTIFIED SOB — Mesa Boogie Triple Rectifier Modern
    // Tube rectifier sag (if enabled)
    sob_rect == 1 ? (
      sag_gain = sag.lms_sag_proc(mono);
      mono *= sag_gain;
    );
    // Channel: 0=Clean, 1=Crunch (Vintage), 2=Lead (Modern)
    amp_channel == 0 ? (
      // Clean — Class A warm, low drive
      amp_l = lms_sat_warm(mono * (1 + drive_amt * 0.3), drive_amt * 0.15, 0.0);
    ) : amp_channel == 1 ? (
      // Crunch — Vintage hot tube
      amp_l = lms_sat_hot(mono * (1 + drive_amt * 1.2), drive_amt * 0.7, 0.05);
    ) : (
      // Lead — Modern: hot stacked with rectifier (the chug wall)
      pre = lms_sat_hot(mono * (1 + drive_amt * 1.5), drive_amt * 0.9, 0.05);
      amp_l = lms_sat_rect(pre, drive_amt * 0.4, 0.02);
    );
    amp_r = amp_l;

  ) : amp_model == 1 ? (
    // PUNK IDOL — Marshall JCM800 2203 full circuit model
    //
    // Channel routing:
    //   Clean  (0): Lo input → V1B only (single triode, unbypassed cathode)
    //   Crunch (1): Lo input → V1B pushed harder (still single stage, breakup territory)
    //   Lead   (2): Hi input → V1B → V1A cascade (dual triode, bypassed cathode on V1A)
    //
    // Input coupling cap (100Hz HP) already applied in jcm_input_hp filter.
    // Drive into V1B scaled by amp_gain — this is the preamp Gain knob.

    amp_channel == 0 ? (
      // CLEAN — Lo input, V1B at low drive (single unbypassed triode stage)
      // Produces very little saturation — just the warm asymmetric character of
      // a 12AX7 running well within its linear region
      amp_l = jcm_v1b.lms_triode_v1b_proc(mono, amp_gain * 0.25);

    ) : amp_channel == 1 ? (
      // CRUNCH — Lo input, V1B driven into breakup
      // Single stage but pushed: the unbypassed cathode compression starts to
      // become audible, positive peaks clip sooner than negative
      amp_l = jcm_v1b.lms_triode_v1b_proc(mono, amp_gain * 0.75);

    ) : (
      // LEAD — Hi input, V1B → V1A cascade
      // V1B: first triode, unbypassed cathode — soft entry saturation, even harmonics
      amp_l = jcm_v1b.lms_triode_v1b_proc(mono, amp_gain * 0.85);
      // V1A: second triode, bypassed cathode — harder clip, more 3rd harmonic
      // This is what makes the JCM800 Hi input mean — two stages of different character
      amp_l = jcm_v1a.lms_triode_v1a_proc(amp_l, amp_gain * 0.70);
    );

    // Passive tone stack (interactive Bass/Mid/Treble — replaces old biquad tone)
    // Applied here in the signal path (before power amp, as in real circuit)
    // Recovery gain compensates for ~18dB passive stack insertion loss
    amp_l = jcm_ts.lms_tonestack_jcm_proc(amp_l);
    amp_l *= 8.0;   // ~18dB recovery gain (real amp uses a recovery triode stage here)

    // EL34 push-pull power amp (odd harmonics, sag, presence NFB)
    amp_l = jcm_pa.lms_el34_proc(amp_l);

    amp_r = amp_l;

  ) : amp_model == 2 ? (
    // THE FRIDGE — Ampeg SVT-CL (no channel switch, drive_amt from amp_gain)
    // 12AX7 preamp: even harmonics, warm tube
    amp_l = lms_sat_warm(mono * (1 + drive_amt * 0.7), drive_amt * 0.5, 0.06);
    // 6550 push-pull power amp: odd harmonics (even cancel in push-pull)
    amp_l = lms_sat_harmonics(amp_l, 0.0, 0.15);
    amp_r = amp_l;
    // Ultra Lo / Ultra Hi EQ (applied after saturation)
    amp_l = fridge_ulo.lms_bq_proc_l(amp_l);
    amp_r = fridge_ulo.lms_bq_proc_r(amp_r);
    amp_l = fridge_notch.lms_bq_proc_l(amp_l);
    amp_r = fridge_notch.lms_bq_proc_r(amp_r);
    amp_l = fridge_uhi.lms_bq_proc_l(amp_l);
    amp_r = fridge_uhi.lms_bq_proc_r(amp_r);

  ) : (
    // THE FRENCHIE — Fender Champ 5F1 (no channel switch, single-ended)
    // Opto comp first (natural low-wattage compression)
    frenchie_opto.lms_opto_proc(mono, mono);
    mono *= frenchie_opto.gr;
    // 6V6GT single-ended Class A: pure even harmonics, warm breakup
    amp_l = lms_sat_warm(mono * (1 + drive_amt * 0.9), drive_amt * 0.8, 0.0);
    // Even harmonics increase with drive (single-ended character)
    drive_amt > 0.8 ? (
      even_amt = (drive_amt - 0.8) * 0.5;
      amp_l = lms_sat_harmonics(amp_l, min(0.35, even_amt), 0.03);
    );
    amp_r = amp_l;
  );

  // DC block after asymmetric clipping (essential)
  amp_l = dc.lms_dc_proc_l(amp_l);
  amp_r = dc.lms_dc_proc_r(amp_r);

  // ============================================================
  // TONE STACK — generic (not JCM800; JCM800 runs its passive stack inline)
  // ============================================================
  amp_model != 1 ? (
    amp_l = bass_eq.lms_bq_proc_l(amp_l);
    amp_r = bass_eq.lms_bq_proc_r(amp_r);
    amp_l = mid_eq.lms_bq_proc_l(amp_l);
    amp_r = mid_eq.lms_bq_proc_r(amp_r);
    amp_l = treb_eq.lms_bq_proc_l(amp_l);
    amp_r = treb_eq.lms_bq_proc_r(amp_r);
    amp_l = pres_eq.lms_bq_proc_l(amp_l);
    amp_r = pres_eq.lms_bq_proc_r(amp_r);
  );

  // ============================================================
  // CABINET SIMULATION
  // ============================================================
  cab_on == 1 ? (
    amp_model == 1 ? (
      // JCM800: 5-band Celestion G12T-75 model
      amp_l = jcm_cab.lms_cab_412_proc_l(amp_l);
      amp_r = jcm_cab.lms_cab_412_proc_r(amp_r);
    ) : (
      // All other amps: generic 2-biquad cab
      amp_l = cab_lo.lms_bq_proc_l(amp_l);
      amp_r = cab_lo.lms_bq_proc_r(amp_r);
      amp_l = cab_hi.lms_bq_proc_l(amp_l);
      amp_r = cab_hi.lms_bq_proc_r(amp_r);
    );
  );

  // Master volume
  amp_l *= master;
  amp_r *= master;

  // ============================================================
  // ROOM REVERB — Schroeder (6 comb + 4 allpass)
  // ============================================================
  room_in_l = amp_l * 0.5;
  room_in_r = amp_r * 0.5;
  cb_out_l = 0;
  cb_out_r = 0;

  delayed = cb_l0[cp_l0]; clp_l0 = delayed * damp_coeff + clp_l0 * (1 - damp_coeff);
  cb_l0[cp_l0] = room_in_l + clp_l0 * comb_fb; cb_out_l += delayed;
  cp_l0 += 1; cp_l0 >= cb_len0 ? cp_l0 = 0;

  delayed = cb_l1[cp_l1]; clp_l1 = delayed * damp_coeff + clp_l1 * (1 - damp_coeff);
  cb_l1[cp_l1] = room_in_l + clp_l1 * comb_fb; cb_out_l += delayed;
  cp_l1 += 1; cp_l1 >= cb_len1 ? cp_l1 = 0;

  delayed = cb_l2[cp_l2]; clp_l2 = delayed * damp_coeff + clp_l2 * (1 - damp_coeff);
  cb_l2[cp_l2] = room_in_l + clp_l2 * comb_fb; cb_out_l += delayed;
  cp_l2 += 1; cp_l2 >= cb_len2 ? cp_l2 = 0;

  delayed = cb_l3[cp_l3]; clp_l3 = delayed * damp_coeff + clp_l3 * (1 - damp_coeff);
  cb_l3[cp_l3] = room_in_l + clp_l3 * comb_fb; cb_out_l += delayed;
  cp_l3 += 1; cp_l3 >= cb_len3 ? cp_l3 = 0;

  delayed = cb_l4[cp_l4]; clp_l4 = delayed * damp_coeff + clp_l4 * (1 - damp_coeff);
  cb_l4[cp_l4] = room_in_l + clp_l4 * comb_fb; cb_out_l += delayed;
  cp_l4 += 1; cp_l4 >= cb_len4 ? cp_l4 = 0;

  delayed = cb_l5[cp_l5]; clp_l5 = delayed * damp_coeff + clp_l5 * (1 - damp_coeff);
  cb_l5[cp_l5] = room_in_l + clp_l5 * comb_fb; cb_out_l += delayed;
  cp_l5 += 1; cp_l5 >= cb_len5 ? cp_l5 = 0;

  delayed = cb_r0[cp_r0]; clp_r0 = delayed * damp_coeff + clp_r0 * (1 - damp_coeff);
  cb_r0[cp_r0] = room_in_r + clp_r0 * comb_fb; cb_out_r += delayed;
  cp_r0 += 1; cp_r0 >= cb_len0 ? cp_r0 = 0;

  delayed = cb_r1[cp_r1]; clp_r1 = delayed * damp_coeff + clp_r1 * (1 - damp_coeff);
  cb_r1[cp_r1] = room_in_r + clp_r1 * comb_fb; cb_out_r += delayed;
  cp_r1 += 1; cp_r1 >= cb_len1 ? cp_r1 = 0;

  delayed = cb_r2[cp_r2]; clp_r2 = delayed * damp_coeff + clp_r2 * (1 - damp_coeff);
  cb_r2[cp_r2] = room_in_r + clp_r2 * comb_fb; cb_out_r += delayed;
  cp_r2 += 1; cp_r2 >= cb_len2 ? cp_r2 = 0;

  delayed = cb_r3[cp_r3]; clp_r3 = delayed * damp_coeff + clp_r3 * (1 - damp_coeff);
  cb_r3[cp_r3] = room_in_r + clp_r3 * comb_fb; cb_out_r += delayed;
  cp_r3 += 1; cp_r3 >= cb_len3 ? cp_r3 = 0;

  delayed = cb_r4[cp_r4]; clp_r4 = delayed * damp_coeff + clp_r4 * (1 - damp_coeff);
  cb_r4[cp_r4] = room_in_r + clp_r4 * comb_fb; cb_out_r += delayed;
  cp_r4 += 1; cp_r4 >= cb_len4 ? cp_r4 = 0;

  delayed = cb_r5[cp_r5]; clp_r5 = delayed * damp_coeff + clp_r5 * (1 - damp_coeff);
  cb_r5[cp_r5] = room_in_r + clp_r5 * comb_fb; cb_out_r += delayed;
  cp_r5 += 1; cp_r5 >= cb_len5 ? cp_r5 = 0;

  cb_out_l *= 0.167;
  cb_out_r *= 0.167;

  cb_out_l = lms_spring_ap(ap_l0, ap_pos_l0, ap_len0, cb_out_l, ap_coeff);
  ap_pos_l0 += 1; ap_pos_l0 >= ap_len0 ? ap_pos_l0 = 0;
  cb_out_l = lms_spring_ap(ap_l1, ap_pos_l1, ap_len1, cb_out_l, ap_coeff);
  ap_pos_l1 += 1; ap_pos_l1 >= ap_len1 ? ap_pos_l1 = 0;
  cb_out_l = lms_spring_ap(ap_l2, ap_pos_l2, ap_len2, cb_out_l, ap_coeff);
  ap_pos_l2 += 1; ap_pos_l2 >= ap_len2 ? ap_pos_l2 = 0;
  cb_out_l = lms_spring_ap(ap_l3, ap_pos_l3, ap_len3, cb_out_l, ap_coeff);
  ap_pos_l3 += 1; ap_pos_l3 >= ap_len3 ? ap_pos_l3 = 0;

  cb_out_r = lms_spring_ap(ap_r0, ap_pos_r0, ap_len0, cb_out_r, ap_coeff);
  ap_pos_r0 += 1; ap_pos_r0 >= ap_len0 ? ap_pos_r0 = 0;
  cb_out_r = lms_spring_ap(ap_r1, ap_pos_r1, ap_len1, cb_out_r, ap_coeff);
  ap_pos_r1 += 1; ap_pos_r1 >= ap_len1 ? ap_pos_r1 = 0;
  cb_out_r = lms_spring_ap(ap_r2, ap_pos_r2, ap_len2, cb_out_r, ap_coeff);
  ap_pos_r2 += 1; ap_pos_r2 >= ap_len2 ? ap_pos_r2 = 0;
  cb_out_r = lms_spring_ap(ap_r3, ap_pos_r3, ap_len3, cb_out_r, ap_coeff);
  ap_pos_r3 += 1; ap_pos_r3 >= ap_len3 ? ap_pos_r3 = 0;

  room_l = room_tone.lms_tone_proc_l(cb_out_l);
  room_r = room_tone.lms_tone_proc_r(cb_out_r);

  wet_l = amp_l * (1 - room_mix) + room_l * room_mix;
  wet_r = amp_r * (1 - room_mix) + room_r * room_mix;

  spl0 = dry_l * (1 - dry_wet) + wet_l * dry_wet;
  spl1 = dry_r * (1 - dry_wet) + wet_r * dry_wet;

@gfx 620 480
// ============================================================================
//  COLOR CONSTANTS
// ============================================================================
COL_BG_R = 0.05; COL_BG_G = 0.05; COL_BG_B = 0.07;
COL_PANEL_R = 0.08; COL_PANEL_G = 0.08; COL_PANEL_B = 0.11;
COL_PANEL_HI_R = 0.12; COL_PANEL_HI_G = 0.12; COL_PANEL_HI_B = 0.16;
COL_BORDER_R = 0.20; COL_BORDER_G = 0.20; COL_BORDER_B = 0.25;
COL_TITLE_R = 0.95; COL_TITLE_G = 0.78; COL_TITLE_B = 0.35;
COL_SEC_R = 0.55; COL_SEC_G = 0.50; COL_SEC_B = 0.40;
COL_TEXT_R = 0.78; COL_TEXT_G = 0.78; COL_TEXT_B = 0.82;
COL_DIM_R = 0.38; COL_DIM_G = 0.38; COL_DIM_B = 0.42;
COL_ACCENT_R = 0.95; COL_ACCENT_G = 0.45; COL_ACCENT_B = 0.15;
COL_GREEN_R = 0.25; COL_GREEN_G = 0.80; COL_GREEN_B = 0.50;
COL_CYAN_R = 0.20; COL_CYAN_G = 0.60; COL_CYAN_B = 0.85;
COL_BAR_BG_R = 0.12; COL_BAR_BG_G = 0.12; COL_BAR_BG_B = 0.16;

// Background
gfx_r = COL_BG_R; gfx_g = COL_BG_G; gfx_b = COL_BG_B;
gfx_rect(0, 0, gfx_w, gfx_h);
gfx_r = 0.03; gfx_g = 0.03; gfx_b = 0.05;
gfx_rect(0, 0, gfx_w, 44);
gfx_r = COL_TITLE_R * 0.6; gfx_g = COL_TITLE_G * 0.6; gfx_b = COL_TITLE_B * 0.6;
gfx_rect(0, 44, gfx_w, 2);

// ============================================================================
//  HELPERS
// ============================================================================
function draw_bar(bx, by, bw, bh, val, vmin, vmax, label, show_val) (
  gfx_r = COL_BAR_BG_R; gfx_g = COL_BAR_BG_G; gfx_b = COL_BAR_BG_B;
  gfx_rect(bx, by, bw, bh);
  norm = (val - vmin) / (vmax - vmin);
  norm = max(0, min(1, norm));
  fill_w = norm * bw;
  fill_w > 0 ? (
    gfx_r = COL_CYAN_R * 0.6; gfx_g = COL_CYAN_G * 0.6; gfx_b = COL_CYAN_B * 0.6;
    gfx_rect(bx, by, fill_w, bh);
    gfx_r = COL_CYAN_R * 0.8; gfx_g = COL_CYAN_G * 0.8; gfx_b = COL_CYAN_B * 0.8;
    gfx_rect(bx, by, fill_w, floor(bh / 2));
    gfx_r = COL_CYAN_R; gfx_g = COL_CYAN_G; gfx_b = COL_CYAN_B;
    gfx_rect(bx, by, fill_w, 1);
  );
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_rect(bx, by, bw, 1); gfx_rect(bx, by + bh - 1, bw, 1);
  gfx_rect(bx, by, 1, bh); gfx_rect(bx + bw - 1, by, 1, bh);
  gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
  gfx_setfont(1, "Arial", 12);
  gfx_x = bx + 5; gfx_y = by + floor((bh - 12) / 2);
  gfx_drawstr(label);
  show_val ? (
    gfx_setfont(1, "Arial", 11);
    gfx_x = bx + bw - 40; gfx_y = by + floor((bh - 11) / 2);
    gfx_drawnumber(val, val == floor(val) ? 0 : 1);
  );
  mouse_cap & 1 ? (
    mouse_x >= bx && mouse_x <= bx + bw &&
    mouse_y >= by && mouse_y <= by + bh ? (
      new_norm = (mouse_x - bx) / bw;
      new_norm = max(0, min(1, new_norm));
      val = vmin + new_norm * (vmax - vmin);
    );
  );
  val;
);

function draw_panel(px, py, pw, ph, title) (
  gfx_r = COL_PANEL_R; gfx_g = COL_PANEL_G; gfx_b = COL_PANEL_B;
  gfx_rect(px, py, pw, ph);
  gfx_r = COL_PANEL_HI_R; gfx_g = COL_PANEL_HI_G; gfx_b = COL_PANEL_HI_B;
  gfx_rect(px, py, pw, 22);
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_rect(px, py + 22, pw, 1);
  gfx_r = COL_BORDER_R * 0.7; gfx_g = COL_BORDER_G * 0.7; gfx_b = COL_BORDER_B * 0.7;
  gfx_rect(px, py, pw, 1); gfx_rect(px, py, 1, ph);
  gfx_rect(px + pw - 1, py, 1, ph); gfx_rect(px, py + ph - 1, pw, 1);
  gfx_r = COL_SEC_R; gfx_g = COL_SEC_G; gfx_b = COL_SEC_B;
  gfx_setfont(1, "Arial", 12);
  gfx_x = px + 8; gfx_y = py + 4;
  gfx_drawstr(title);
);

function draw_mode_sel(mx, my, mw, mh, val, vmax, label, v0, v1, v2, v3) (
  gfx_r = COL_BAR_BG_R; gfx_g = COL_BAR_BG_G; gfx_b = COL_BAR_BG_B;
  gfx_rect(mx, my, mw, mh);
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_rect(mx, my, mw, 1); gfx_rect(mx, my + mh - 1, mw, 1);
  gfx_rect(mx, my, 1, mh); gfx_rect(mx + mw - 1, my, 1, mh);
  gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
  gfx_setfont(1, "Arial", 12);
  gfx_x = mx + 5; gfx_y = my + floor((mh - 12) / 2);
  gfx_drawstr(label);
  gfx_r = COL_ACCENT_R; gfx_g = COL_ACCENT_G; gfx_b = COL_ACCENT_B;
  gfx_x = mx + mw - 148; gfx_y = my + floor((mh - 12) / 2);
  val == 0 ? gfx_drawstr(v0);
  val == 1 ? gfx_drawstr(v1);
  val == 2 ? gfx_drawstr(v2);
  val == 3 ? gfx_drawstr(v3);
  (mouse_cap & 1) && !(last_cap & 1) &&
    mouse_x >= mx && mouse_x <= mx + mw &&
    mouse_y >= my && mouse_y <= my + mh ? (
      val = (val + 1) % (vmax + 1);
  );
  (mouse_cap & 2) && !(last_cap & 2) &&
    mouse_x >= mx && mouse_x <= mx + mw &&
    mouse_y >= my && mouse_y <= my + mh ? (
      val = val - 1; val < 0 ? val = vmax;
  );
  val;
);

function draw_toggle(tx, ty, tw, th, is_on, label) (
  gfx_r = COL_BAR_BG_R; gfx_g = COL_BAR_BG_G; gfx_b = COL_BAR_BG_B;
  gfx_rect(tx, ty, tw, th);
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_rect(tx, ty, tw, 1); gfx_rect(tx, ty + th - 1, tw, 1);
  gfx_rect(tx, ty, 1, th); gfx_rect(tx + tw - 1, ty, 1, th);
  is_on ? (
    gfx_r = COL_GREEN_R * 0.3; gfx_g = COL_GREEN_G * 0.3; gfx_b = COL_GREEN_B * 0.3;
    gfx_rect(tx + 1, ty + 1, tw - 2, th - 2);
  );
  gfx_r = is_on ? COL_GREEN_R : COL_DIM_R;
  gfx_g = is_on ? COL_GREEN_G : COL_DIM_G;
  gfx_b = is_on ? COL_GREEN_B : COL_DIM_B;
  gfx_setfont(1, "Arial", 11);
  gfx_x = tx + 5; gfx_y = ty + floor((th - 11) / 2);
  gfx_drawstr(label);
  (mouse_cap & 1) && !(last_cap & 1) &&
    mouse_x >= tx && mouse_x <= tx + tw &&
    mouse_y >= ty && mouse_y <= ty + th ? (
      is_on = 1 - is_on;
  );
  is_on;
);

// ============================================================================
//  LAYOUT
// ============================================================================
margin = 8;
gap = 6;
bar_h = 18;
bar_sp = 21;
body_y = 50;
col_w = floor((gfx_w - margin * 2 - gap) / 2);

// ============================================================================
//  TITLE
// ============================================================================
gfx_r = COL_TITLE_R; gfx_g = COL_TITLE_G; gfx_b = COL_TITLE_B;
gfx_setfont(1, "Arial", 20);
gfx_x = 12; gfx_y = 10;
gfx_drawstr("LMS - CHRIS' BEDROOM");
gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
gfx_setfont(1, "Arial", 11);
gfx_x = 220; gfx_y = 18;
amp_model == 0 ? gfx_drawstr("Triple Rectified SOB");
amp_model == 1 ? gfx_drawstr("Punk Idol");
amp_model == 2 ? gfx_drawstr("The Fridge");
amp_model == 3 ? gfx_drawstr("The Frenchie");

// ============================================================================
//  LEFT COLUMN
// ============================================================================
c1x = margin;
// 3 comp + amp select (+4px tall) + input gain + gain + channel + 4 tone = 11 rows + 4px
left_h = 26 + bar_sp * 11 + 4 + 4;
draw_panel(c1x, body_y, col_w, left_h, "INPUT / AMP");
cy = body_y + 26;

// Input compressor
_old = slider1; slider1 = draw_bar(c1x + 4, cy, col_w - 8, bar_h, slider1, -40, 0, "Comp Thresh", 1);
slider1 != _old ? slider_automate(2^0); cy += bar_sp;

_old = slider2; slider2 = draw_bar(c1x + 4, cy, col_w - 8, bar_h, slider2, 1, 20, "Comp Ratio", 1);
slider2 != _old ? slider_automate(2^1); cy += bar_sp;

_old = slider3; slider3 = draw_bar(c1x + 4, cy, col_w - 8, bar_h, slider3, 0, 100, "Comp Out", 1);
slider3 != _old ? slider_automate(2^2); cy += bar_sp;

// Amp model selector (large — most important control)
_old = slider4; slider4 = draw_mode_sel(c1x + 4, cy, col_w - 8, bar_h + 4, slider4, 3, "Amp", "Triple Rectified SOB", "Punk Idol", "The Fridge", "The Frenchie");
slider4 != _old ? slider_automate(2^3); cy += bar_sp + 4;

_old = slider5; slider5 = draw_bar(c1x + 4, cy, col_w - 8, bar_h, slider5, 0, 100, "Input Gain", 1);
slider5 != _old ? slider_automate(2^4); cy += bar_sp;

_old = slider22; slider22 = draw_bar(c1x + 4, cy, col_w - 8, bar_h, slider22, 0, 100, "Gain", 1);
slider22 != _old ? slider_automate(2^21); cy += bar_sp;

// Channel selector — only meaningful for SOB and Punk Idol
amp_model <= 1 ? (
  _old = slider23;
  amp_model == 0 ? (
    slider23 = draw_mode_sel(c1x + 4, cy, col_w - 8, bar_h, slider23, 2, "Channel", "Clean", "Crunch", "Lead", "");
  ) : (
    slider23 = draw_mode_sel(c1x + 4, cy, col_w - 8, bar_h, slider23, 2, "Channel", "Clean", "Crunch", "Lead", "");
  );
  slider23 != _old ? slider_automate(2^22);
) : (
  // Fridge and Frenchie: show grayed label
  gfx_r = COL_DIM_R * 0.5; gfx_g = COL_DIM_G * 0.5; gfx_b = COL_DIM_B * 0.5;
  gfx_setfont(1, "Arial", 10);
  gfx_x = c1x + 8; gfx_y = cy + 3;
  amp_model == 2 ? gfx_drawstr("Channel: N/A (it's a bass amp)") : gfx_drawstr("Channel: N/A (it's a Champ)");
);
cy += bar_sp;

// Tone stack
_old = slider6; slider6 = draw_bar(c1x + 4, cy, col_w - 8, bar_h, slider6, 0, 100, "Bass", 1);
slider6 != _old ? slider_automate(2^5); cy += bar_sp;

_old = slider7; slider7 = draw_bar(c1x + 4, cy, col_w - 8, bar_h, slider7, 0, 100,
  amp_model == 2 ? "Mid Level" : "Mid", 1);
slider7 != _old ? slider_automate(2^6); cy += bar_sp;

_old = slider8; slider8 = draw_bar(c1x + 4, cy, col_w - 8, bar_h, slider8, 0, 100, "Treble", 1);
slider8 != _old ? slider_automate(2^7); cy += bar_sp;

// Presence / Tone (context-sensitive label)
_old = slider9; slider9 = draw_bar(c1x + 4, cy, col_w - 8, bar_h, slider9, 0, 100,
  amp_model == 3 ? "Tone" : "Presence", 1);
slider9 != _old ? slider_automate(2^8);

// ============================================================================
//  RIGHT COLUMN
// ============================================================================
c2x = margin + col_w + gap;

// Amp-specific controls (vary by model)
amp_model == 0 ? specific_rows = 1;  // Rectifier toggle
amp_model == 1 ? specific_rows = 0;  // Channel handled in left column
amp_model == 2 ? specific_rows = 3;  // Mid Freq + Ultra Lo + Ultra Hi
amp_model == 3 ? specific_rows = 0;  // Frenchie has no specific controls

right_h = 26 + bar_sp * (3 + specific_rows) + 4; // Master + Cabinet + Room Mix + specifics
draw_panel(c2x, body_y, col_w, right_h, "AMP CONTROLS");
cy = body_y + 26;

// Amp-specific controls
amp_model == 0 ? (
  _old = slider10; slider10 = draw_toggle(c2x + 4, cy, col_w - 8, bar_h, slider10, "Tube Rectifier (Sag)");
  slider10 != _old ? slider_automate(2^9); cy += bar_sp;
) : amp_model == 1 ? (
  // No extra controls — channel (Clean/Crunch/Lead) is in left column
) : amp_model == 2 ? (
  _old = slider12; slider12 = draw_mode_sel(c2x + 4, cy, col_w - 8, bar_h, slider12, 4, "Mid Hz", "220", "450", "800", "1.6k");
  slider12 != _old ? slider_automate(2^11); cy += bar_sp;
  _old = slider13; slider13 = draw_toggle(c2x + 4, cy, col_w - 8, bar_h, slider13, "Ultra Lo (+2@40/-10@500)");
  slider13 != _old ? slider_automate(2^12); cy += bar_sp;
  _old = slider14; slider14 = draw_toggle(c2x + 4, cy, col_w - 8, bar_h, slider14, "Ultra Hi (+9@8kHz)");
  slider14 != _old ? slider_automate(2^13); cy += bar_sp;
) : (
  // Frenchie: show a note about the Champ's simplicity
  gfx_r = COL_DIM_R; gfx_g = COL_DIM_G * 0.8; gfx_b = COL_DIM_B * 0.6;
  gfx_setfont(1, "Arial", 10);
  gfx_x = c2x + 8; gfx_y = cy + 2;
  gfx_drawstr("It's a Champ. One knob.");
  cy += bar_sp;
);

// Shared output controls
_old = slider15; slider15 = draw_bar(c2x + 4, cy, col_w - 8, bar_h, slider15, 0, 100, "Master Vol", 1);
slider15 != _old ? slider_automate(2^14); cy += bar_sp;

_old = slider16; slider16 = draw_toggle(c2x + 4, cy, col_w - 8, bar_h, slider16, "Cabinet (Mic'd)");
slider16 != _old ? slider_automate(2^15); cy += bar_sp;

_old = slider17; slider17 = draw_bar(c2x + 4, cy, col_w - 8, bar_h, slider17, 0, 100, "Room Mix", 1);
slider17 != _old ? slider_automate(2^16);

// ============================================================================
//  ROOM PANEL (below both columns)
// ============================================================================
below_y = body_y + max(left_h, right_h) + gap;
room_panel_h = 26 + bar_sp * 3 + 4;
draw_panel(margin, below_y, gfx_w - margin * 2, room_panel_h, "ROOM");
rcy = below_y + 26;
rpw3 = floor((gfx_w - margin * 2 - gap * 2) / 3);

_old = slider18; slider18 = draw_bar(margin + 4, rcy, rpw3 - 4, bar_h, slider18, 0, 100, "Decay", 1);
slider18 != _old ? slider_automate(2^17);

_old = slider19; slider19 = draw_bar(margin + 4 + rpw3 + gap, rcy, rpw3 - 4, bar_h, slider19, 0, 100, "Damp", 1);
slider19 != _old ? slider_automate(2^18);

// Room type — 6 options, draw inline (draw_mode_sel only shows 4 labels)
_old = slider20;
rtx = margin + 4 + (rpw3 + gap) * 2; rty = rcy; rtw = rpw3 - 4; rth = bar_h;
gfx_r = COL_BAR_BG_R; gfx_g = COL_BAR_BG_G; gfx_b = COL_BAR_BG_B;
gfx_rect(rtx, rty, rtw, rth);
gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
gfx_rect(rtx, rty, rtw, 1); gfx_rect(rtx, rty + rth - 1, rtw, 1);
gfx_rect(rtx, rty, 1, rth); gfx_rect(rtx + rtw - 1, rty, 1, rth);
gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
gfx_setfont(1, "Arial", 12);
gfx_x = rtx + 5; gfx_y = rty + floor((rth - 12) / 2);
gfx_drawstr("Type");
gfx_r = COL_ACCENT_R; gfx_g = COL_ACCENT_G; gfx_b = COL_ACCENT_B;
gfx_x = rtx + rtw - 78; gfx_y = rty + floor((rth - 12) / 2);
slider20 == 0 ? gfx_drawstr("Bedroom");
slider20 == 1 ? gfx_drawstr("Garage");
slider20 == 2 ? gfx_drawstr("Basement");
slider20 == 3 ? gfx_drawstr("Studio");
slider20 == 4 ? gfx_drawstr("Stage");
slider20 == 5 ? gfx_drawstr("Hall");
(mouse_cap & 1) && !(last_cap & 1) &&
  mouse_x >= rtx && mouse_x <= rtx + rtw &&
  mouse_y >= rty && mouse_y <= rty + rth ? (
    slider20 = (slider20 + 1) % 6;
);
(mouse_cap & 2) && !(last_cap & 2) &&
  mouse_x >= rtx && mouse_x <= rtx + rtw &&
  mouse_y >= rty && mouse_y <= rty + rth ? (
    slider20 = slider20 - 1; slider20 < 0 ? slider20 = 5;
);
slider20 != _old ? slider_automate(2^19);
slider20 != _old ? slider_automate(2^19);

rcy += bar_sp;
_old = slider21; slider21 = draw_bar(margin + 4, rcy, gfx_w - margin * 2 - 8, bar_h, slider21, 0, 100, "Dry / Wet", 1);
slider21 != _old ? slider_automate(2^20);

// ============================================================================
//  AMP VISUALIZER
// ============================================================================
vis_y = below_y + room_panel_h + gap;
vis_h = gfx_h - vis_y - 38;
vis_h = max(50, vis_h);

draw_panel(margin, vis_y, gfx_w - margin * 2, vis_h, "THE ROOM");

room_bx = margin + 8;
room_by = vis_y + 26;
room_bw = gfx_w - margin * 2 - 16;
room_bh = vis_h - 32;

// Room background — color per amp model
amp_model == 0 ? (
  // SOB: dark, reddish — Mesa vibe
  gfx_r = 0.12; gfx_g = 0.03; gfx_b = 0.03;
) : amp_model == 1 ? (
  // Punk Idol: dark grey — British rehearsal room
  gfx_r = 0.08; gfx_g = 0.08; gfx_b = 0.10;
) : amp_model == 2 ? (
  // Fridge: dark blue — concert venue / arena
  gfx_r = 0.03; gfx_g = 0.04; gfx_b = 0.12;
) : (
  // Frenchie: warm tan — cozy jazz club
  gfx_r = 0.10; gfx_g = 0.08; gfx_b = 0.04;
);
gfx_rect(room_bx, room_by, room_bw, room_bh);

// Walls
amp_model == 0 ? (gfx_r = 0.35; gfx_g = 0.08; gfx_b = 0.06;)  // Mesa: red brick
  : amp_model == 1 ? (gfx_r = 0.22; gfx_g = 0.22; gfx_b = 0.20;) // Marshall: concrete
  : amp_model == 2 ? (gfx_r = 0.10; gfx_g = 0.12; gfx_b = 0.30;) // SVT: deep blue stage
  : (gfx_r = 0.30; gfx_g = 0.22; gfx_b = 0.10;);                  // Champ: warm wood
gfx_rect(room_bx, room_by, room_bw, 3);
gfx_rect(room_bx, room_by + room_bh - 3, room_bw, 3);
gfx_rect(room_bx, room_by, 3, room_bh);
gfx_rect(room_bx + room_bw - 3, room_by, 3, room_bh);

// Amp body
amp_vis_x = room_bx + floor(room_bw * 0.12);
amp_vis_y = room_by + floor(room_bh * 0.55);

amp_model == 0 ? (
  // SOB: tall 4×12 stack — head on top of cab
  amp_w = 24; amp_h = 32;
  gfx_r = 0.08; gfx_g = 0.03; gfx_b = 0.03;
  gfx_rect(amp_vis_x - amp_w/2, amp_vis_y - amp_h/2, amp_w, amp_h);
  gfx_r = 0.45; gfx_g = 0.08; gfx_b = 0.06;
  gfx_rect(amp_vis_x - amp_w/2 + 2, amp_vis_y - amp_h/2 + 2, amp_w - 4, 10);
  gfx_r = 0.20; gfx_g = 0.05; gfx_b = 0.04;
  gfx_rect(amp_vis_x - amp_w/2 + 2, amp_vis_y - amp_h/2 + 14, amp_w - 4, amp_h - 16);
  // Speaker dots on cab
  gfx_r = 0.06; gfx_g = 0.02; gfx_b = 0.02;
  gfx_circle(amp_vis_x - 4, amp_vis_y + 4, 3, 1);
  gfx_circle(amp_vis_x + 4, amp_vis_y + 4, 3, 1);
  gfx_circle(amp_vis_x - 4, amp_vis_y + 10, 3, 1);
  gfx_circle(amp_vis_x + 4, amp_vis_y + 10, 3, 1);
) : amp_model == 1 ? (
  // Punk Idol: Marshall head + angled 4×12
  amp_w = 22; amp_h = 28;
  gfx_r = 0.06; gfx_g = 0.06; gfx_b = 0.06;
  gfx_rect(amp_vis_x - amp_w/2, amp_vis_y - amp_h/2, amp_w, amp_h);
  gfx_r = 0.40; gfx_g = 0.35; gfx_b = 0.05;
  gfx_rect(amp_vis_x - amp_w/2 + 2, amp_vis_y - amp_h/2 + 2, amp_w - 4, 8);
  gfx_r = 0.15; gfx_g = 0.15; gfx_b = 0.15;
  gfx_rect(amp_vis_x - amp_w/2 + 2, amp_vis_y - amp_h/2 + 12, amp_w - 4, amp_h - 14);
  gfx_r = 0.06; gfx_g = 0.06; gfx_b = 0.06;
  gfx_circle(amp_vis_x - 3, amp_vis_y + 3, 3, 1);
  gfx_circle(amp_vis_x + 4, amp_vis_y + 3, 3, 1);
  gfx_circle(amp_vis_x - 3, amp_vis_y + 9, 3, 1);
  gfx_circle(amp_vis_x + 4, amp_vis_y + 9, 3, 1);
) : amp_model == 2 ? (
  // The Fridge: enormous SVT head (genuinely the size of a fridge)
  amp_w = 30; amp_h = 40;
  gfx_r = 0.05; gfx_g = 0.05; gfx_b = 0.12;
  gfx_rect(amp_vis_x - amp_w/2, amp_vis_y - amp_h/2, amp_w, amp_h);
  gfx_r = 0.20; gfx_g = 0.20; gfx_b = 0.55;
  gfx_rect(amp_vis_x - amp_w/2 + 2, amp_vis_y - amp_h/2 + 2, amp_w - 4, 10);
  gfx_r = 0.08; gfx_g = 0.08; gfx_b = 0.25;
  gfx_rect(amp_vis_x - amp_w/2 + 2, amp_vis_y - amp_h/2 + 14, amp_w - 4, amp_h - 16);
  // 8×10 speakers
  gfx_r = 0.03; gfx_g = 0.03; gfx_b = 0.10;
  si = 0;
  loop(4,
    gfx_circle(amp_vis_x - 5, amp_vis_y + (si - 1) * 7 + 4, 3, 1);
    gfx_circle(amp_vis_x + 5, amp_vis_y + (si - 1) * 7 + 4, 3, 1);
    si += 1;
  );
) : (
  // Frenchie: tiny tweed combo — charmingly small
  amp_w = 14; amp_h = 16;
  gfx_r = 0.35; gfx_g = 0.25; gfx_b = 0.12;
  gfx_rect(amp_vis_x - amp_w/2, amp_vis_y - amp_h/2, amp_w, amp_h);
  gfx_r = 0.55; gfx_g = 0.42; gfx_b = 0.20;
  gfx_rect(amp_vis_x - amp_w/2 + 1, amp_vis_y - amp_h/2 + 1, amp_w - 2, amp_h - 5);
  gfx_r = 0.15; gfx_g = 0.10; gfx_b = 0.05;
  gfx_circle(amp_vis_x, amp_vis_y, 4, 1);
);

// Amp label
gfx_r = COL_DIM_R * 0.7; gfx_g = COL_DIM_G * 0.7; gfx_b = COL_DIM_B * 0.7;
gfx_setfont(1, "Arial", 9);
gfx_x = amp_vis_x - 8; gfx_y = amp_vis_y + 20;
amp_model == 0 ? gfx_drawstr("SOB");
amp_model == 1 ? gfx_drawstr("JCM800");
amp_model == 2 ? gfx_drawstr("SVT");
amp_model == 3 ? gfx_drawstr("CHAMP");

// Mic — fixed close position (Room Mix controls reverb send, not mic distance)
mic_x = amp_vis_x + floor(room_bw * 0.15);
mic_x = min(room_bx + room_bw - 20, mic_x);
mic_y = amp_vis_y;
gfx_r = 0.25; gfx_g = 0.25; gfx_b = 0.30;
gfx_line(mic_x, mic_y + 10, mic_x, mic_y - 10);
gfx_r = COL_CYAN_R * 0.8; gfx_g = COL_CYAN_G * 0.8; gfx_b = COL_CYAN_B * 0.8;
gfx_circle(mic_x, mic_y - 10, 4, 1);
gfx_r = COL_DIM_R * 0.7; gfx_g = COL_DIM_G * 0.7; gfx_b = COL_DIM_B * 0.7;
gfx_setfont(1, "Arial", 9);
gfx_x = mic_x - 6; gfx_y = mic_y + 14;
gfx_drawstr("MIC");

// Animated sound waves
sb2 = BC_MY_REGION + bc_my_slot * BC_SLOT_SIZE;
wave_phase = bc_my_slot >= 0 ? gmem[sb2 + 0] * 0.08 : 0;
gfx_r = COL_ACCENT_R * 0.35 * (0.4 + in_gain * 0.6);
gfx_g = COL_ACCENT_G * 0.2;
gfx_b = 0.0;
wave_n = 4;
wi = 0;
loop(wave_n,
  wx = amp_vis_x + 14 + floor((mic_x - amp_vis_x - 14) * (wi + 1) / (wave_n + 1));
  wy_off = floor(sin(wave_phase + wi * 1.1) * 5 * in_gain);
  gfx_circle(wx, amp_vis_y + wy_off, 2, 1);
  wi += 1;
);

// Room type label
gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
gfx_setfont(1, "Arial", 9);
gfx_x = room_bx + 6; gfx_y = room_by + 4;
room_type == 0 ? gfx_drawstr("BEDROOM");
room_type == 1 ? gfx_drawstr("GARAGE");
room_type == 2 ? gfx_drawstr("BASEMENT");
room_type == 3 ? gfx_drawstr("STUDIO");
room_type == 4 ? gfx_drawstr("STAGE");
room_type == 5 ? gfx_drawstr("HALL");

// ============================================================================
//  BROADCAST PANEL
// ============================================================================
bc_rows_per_page = 5;
bc_panel_h = bc_panel_expanded ? (30 + bc_rows_per_page * 14 + 18) : 30;
bc_panel_y = gfx_h - bc_panel_h;

gfx_r = 0.04; gfx_g = 0.04; gfx_b = 0.06;
gfx_rect(0, bc_panel_y, gfx_w, bc_panel_h);
gfx_r = 0.15; gfx_g = 0.15; gfx_b = 0.20;
gfx_rect(0, bc_panel_y, gfx_w, 1);

gfx_setfont(1, "Arial", 11);
gfx_r = 0.95; gfx_g = 0.45; gfx_b = 0.15;
gfx_x = 8; gfx_y = bc_panel_y + 8;
bc_my_slot >= 0 ? (
  gfx_drawstr("I");
  gfx_drawnumber(bc_my_slot + 1, 0);
  gfx_drawstr("/");
  gfx_drawnumber(bc_instance_count, 0);
) : (
  gfx_drawstr("--");
);

bc_following > 0 ? (
  gfx_r = 0.2; gfx_g = 0.8; gfx_b = 0.3;
  gfx_drawstr("  Following: I");
  bc_fs = 0;
  loop(BC_MAX_INST,
    fsb = BC_MY_REGION + bc_fs * BC_SLOT_SIZE;
    gmem[fsb + 1] == bc_following ? (
      gfx_drawnumber(bc_fs + 1, 0);
      bc_fs = BC_MAX_INST;
    );
    bc_fs += 1;
  );
) : (
  gfx_r = 0.3; gfx_g = 0.3; gfx_b = 0.4;
  gfx_drawstr("  Following: --");
);

exp_x = gfx_w - 200; exp_y = bc_panel_y + 4; exp_w = 65; exp_h = 20;
gfx_r = 0.12; gfx_g = 0.12; gfx_b = 0.16;
gfx_rect(exp_x, exp_y, exp_w, exp_h);
gfx_r = 0.5; gfx_g = 0.5; gfx_b = 0.6;
gfx_x = exp_x + 5; gfx_y = exp_y + 4;
bc_panel_expanded ? gfx_drawstr("COLLAPSE") : gfx_drawstr("EXPAND");
(mouse_cap & 1) && !(last_cap & 1) &&
  mouse_x >= exp_x && mouse_x < exp_x + exp_w &&
  mouse_y >= exp_y && mouse_y < exp_y + exp_h ? (
  bc_panel_expanded = !bc_panel_expanded;
  bc_steal_mode = 0;
);

stl_x = gfx_w - 125; stl_y = bc_panel_y + 4; stl_w = 50; stl_h = 20;
bc_steal_mode ? (gfx_r = 0.6; gfx_g = 0.2; gfx_b = 0.1;) : (gfx_r = 0.2; gfx_g = 0.1; gfx_b = 0.1;);
gfx_rect(stl_x, stl_y, stl_w, stl_h);
gfx_r = 0.9; gfx_g = 0.5; gfx_b = 0.2;
gfx_x = stl_x + 6; gfx_y = stl_y + 4;
gfx_drawstr("STEAL");
(mouse_cap & 1) && !(last_cap & 1) &&
  mouse_x >= stl_x && mouse_x < stl_x + stl_w &&
  mouse_y >= stl_y && mouse_y < stl_y + stl_h ? (
  bc_steal_mode = !bc_steal_mode;
  !bc_panel_expanded ? bc_panel_expanded = 1;
);

bc_following > 0 ? (
  unf_x = gfx_w - 65; unf_y = bc_panel_y + 4; unf_w = 55; unf_h = 20;
  gfx_r = 0.1; gfx_g = 0.2; gfx_b = 0.1;
  gfx_rect(unf_x, unf_y, unf_w, unf_h);
  gfx_r = 0.5; gfx_g = 0.9; gfx_b = 0.5;
  gfx_x = unf_x + 4; gfx_y = unf_y + 4;
  gfx_drawstr("UNFLW");
  (mouse_cap & 1) && !(last_cap & 1) &&
    mouse_x >= unf_x && mouse_x < unf_x + unf_w &&
    mouse_y >= unf_y && mouse_y < unf_y + unf_h ? (
    bc_following = 0;
    bc_follow_slot = -1;
  );
);

bc_panel_expanded ? (
  row_y = bc_panel_y + 30;
  row_h = 14;
  bc_my_page = bc_my_slot >= 0 ? floor(bc_my_slot / bc_rows_per_page) : 0;
  bc_page < 0 ? bc_page = 0;
  bc_active_slots = 0;
  bc_si = 0;
  loop(BC_MAX_INST,
    gmem[BC_MY_REGION + bc_si * BC_SLOT_SIZE + 1] > 0 ? bc_active_slots += 1;
    bc_si += 1;
  );
  bc_total_pages = max(1, ceil(bc_active_slots / bc_rows_per_page));
  bc_page >= bc_total_pages ? bc_page = bc_total_pages - 1;

  pg_btn_w = 18; pg_btn_h = 14;
  pg_prev_x = 8; pg_prev_y = bc_panel_y + 30 + bc_rows_per_page * row_h + 2;
  bc_total_pages > 1 ? (
    gfx_r = 0.25; gfx_g = 0.25; gfx_b = 0.32;
    gfx_rect(pg_prev_x, pg_prev_y, pg_btn_w, pg_btn_h);
    gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.8;
    gfx_x = pg_prev_x + 4; gfx_y = pg_prev_y + 2;
    gfx_drawstr("<");
    (mouse_cap & 1) && !(last_cap & 1) &&
      mouse_x >= pg_prev_x && mouse_x < pg_prev_x + pg_btn_w &&
      mouse_y >= pg_prev_y && mouse_y < pg_prev_y + pg_btn_h ? (
      bc_page > 0 ? bc_page -= 1;
    );
    gfx_r = 0.25; gfx_g = 0.25; gfx_b = 0.32;
    gfx_rect(pg_prev_x + pg_btn_w + 2, pg_prev_y, pg_btn_w, pg_btn_h);
    gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.8;
    gfx_x = pg_prev_x + pg_btn_w + 6; gfx_y = pg_prev_y + 2;
    gfx_drawstr(">");
    (mouse_cap & 1) && !(last_cap & 1) &&
      mouse_x >= pg_prev_x + pg_btn_w + 2 && mouse_x < pg_prev_x + pg_btn_w * 2 + 2 &&
      mouse_y >= pg_prev_y && mouse_y < pg_prev_y + pg_btn_h ? (
      bc_page < bc_total_pages - 1 ? bc_page += 1;
    );
    gfx_r = 0.4; gfx_g = 0.4; gfx_b = 0.5;
    gfx_x = pg_prev_x + pg_btn_w * 2 + 8; gfx_y = pg_prev_y + 2;
    gfx_drawnumber(bc_page + 1, 0);
    gfx_drawstr("/");
    gfx_drawnumber(bc_total_pages, 0);
  );

  bc_page_start = bc_page * bc_rows_per_page;
  bc_page_end = bc_page_start + bc_rows_per_page - 1;
  bc_visible = 0;
  bc_s = 0;
  loop(BC_MAX_INST,
    isb = BC_MY_REGION + bc_s * BC_SLOT_SIZE;
    isid = gmem[isb + 1];
    isid > 0 ? (
      bc_visible >= bc_page_start && bc_visible <= bc_page_end ? (
        draw_row_y = row_y + (bc_visible - bc_page_start) * row_h;
        mouse_y >= draw_row_y && mouse_y < draw_row_y + row_h &&
          mouse_x >= 8 && mouse_x < gfx_w - 8 &&
          bc_s != bc_my_slot ? (
          gfx_r = 0.10; gfx_g = 0.10; gfx_b = 0.14;
          gfx_rect(4, draw_row_y, gfx_w - 8, row_h);
        );
        gfx_setfont(1, "Arial", 10);
        bc_s == bc_my_slot ? (
          gfx_r = 0.95; gfx_g = 0.45; gfx_b = 0.15;
        ) : (
          gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.8;
        );
        gfx_x = 12; gfx_y = draw_row_y + 1;
        gfx_drawstr("I");
        gfx_drawnumber(bc_s + 1, 0);
        gfx_drawstr("  ");
        bc_s == bc_my_slot ? (
          gfx_drawstr("[YOU]");
        ) : (
          iwho = gmem[isb + 3];
          bc_has_follower = 0;
          bc_fsc = 0;
          loop(BC_MAX_INST,
            fsb2 = BC_MY_REGION + bc_fsc * BC_SLOT_SIZE;
            gmem[fsb2 + 1] > 0 && gmem[fsb2 + 3] == isid ? bc_has_follower = 1;
            bc_fsc += 1;
          );
          iwho > 0 ? (
            gfx_r = 0.4; gfx_g = 0.6; gfx_b = 0.9;
            gfx_drawstr("[FOLLOWER]");
          ) : bc_has_follower ? (
            gfx_r = 0.95; gfx_g = 0.78; gfx_b = 0.35;
            gfx_drawstr("[LEADER]");
          ) : (
            gfx_r = 0.38; gfx_g = 0.38; gfx_b = 0.45;
            gfx_drawstr("[UNASSIGNED]");
          );
          gfx_r = 0.35; gfx_g = 0.45; gfx_b = 0.35;
          bc_steal_mode ? gfx_drawstr("  click: steal") : gfx_drawstr("  click: follow");
          (mouse_cap & 1) && !(last_cap & 1) &&
            mouse_y >= draw_row_y && mouse_y < draw_row_y + row_h &&
            mouse_x >= 8 && mouse_x < gfx_w - 8 ? (
            bc_steal_mode ? (
              bc_steal_target = isid;
              bc_steal_pending = 1;
              bc_steal_mode = 0;
            ) : (
              bc_can_follow = 1;
              bc_cursor = isid;
              bc_hops = 0;
              while(bc_cursor > 0 && bc_hops < BC_MAX_INST) (
                bc_cursor == bc_my_id ? (
                  bc_can_follow = 0;
                  bc_cursor = 0;
                ) : (
                  bc_next = 0;
                  bc_cs = 0;
                  loop(BC_MAX_INST,
                    csb = BC_MY_REGION + bc_cs * BC_SLOT_SIZE;
                    gmem[csb + 1] == bc_cursor ? (
                      bc_next = gmem[csb + 3];
                      bc_cs = BC_MAX_INST;
                    );
                    bc_cs += 1;
                  );
                  bc_cursor = bc_next;
                );
                bc_hops += 1;
              );
              bc_can_follow ? bc_following = isid;
            );
          );
        );
      );
      bc_visible += 1;
    );
    bc_s += 1;
  );
);

last_cap = mouse_cap;

// NOTICE
notice_btn_x = gfx_w - 60;
notice_btn_y = bc_panel_y - 18;
gfx_r = 0.6; gfx_g = 0.5; gfx_b = 0.3;
gfx_rect(notice_btn_x, notice_btn_y, 55, 15);
gfx_r = 0; gfx_g = 0; gfx_b = 0;
gfx_x = notice_btn_x + 4; gfx_y = notice_btn_y + 2;
gfx_drawstr("NOTICE");
(mouse_cap & 1) && mouse_x >= notice_btn_x && mouse_x <= notice_btn_x + 55 && mouse_y >= notice_btn_y && mouse_y <= notice_btn_y + 15 && !notice_clicked ? (
  notice_show = !notice_show;
  notice_clicked = 1;
);
!(mouse_cap & 1) ? notice_clicked = 0;
notice_show ? (
  gfx_r = 0.05; gfx_g = 0.05; gfx_b = 0.05; gfx_a = 0.95;
  gfx_rect(0, 0, gfx_w, gfx_h);
  gfx_a = 1;
  gfx_r = 0.9; gfx_g = 0.8; gfx_b = 0.5;
  gfx_x = 15; gfx_y = 10;
  gfx_drawstr("NOTICE: THEY ARE TRYING TO STEAL YOUR COMPUTER");
  gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.7;
  gfx_x = 15; gfx_y = 30;
  gfx_drawstr("The algorithms in our favorite software are decades old.");
  gfx_x = 15; gfx_y = 45;
  gfx_drawstr("A mathematical model is a truth about the world,");
  gfx_x = 15; gfx_y = 60;
  gfx_drawstr("not a copyrightable product. You do not have to stay");
  gfx_x = 15; gfx_y = 75;
  gfx_drawstr("a slave to subscription software. Install Linux.");
  gfx_x = 15; gfx_y = 90;
  gfx_drawstr("Build your own tools. Believe in yourself.");
  gfx_r = 0.5; gfx_g = 0.7; gfx_b = 1.0;
  gfx_x = 15; gfx_y = 115;
  gfx_drawstr("github.com/LMSBAND  |  instagram.com/LMSSKABAND");
  gfx_r = 0.6; gfx_g = 0.5; gfx_b = 0.3;
  gfx_rect(notice_btn_x, notice_btn_y, 55, 15);
  gfx_r = 0; gfx_g = 0; gfx_b = 0;
  gfx_x = notice_btn_x + 4; gfx_y = notice_btn_y + 2;
  gfx_drawstr("NOTICE");
);

@serialize
file_var(0, bc_following);
file_var(0, bc_my_id);
