desc:LMS - The Basswoman v2 (Density-Aware Bassman)
//tags: amp guitar bass fender bassman density-aware
//author: LMS
//version: 1.0
//license: GPL-3.0
filename:0,shakebot_logo.png

import lms_core.jsfx-inc
options:gmem=DrumBagger

slider1:-12<-24,24,0.1>-Input Level (dB)
slider2:50<0,100,0.1>-Gain (%)
slider3:0<0,1,1{Normal,Bright}>-Channel
slider4:50<0,100,1>-Bass (%)
slider5:50<0,100,1>-Mid (%)
slider6:50<0,100,1>-Treble (%)
slider7:50<0,100,1>-Presence (%)
slider8:50<0,100,1>-Master (%)
slider9:50<0,100,1>-Input Stage (%)
slider10:50<0,100,1>-PSU Sag (%)
slider11:-12<-24,24,0.1>-Output Level (dB)
slider12:0<0,1,1{Off,On}>-FX Bypass
// --- SPRING REVERB ---
slider13:0<0,100,1>-Spring Reverb (%)
// slider14 removed (dwell)
// --- TREMOLO ---
slider15:0<0,100,1>-Tremolo Depth (%)
slider16:50<0,100,1>-Tremolo Speed (%)
// --- TAPE ECHO ---
slider17:0<0,100,1>-Tape Echo Mix (%)
slider18:40<0,100,1>-Echo Feedback (%)
// --- CABINET ---
slider19:9<0,11,1{Off,1x12 Greenback,1x12 Jensen,1x12 Blue,2x12 Jensen,4x12 G12T-75,4x12 V30,8x10 Sealed,4x12 Sheffield,1x15 Open,4x10 Sealed,Orange PPC412}>-Cabinet
slider20:1<0,1,1{Off,On}>-Cab Sim
slider21:0<0,100,1>-Mic Distance (%)
// --- CABINET B ---
slider22:0<0,11,1{Off,1x12 Greenback,1x12 Jensen,1x12 Blue,2x12 Jensen,4x12 G12T-75,4x12 V30,8x10 Sealed,4x12 Sheffield,1x15 Open,4x10 Sealed,Orange PPC412}>-Cabinet B
slider23:0<0,100,1>-Mic B Distance (%)
// --- IMPEDANCE TAP ---
slider24:1<0,2,1{4 ohm,8 ohm,16 ohm}>-Impedance Tap

@init

// === TUNER ===
tuner.lms_yin_init(20000);
tuner_disp_freq = 0;
tuner_disp_conf = 0;
tuner_disp_cents = 0;
tuner_disp_note = -1;
tuner_smooth = 0;

// === CORE MATH ===
function tanh_approx(x) local(e2x) ( x > 10 ? 1 : x < -10 ? -1 : ( e2x = exp(2*x); (e2x-1)/(e2x+1); ); );

function bq_init() ( this.b0=1; this.b1=0; this.b2=0; this.a1=0; this.a2=0; this.x1=0; this.x2=0; this.y1=0; this.y2=0; );
function bq_set_lp(freq, q) local(w0, cs, sn, alpha, a0_inv) ( w0=2*$pi*freq/srate; cs=cos(w0); sn=sin(w0); alpha=sn/(2*q); a0_inv=1/(1+alpha); this.b0=(1-cs)/2*a0_inv; this.b1=(1-cs)*a0_inv; this.b2=(1-cs)/2*a0_inv; this.a1=-2*cs*a0_inv; this.a2=(1-alpha)*a0_inv; );
function bq_set_hp(freq, q) local(w0, cs, sn, alpha, a0_inv) ( w0=2*$pi*freq/srate; cs=cos(w0); sn=sin(w0); alpha=sn/(2*q); a0_inv=1/(1+alpha); this.b0=(1+cs)/2*a0_inv; this.b1=-(1+cs)*a0_inv; this.b2=(1+cs)/2*a0_inv; this.a1=-2*cs*a0_inv; this.a2=(1-alpha)*a0_inv; );
function bq_set_peak(freq, gain_db, q) local(a, w0, alpha, a0_inv) ( a=10^(gain_db/20); w0=2*$pi*freq/srate; alpha=sin(w0)/(2*q); a0_inv=1/(1+alpha/a); this.b0=(1+alpha*a)*a0_inv; this.b1=(-2*cos(w0))*a0_inv; this.b2=(1-alpha*a)*a0_inv; this.a1=this.b1; this.a2=(1-alpha/a)*a0_inv; );
function bq_set_loshelf(freq, gain_db, q) local(a, w0, cs, sn, alpha, ap1, am1, beta, a0_inv) ( a=10^(gain_db/40); w0=2*$pi*freq/srate; cs=cos(w0); sn=sin(w0); alpha=sn/(2*q); ap1=a+1; am1=a-1; beta=2*sqrt(a)*alpha; a0_inv=1/(ap1+am1*cs+beta); this.b0=a*(ap1-am1*cs+beta)*a0_inv; this.b1=2*a*(am1-ap1*cs)*a0_inv; this.b2=a*(ap1-am1*cs-beta)*a0_inv; this.a1=-2*(am1+ap1*cs)*a0_inv; this.a2=(ap1+am1*cs-beta)*a0_inv; );
function bq_set_hishelf(freq, gain_db, q) local(a, w0, cs, sn, alpha, ap1, am1, beta, a0_inv) ( a=10^(gain_db/40); w0=2*$pi*freq/srate; cs=cos(w0); sn=sin(w0); alpha=sn/(2*q); ap1=a+1; am1=a-1; beta=2*sqrt(a)*alpha; a0_inv=1/(ap1-am1*cs+beta); this.b0=a*(ap1+am1*cs+beta)*a0_inv; this.b1=-2*a*(am1+ap1*cs)*a0_inv; this.b2=a*(ap1+am1*cs-beta)*a0_inv; this.a1=2*(am1-ap1*cs)*a0_inv; this.a2=(ap1-am1*cs-beta)*a0_inv; );
function bq_proc(x) local(o) ( o=this.b0*x + this.b1*this.x1 + this.b2*this.x2 - this.a1*this.y1 - this.a2*this.y2; this.x2=this.x1; this.x1=x; this.y2=this.y1; this.y1=o; o; );
function dc_init() ( this.xp=0; this.yp=0; this.r=1-(20/srate); );
function dc_proc(x) ( this.yp=x-this.xp+this.r*this.yp; this.xp=x; this.yp; );

// === INPUT STAGE (5F6-A grid physics — 1M grid leak, tweed Bassman) ===
// Bassman input: warm, fat, designed for bass & guitar
function input_stage_init() (
  this.cap_charge = 0.0;
  this.cap_charge_rate = exp(-1/(srate * 0.0005));
  this.cap_drain_rate = exp(-1/(srate * 0.035));  // slightly slower drain (tweed caps)
  this.input_lp.bq_init();
  this.input_lp.bq_set_lp(4200, 0.55);  // warmer than blackface (tweed input)
  this.cathode_shelf.bq_init();
  this.cathode_shelf.bq_set_hishelf(1000, -2.0, 0.5);  // 12AY7 cathode shelf (warmer)
  this.peak_env = 0;
  this.peak_att = exp(-1/(srate * 0.0002));
  this.peak_rel = exp(-1/(srate * 0.050));
);
function input_stage_proc(x, intensity) local(loaded, dry, bias_shift, biased, grid_thresh, conducted) (
  loaded = this.input_lp.bq_proc(x);
  loaded = x + intensity * (loaded - x);
  loaded > 0.1 ? (
    this.cap_charge = this.cap_charge_rate * this.cap_charge + (1-this.cap_charge_rate) * loaded * 0.15 * intensity;
  ) : (
    this.cap_charge = this.cap_drain_rate * this.cap_charge;
  );
  bias_shift = this.cap_charge;
  biased = loaded - bias_shift;
  grid_thresh = 1.0 - intensity * 0.85;
  biased > grid_thresh ? (
    conducted = grid_thresh + tanh_approx((biased - grid_thresh) * (1.0 + intensity * 3.0)) * (0.05 + intensity * 0.15);
  ) : (
    conducted = biased;
  );
  dry = conducted;
  conducted = this.cathode_shelf.bq_proc(conducted);
  conducted = dry + intensity * (conducted - dry);
  abs(x) > this.peak_env ? (
    this.peak_env = this.peak_att * this.peak_env + (1-this.peak_att) * abs(x);
  ) : (
    this.peak_env = this.peak_rel * this.peak_env + (1-this.peak_rel) * abs(x);
  );
  conducted;
);

// === PSU SAG (5U4 tube rectifier — the saggiest Fender rectifier) ===
// 5U4: high internal resistance, slow recovery. Notes "bloom" as supply recovers.
// More sag than Deluxe's 5U4GB, less than Champ's 5Y3.
// Attack ~4ms (tube takes time to conduct under load).
// Recovery ~150ms (moderate filter caps + tube rectifier resistance).
// Max droop 22% — between Champ's 30% and Deluxe's 18%.
function psu_init() (
  this.voltage = 1.0;
  this.droop_amount = 0.0;
  this.att = exp(-1/(srate * 0.004));
  this.rel = exp(-1/(srate * 0.150));
);
function psu_proc(signal_level, sag_depth)
  local(draw)
(
  draw = signal_level * signal_level;
  draw > this.droop_amount ? (
    this.droop_amount = this.att * this.droop_amount + (1-this.att) * draw;
  ) : (
    this.droop_amount = this.rel * this.droop_amount + (1-this.rel) * draw;
  );
  this.voltage = 1.0 - this.droop_amount * 0.22 * sag_depth;
  this.voltage = max(0.65, min(1.0, this.voltage));
  this.voltage;
);

// === 4-BAND HARMONIC DENSITY TRACKER ===
function hd_init() (
  this.f_lo.bq_init(); this.f_lo.bq_set_lp(250, 0.7);
  this.f_mid_lo.bq_init(); this.f_mid_lo.bq_set_lp(2000, 0.7);
  this.f_mid_hi.bq_init(); this.f_mid_hi.bq_set_hp(250, 0.7);
  this.f_hi.bq_init(); this.f_hi.bq_set_hp(2000, 0.7);
  this.f_air.bq_init(); this.f_air.bq_set_hp(5000, 0.7);
  this.env_lo=0; this.env_mid=0; this.env_hi=0; this.env_air=0; this.env_total=0;
  this.att=exp(-1/(srate*0.002)); this.rel=exp(-1/(srate*0.080));
  this.density=1.0; this.mid_density=0.0; this.hi_density=0.0; this.air_density=0.0;
  this.smooth=exp(-1/(srate*0.030));
);
function hd_proc(x) local(lo, mid, hi, air, abs_lo, abs_mid, abs_hi, abs_air, abs_total, raw, raw_mid, raw_hi, raw_air) (
  lo=this.f_lo.bq_proc(x);
  mid=this.f_mid_hi.bq_proc(this.f_mid_lo.bq_proc(x));
  hi=this.f_hi.bq_proc(x);
  air=this.f_air.bq_proc(x);
  abs_lo=abs(lo); abs_mid=abs(mid); abs_hi=abs(hi); abs_air=abs(air); abs_total=abs(x);
  abs_lo > this.env_lo ? ( this.env_lo=this.att*this.env_lo+(1-this.att)*abs_lo; ) : ( this.env_lo=this.rel*this.env_lo+(1-this.rel)*abs_lo; );
  abs_mid > this.env_mid ? ( this.env_mid=this.att*this.env_mid+(1-this.att)*abs_mid; ) : ( this.env_mid=this.rel*this.env_mid+(1-this.rel)*abs_mid; );
  abs_hi > this.env_hi ? ( this.env_hi=this.att*this.env_hi+(1-this.att)*abs_hi; ) : ( this.env_hi=this.rel*this.env_hi+(1-this.rel)*abs_hi; );
  abs_air > this.env_air ? ( this.env_air=this.att*this.env_air+(1-this.att)*abs_air; ) : ( this.env_air=this.rel*this.env_air+(1-this.rel)*abs_air; );
  abs_total > this.env_total ? ( this.env_total=this.att*this.env_total+(1-this.att)*abs_total; ) : ( this.env_total=this.rel*this.env_total+(1-this.rel)*abs_total; );
  this.env_lo > 0.0001 ? ( raw=this.env_total/this.env_lo; raw=min(2.5,max(1.0,raw)); ) : ( raw=1.0; );
  this.env_total > 0.0001 ? (
    raw_mid=this.env_mid/this.env_total; raw_mid=min(1.0,max(0.0,raw_mid));
    raw_hi=this.env_hi/this.env_total; raw_hi=min(1.0,max(0.0,raw_hi));
    raw_air=this.env_air/this.env_total; raw_air=min(1.0,max(0.0,raw_air));
  ) : ( raw_mid=0.0; raw_hi=0.0; raw_air=0.0; );
  this.density=this.smooth*this.density+(1-this.smooth)*raw;
  this.mid_density=this.smooth*this.mid_density+(1-this.smooth)*raw_mid;
  this.hi_density=this.smooth*this.hi_density+(1-this.smooth)*raw_hi;
  this.air_density=this.smooth*this.air_density+(1-this.smooth)*raw_air;
);

// =========================================================================
// === DENSITY-AWARE TRIODE (v2b — proven architecture) ===
// =========================================================================
function triode_init(hp_freq, lp_freq) (
  this.hp.bq_init();
  this.hp.bq_set_hp(hp_freq, 0.7);
  this.cap_charge = 0.0;
  this.cap_charge_rate = exp(-1/(srate * 0.0005));
  this.cap_drain_rate = exp(-1/(srate * 0.030));
  this.miller.bq_init();
  this.miller.bq_set_lp(lp_freq, 0.6);
  this.miller_base_freq = lp_freq;
  this.last_miller_freq = lp_freq;
  this.last_miller_q = 0.6;
  this.air_shelf.bq_init();
  this.air_shelf.bq_set_hishelf(4000, 0.0, 0.7);
  this.last_air_cut = 0.0;
  this.hd.hd_init();
  this.dc.dc_init();
  this.peak_env = 0;
  this.peak_att = exp(-1/(srate * 0.0002));
  this.peak_rel = exp(-1/(srate * 0.050));
);
function triode_proc(x, drive, bplus, pos_hard, neg_hard, pos_ceil, neg_ceil, gc_thresh, gc_amount)
  local(b, gain, bias_shift, p_ceil, n_ceil, gc_out, lp_freq, lp_q, air_cut, drive_boost, ax)
(
  b = this.hp.bq_proc(x);
  b > 0.1 ? (
    this.cap_charge = this.cap_charge_rate * this.cap_charge + (1-this.cap_charge_rate) * b * 0.12;
  ) : (
    this.cap_charge = this.cap_drain_rate * this.cap_charge;
  );
  bias_shift = this.cap_charge;
  b = b - bias_shift;
  drive_boost = 1.0 + this.hd.mid_density * 0.4;
  gain = (1.0 + drive * 4.0) * drive_boost;
  b = b * gain;
  this.hd.hd_proc(b);
  p_ceil = pos_ceil * bplus;
  n_ceil = neg_ceil * bplus;
  b >= 0 ? (
    b = tanh_approx(b * pos_hard) * p_ceil;
  ) : (
    b = tanh_approx(b * neg_hard) * n_ceil;
  );
  ax = abs(b);
  ax > this.peak_env ? (
    this.peak_env = this.peak_att * this.peak_env + (1-this.peak_att) * ax;
  ) : (
    this.peak_env = this.peak_rel * this.peak_env + (1-this.peak_rel) * ax;
  );
  b > gc_thresh && this.peak_env > gc_thresh * 0.8 ? (
    gc_out = gc_thresh + tanh_approx((b - gc_thresh) * 3.0) * gc_amount;
    b = gc_out;
  );
  lp_freq = this.miller_base_freq - (this.hd.density - 1.0) * 500;
  lp_freq = max(this.miller_base_freq - 1500, min(this.miller_base_freq + 500, lp_freq));
  lp_q = 0.6 + this.hd.hi_density * 0.35;
  lp_q = max(0.6, min(0.95, lp_q));
  abs(lp_freq - this.last_miller_freq) > 30 || abs(lp_q - this.last_miller_q) > 0.02 ? (
    this.miller.bq_set_lp(lp_freq, lp_q);
    this.last_miller_freq = lp_freq;
    this.last_miller_q = lp_q;
  );
  b = this.miller.bq_proc(b);
  air_cut = -this.hd.air_density * 3.0;
  air_cut = max(-3.0, min(0.0, air_cut));
  abs(air_cut - this.last_air_cut) > 0.1 ? (
    this.air_shelf.bq_set_hishelf(4000, air_cut, 0.7);
    this.last_air_cut = air_cut;
  );
  b = this.air_shelf.bq_proc(b);
  b = this.dc.dc_proc(b);
  b;
);

// === CATHODE FOLLOWER (V1b — unity-gain buffer before tone stack) ===
// 5F6-A: CF between V1a plate and tone stack. Prevents loading.
// Bassman CF: slightly more compression than blackface (warmer cathode bias).
function cathode_follower_init() (
  this.hp.bq_init();
  this.hp.bq_set_hp(10, 0.7);
  this.dc.dc_init();
  this.bias_env = 0;
  this.bias_att = exp(-1/(srate * 0.002));
  this.bias_rel = exp(-1/(srate * 0.070));
  this.cf_lp.bq_init();
  this.cf_lp.bq_set_lp(15000, 0.5);
);
function cathode_follower_proc(x, bplus) local(b, ax, bias_shift) (
  b = this.hp.bq_proc(x);
  ax = abs(b);
  ax > this.bias_env ? (
    this.bias_env = this.bias_att * this.bias_env + (1-this.bias_att) * ax;
  ) : (
    this.bias_env = this.bias_rel * this.bias_env + (1-this.bias_rel) * ax;
  );
  bias_shift = this.bias_env * 0.18;  // up to 18% gain reduction (Fender CF)
  // Positive: soft clip (cathode current limiting)
  b > 0.7 * bplus ? (
    b = 0.7 * bplus + tanh_approx((b - 0.7 * bplus) * 2.0) * 0.25 * bplus;
  );
  // Negative: harder cutoff
  b < -0.85 * bplus ? (
    b = -0.85 * bplus;
  );
  b = b * (1.0 - bias_shift);
  b = this.cf_lp.bq_proc(b);
  b = this.dc.dc_proc(b);
  b * 0.95;
);

// === BASSMAN TONE STACK (5F6-A passive — THE original Fender TMB) ===
// Bass: 250k pot, 0.1uF cap → ~40-180Hz (deeper than blackface)
// Mid: 10k pot, 0.047uF cap → ~600Hz (less scoop than AB763)
// Treble: 250k pot, 250pF cap → ~800-4kHz
// The Bassman tone stack is THE circuit that Marshall copied for the JTM45.
// More bass, less mid scoop than blackface Twin. Warm and full at noon.
function fender_tonestack_init() (
  this.f_bass.bq_init();
  this.f_mid.bq_init();
  this.f_treb.bq_init();
);
function fender_tonestack_set(bass, mid, treble) local(bass_db, mid_db, treb_db, bass_freq, treb_freq, mid_q) (
  // Bass: 40-170Hz shelf, ±10dB (deeper than blackface — designed for bass guitar)
  bass_freq = 40 + bass * 130;
  bass_db = (bass - 0.5) * 20;
  this.f_bass.bq_set_loshelf(bass_freq, bass_db, 0.50);
  // Mid: 600Hz peak, ±6dB (LESS scoop than blackface — warmer, fuller mids)
  // The Bassman mid is what makes it feel "thick" and "present"
  mid_q = 0.7 + mid * 1.2;
  mid_db = (0.5 - mid) * 12;  // mid knob is a CUT but less extreme than Twin
  // Slight cross-coupling (tweed controls interact more than blackface)
  mid_db -= (bass - 0.5) * 2.5 + (treble - 0.5) * 1.0;
  this.f_mid.bq_set_peak(600, mid_db, mid_q);
  // Treble: 800-4000Hz shelf, ±8dB (slightly warmer top than Twin)
  treb_freq = 800 + treble * 3200;
  treb_db = (treble - 0.5) * 16;
  this.f_treb.bq_set_hishelf(treb_freq, treb_db, 0.65);
);
function fender_tonestack_proc(x) local(b) (
  b = this.f_bass.bq_proc(x);
  b = this.f_mid.bq_proc(b);
  b = this.f_treb.bq_proc(b);
  b;
);

// === BASSMAN POWER AMP (2×6L6 push-pull, 50W — cathode-biased, saggy, warm) ===
// 5F6-A tweed Bassman: cathode-biased 6L6 (unlike Twin's fixed bias).
// Cathode bias = more compression, more sag, more "bloom" on transients.
// 50W output transformer: between Twin (85W) and Deluxe (22W).
// Saturates earlier than Twin, later than Deluxe — the sweet spot.
// LESS NFB than blackface (6dB vs Twin's 10dB) = more alive, warmer, touch-sensitive.
// Transformer winding resonance at 3.2kHz (medium-sized transformer).
function bassman_poweramp_init() (
  this.hd.hd_init();
  this.dc.dc_init();
  this.pres_f.bq_init();
  this.nfb_lp.bq_init();
  this.nfb_lp.bq_set_lp(4000, 0.5);
  this.last_nfb_freq = 4000;
  this.drive = 0;
  // Output transformer saturation (50W OT — medium, moderate saturation)
  this.xfmr_lp = 0;
  // Winding resonance: 3.2kHz +2.0dB Q=1.8 (medium transformer)
  this.xfmr_res.bq_init();
  this.xfmr_res.bq_set_peak(3200, 2.0, 1.8);
  // Cathode bias shift (6L6 cathode-biased — MORE compression than fixed-bias Twin)
  // This is the "spongy" feel that defines the tweed Bassman
  this.cathode_charge = 0;
  this.cathode_att = exp(-1/(srate * 0.004));
  this.cathode_rel = exp(-1/(srate * 0.100));
);
function bassman_poweramp_set(drive, presence) local(pres_freq, pres_db, pres_q) (
  this.drive = drive;
  // Presence in NFB loop (less NFB = presence has more effect)
  pres_freq = 2000 + presence * 4500;
  pres_db = presence * 7;
  pres_q = 0.9 + presence * 0.9;
  this.pres_f.bq_set_peak(pres_freq, pres_db, pres_q);
);
function bassman_poweramp_proc(x, bplus)
  local(b, push, pull, out, cathode_shift, signal_level, nfb_freq, xfmr_sat, lo_content, hi_content, lo_saturated, lo_final)
(
  b = x * (1.0 + this.drive * 2.2);
  this.hd.hd_proc(b);

  // Cathode bias shift — cathode-biased 6L6 = significant compression
  // This is the "spongy" response: loud transients shift the bias colder
  signal_level = abs(b);
  signal_level > this.cathode_charge ? (
    this.cathode_charge = this.cathode_att * this.cathode_charge + (1-this.cathode_att) * signal_level;
  ) : (
    this.cathode_charge = this.cathode_rel * this.cathode_charge + (1-this.cathode_rel) * signal_level;
  );
  cathode_shift = this.cathode_charge * 0.14;  // 14% — between Twin (8%) and Deluxe (15%)
  b = b * (1.0 - cathode_shift);

  // 6L6 push-pull (cathode-biased) — moderate headroom, warm breakup
  // More headroom than Deluxe 6V6 but breaks up earlier than fixed-bias Twin.
  // Cathode bias creates subtle asymmetry in push-pull = more even harmonics.
  push = b > 0 ? b : 0;
  push = tanh_approx(push * 1.5) * bplus;  // softer than fixed-bias Twin (1.6)
  pull = b < 0 ? -b : 0;
  pull = tanh_approx(pull * 1.45) * bplus;  // more mismatch (cathode bias drift)

  out = push - pull;

  // Output transformer saturation — 50W OT, moderate saturation
  // Between Twin (85W, ×1.8) and Deluxe (22W, ×3.0)
  xfmr_sat = this.hd.env_lo;
  xfmr_sat = min(1.0, xfmr_sat * 2.4);  // medium sensitivity
  xfmr_sat > 0.05 ? (
    this.xfmr_lp = this.xfmr_lp * 0.984 + out * 0.016;  // ~125Hz one-pole LP
    lo_content = this.xfmr_lp;
    hi_content = out - lo_content;
    lo_saturated = tanh_approx(lo_content * (1.0 + xfmr_sat * 1.0))
                   / (1.0 + xfmr_sat * 0.20);
    lo_final = lo_content + xfmr_sat * (lo_saturated - lo_content);
    out = lo_final + hi_content;
  );

  // Transformer winding resonance (3.2kHz — medium transformer)
  out = this.xfmr_res.bq_proc(out);

  // NFB: Bassman has LESS NFB than any blackface (6dB vs Twin's 10dB)
  // This is why it feels "alive" and touch-sensitive — less correction.
  nfb_freq = 4000 - (this.hd.density - 1.0) * 800;
  nfb_freq = max(2500, min(5000, nfb_freq));
  abs(nfb_freq - this.last_nfb_freq) > 50 ? (
    this.nfb_lp.bq_set_lp(nfb_freq, 0.5);
    this.last_nfb_freq = nfb_freq;
  );
  out = this.nfb_lp.bq_proc(out);

  // Presence (in NFB loop — more effect due to less overall NFB)
  out = this.pres_f.bq_proc(out);
  out = this.dc.dc_proc(out);
  out * 0.85;
);

// === SOFT GATE ===
function sgate_init() (
  this.env = 0;
  this.att = exp(-1/(srate * 0.0005));
  this.rel = exp(-1/(srate * 0.150));
);
function sgate_proc(x) local(ax, gate_gain) (
  ax = abs(x);
  ax > this.env ? (
    this.env = this.att * this.env + (1-this.att) * ax;
  ) : (
    this.env = this.rel * this.env + (1-this.rel) * ax;
  );
  this.env > 0.001 ? ( gate_gain = 1.0; )
  : this.env < 0.0002 ? ( gate_gain = 0.0; )
  : (
    gate_gain = (this.env - 0.0002) / 0.0008;
    gate_gain = gate_gain * gate_gain * (3.0 - 2.0 * gate_gain);
  );
  x * gate_gain;
);

// === SPRING REVERB (Fender 3-spring tank — long, warm, drippy) ===
// Bassman reverb: same Fender 3-spring tank design.
// 3-spring tank: longer decay, more diffuse, more "boing" than Champ's single spring.
// Slightly brighter feedback LP (springs are longer = more HF return).
function spring_init() (
  this.buf_base = 50000;
  this.pd_off = 0;       this.pd_len = 337;    this.pd_pos = 0;
  this.ap1_off = 400;    this.ap1_len = 1087;  this.ap1_pos = 0;
  this.ap2_off = 1500;   this.ap2_len = 1483;  this.ap2_pos = 0;
  this.ap3_off = 3000;   this.ap3_len = 1801;  this.ap3_pos = 0;
  this.ap4_off = 4900;   this.ap4_len = 2213;  this.ap4_pos = 0;
  this.fb_off = 7200;    this.fb_len = 3571;   this.fb_pos = 0;
  this.fb_val = 0;
  this.fb_lp.bq_init();
  this.fb_lp.bq_set_lp(3000, 0.5);  // brighter than Champ (3-spring = more HF return)
  this.in_lp.bq_init();
  this.in_lp.bq_set_lp(4500, 0.6);  // brighter input (Fender reverb driver tube)
  memset(this.buf_base, 0, 11000);
);
function spring_proc(x, mix) local(input, ap_out, delayed, fb, wet, coeff) (
  input = this.in_lp.bq_proc(x);
  coeff = 0.30;
  delayed = (this.buf_base + this.pd_off)[this.pd_pos];
  (this.buf_base + this.pd_off)[this.pd_pos] = input + this.fb_val * coeff;
  this.pd_pos += 1; this.pd_pos >= this.pd_len ? this.pd_pos = 0;
  ap_out = delayed;
  fb = (this.buf_base + this.ap1_off)[this.ap1_pos];
  (this.buf_base + this.ap1_off)[this.ap1_pos] = ap_out + fb * 0.50;
  ap_out = fb - ap_out * 0.50;
  this.ap1_pos += 1; this.ap1_pos >= this.ap1_len ? this.ap1_pos = 0;
  fb = (this.buf_base + this.ap2_off)[this.ap2_pos];
  (this.buf_base + this.ap2_off)[this.ap2_pos] = ap_out + fb * 0.50;
  ap_out = fb - ap_out * 0.50;
  this.ap2_pos += 1; this.ap2_pos >= this.ap2_len ? this.ap2_pos = 0;
  fb = (this.buf_base + this.ap3_off)[this.ap3_pos];
  (this.buf_base + this.ap3_off)[this.ap3_pos] = ap_out + fb * 0.45;
  ap_out = fb - ap_out * 0.45;
  this.ap3_pos += 1; this.ap3_pos >= this.ap3_len ? this.ap3_pos = 0;
  fb = (this.buf_base + this.ap4_off)[this.ap4_pos];
  (this.buf_base + this.ap4_off)[this.ap4_pos] = ap_out + fb * 0.40;
  ap_out = fb - ap_out * 0.40;
  this.ap4_pos += 1; this.ap4_pos >= this.ap4_len ? this.ap4_pos = 0;
  this.fb_val = this.fb_lp.bq_proc(ap_out);
  this.fb_val = max(-0.9, min(0.9, this.fb_val));
  wet = (this.buf_base + this.fb_off)[this.fb_pos];
  (this.buf_base + this.fb_off)[this.fb_pos] = ap_out;
  this.fb_pos += 1; this.fb_pos >= this.fb_len ? this.fb_pos = 0;
  wet = (ap_out + wet * 0.35) * 0.7;  // slightly longer tail than Champ
  x + wet * mix;
);

// === TREMOLO (Fender bias tremolo — oscillates output tube bias) ===
function trem_init() ( this.phase = 0; );
function trem_proc(x, depth, speed) local(rate, lfo) (
  rate = 1.0 + speed * 9.0;
  this.phase += rate / srate;
  this.phase >= 1.0 ? this.phase -= 1.0;
  lfo = sin(this.phase * 2.0 * $pi);
  x * (1.0 - depth * 0.8 * (0.5 + lfo * 0.5));
);

// === TAPE ECHO ===
function tape_echo_init() (
  this.buf_base = 200000;
  this.buf_len = (srate * 1.0)|0;
  this.buf_len = min(this.buf_len, 48000);
  this.write_pos = 0;
  this.fb_lp.bq_init();
  this.fb_lp.bq_set_lp(3000, 0.5);
  this.fb_val = 0;
  this.wow_phase = 0;
  memset(this.buf_base, 0, 50000);
);
function tape_echo_proc(x, mix, time, feedback) local(delay_samps, read_pos, wow, delayed, wet, frac, idx, s0, s1) (
  delay_samps = (0.050 + time * 0.550) * srate;
  delay_samps = min(delay_samps, this.buf_len - 2);
  this.wow_phase += 0.7 / srate;
  this.wow_phase >= 1.0 ? this.wow_phase -= 1.0;
  wow = sin(this.wow_phase * 2.0 * $pi) * 0.002 * srate;
  read_pos = this.write_pos - delay_samps + wow;
  read_pos < 0 ? read_pos += this.buf_len;
  idx = floor(read_pos);
  frac = read_pos - idx;
  idx < 0 ? idx += this.buf_len;
  s0 = (this.buf_base)[idx % this.buf_len];
  s1 = (this.buf_base)[(idx + 1) % this.buf_len];
  delayed = s0 + frac * (s1 - s0);
  this.fb_val = this.fb_lp.bq_proc(delayed);
  (this.buf_base)[this.write_pos] = x + this.fb_val * feedback * 0.85;
  this.write_pos += 1;
  this.write_pos >= this.buf_len ? this.write_pos = 0;
  x + delayed * mix;
);

// === INSTANCES ===
inp.input_stage_init();
input_hp.bq_init();
input_hp.bq_set_hp(30, 0.7);  // 5F6-A input coupling: deeper bass (designed for bass guitar)

// RF filter — grid stopper (tweed input circuit)
rf_filter.bq_init();
rf_filter.bq_set_lp(9000, 0.5);  // slightly warmer than blackface

// Bright cap on Bright channel — gain-dependent treble boost
// 5F6-A: 120pF across gain pot. Only active on Bright channel.
bright_cap.bq_init();
bright_cap.bq_set_hishelf(3000, 0.0, 0.7);

// V1a: 12AY7 input gain stage — LOWER gain than 12AX7 (mu=44 vs mu=100)
// 5F6-A V1a: warmer, less gain = more headroom in preamp.
// Miller LP at 7000Hz (warmer than blackface — tweed preamp character)
v1a.triode_init(30, 7000);

// Cathode follower (V1b) — unity-gain buffer before tone stack
cf.cathode_follower_init();

// Phase inverter (12AX7 LTP) — Bassman uses 12AX7 (unlike Twin's 12AT7)
// More gain at PI than Twin = power amp sees more signal = earlier breakup.
// This is part of why the Bassman breaks up earlier than the Twin.
pi.triode_init(15, 8000);  // slightly warmer bandwidth than Twin

// Tone stack
ts.fender_tonestack_init();
ts.fender_tonestack_set(0.5, 0.5, 0.5);

// PSU
psu.psu_init();

// Bassman power amp (single — both channels share the same power section)
bassman_pa.bassman_poweramp_init();
bassman_pa.bassman_poweramp_set(0.5, 0.5);

// Soft gate
gate.sgate_init();

// Spring reverb
spring.spring_init();

// Tremolo
trem.trem_init();

// Tape echo
echo.tape_echo_init();

// Cabinet simulation (shared presets from core)
lms_cab_table_init();
cab.lms_cab_init();
cab.lms_cab_set(9);  // default: 1x15 Open (Bassman)
cab_type = 9;
cab_on = 1;
cab2.lms_cab_init();
cab2.lms_cab_set(0);
cab2_type = 0;
cab_dual = 0;
cab_b_solo = 0;

// Impedance interaction — Bassman rear panel tap (4/8/16 ohm)
amp_designed_ohms = 8;  // default: 8 ohm tap
ohm_ratio = 1.0;
ohm_sag_mult = 1.0;
ohm_vol = 1.0;
ohm_lo_gain = 0;
ohm_lo.lms_bq_init();
cab_load_ohms = 8;

gain = 0.5; in_level = 1; out_level = 1; master = 0.5;
amp_channel = 0; input_intensity = 0.5; sag_depth = 0.5;
spring_mix = 0;
trem_depth = 0; trem_speed = 0.5;
echo_mix = 0; echo_feedback = 0.4;
fx_bypass = 0;

// Density matrix animation state (128 cells for 16x8 grid)
DM_CELLS = 90000;
memset(DM_CELLS, 0, 128);
dm_frame = 0;
d_env_lo = 0; d_env_mid = 0; d_env_hi = 0; d_env_air = 0;
d_density = 1.0; d_mid_d = 0; d_hi_d = 0; d_air_d = 0;
d_miller_freq = 7000; d_miller_q = 0.6; d_grid_cond = 0;
d_drive_boost = 1.0; d_bplus = 1.0;

  // ============================================================
  // BROADCAST SYSTEM — Instance Registry
  // ============================================================
  BC_BASE = 100000;
  BC_MY_TYPE = 24;
  BC_SLOT_SIZE = 512;
  BC_MAX_INST = 32;
  BC_PARAM_COUNT = 24;
  BC_MY_REGION = BC_BASE + BC_MY_TYPE * 16384;
  BC_STALE_TIMEOUT = 2;

  bc_my_id == 0 ? bc_my_id = floor(rand() * 1073741824) + 1;
  bc_my_slot = -1;
  bc_follow_slot = -1;
  bc_steal_pending = 0;
  bc_steal_target = 0;
  bc_panel_expanded = 0;
  bc_page = 0;
  bc_steal_mode = 0;
  bc_instance_count = 0;
  notice_show = 0;

  BC_STALE_HB = 870000;
  BC_STALE_CT = 870032;
  i = 0;
  loop(BC_MAX_INST,
    BC_STALE_HB[i] = -1;
    BC_STALE_CT[i] = 0;
    i += 1;
  );

  bc_i = 0;
  loop(BC_MAX_INST,
    bc_my_slot < 0 ? (
      sb = BC_MY_REGION + bc_i * BC_SLOT_SIZE;
      sid = gmem[sb + 1];
      (sid == 0 || sid == bc_my_id) ? (
        bc_my_slot = bc_i;
      );
    );
    bc_i += 1;
  );

  bc_my_slot >= 0 ? (
    sb = BC_MY_REGION + bc_my_slot * BC_SLOT_SIZE;
    gmem[sb + 0] = 0;
    gmem[sb + 1] = bc_my_id;
    gmem[sb + 2] = BC_MY_TYPE;
    gmem[sb + 3] = 0;
    gmem[sb + 4] = BC_PARAM_COUNT;
  );

@slider
in_level = 10 ^ (slider1 / 20);
gain = slider2 / 100;
amp_channel = slider3;
ts.fender_tonestack_set(slider4/100, slider5/100, slider6/100);
master = slider8 / 100;
bassman_pa.bassman_poweramp_set(master, slider7/100);
input_intensity = slider9 / 100;
sag_depth = slider10 / 100;
out_level = 10 ^ (slider11 / 20);
fx_bypass = slider12;
spring_mix = slider13 / 100;
trem_depth = slider15 / 100;
trem_speed = slider16 / 100;
echo_mix = slider17 / 100;
echo_feedback = slider18 / 100;
cab_type = slider19;
cab_on = slider20;
cab.lms_cab_set(cab_on ? cab_type : 0);
cab_mic = slider21;
cab.lms_cab_set_mic(cab_mic);
cab2_type = slider22;
cab2.lms_cab_set(cab_on ? cab2_type : 0);
cab2_mic = slider23;
cab2.lms_cab_set_mic(cab2_mic);
cab_dual = cab_on && cab_type > 0 && cab2_type > 0;
cab_b_solo = cab_on && cab_type == 0 && cab2_type > 0;

// Impedance interaction — rear panel tap + load mismatch
amp_designed_ohms = slider24 == 0 ? 4 : slider24 == 1 ? 8 : 16;
cab_a_ohms = lms_cab_get_ohms(cab_on ? cab_type : 0);
cab_b_ohms = lms_cab_get_ohms(cab_on ? cab2_type : 0);
cab_load_ohms = lms_cab_compute_load(cab_a_ohms, cab_b_ohms);
cab_load_ohms > 0 ? (
  ohm_ratio = cab_load_ohms / amp_designed_ohms;
  ohm_ratio = max(0.25, min(4.0, ohm_ratio));
  ohm_sag_mult = 1.0 / ohm_ratio;
  ohm_sag_mult = max(0.5, min(2.5, ohm_sag_mult));
  ohm_vol = 1.0 / sqrt(ohm_ratio);
  ohm_vol = max(0.5, min(1.6, ohm_vol));
  ohm_lo_gain = (1.0 - ohm_ratio) * 3.0;
  ohm_lo_gain = max(-4.0, min(4.0, ohm_lo_gain));
  abs(ohm_lo_gain) > 0.2 ? (
    ohm_lo.lms_bq_set_loshelf(120, ohm_lo_gain, 0.7);
  ) : (
    ohm_lo.lms_bq_init();
  );
) : (
  ohm_sag_mult = 1.0;
  ohm_vol = 1.0;
  ohm_lo.lms_bq_init();
);

// ============================================================
// @BLOCK — Broadcast, heartbeat, stale-check, follow, steal
// ============================================================
@block
// ---- Recalculate from sliders (GFX changes don't trigger @slider) ----
in_level = 10 ^ (slider1 / 20);
gain = slider2 / 100;
amp_channel = slider3;
ts.fender_tonestack_set(slider4/100, slider5/100, slider6/100);
master = slider8 / 100;
bassman_pa.bassman_poweramp_set(master, slider7/100);
input_intensity = slider9 / 100;
sag_depth = slider10 / 100;
out_level = 10 ^ (slider11 / 20);
fx_bypass = slider12;
spring_mix = slider13 / 100;
trem_depth = slider15 / 100;
trem_speed = slider16 / 100;
echo_mix = slider17 / 100;
echo_feedback = slider18 / 100;
cab_type = slider19;
cab_on = slider20;
cab.lms_cab_set(cab_on ? cab_type : 0);
cab_mic = slider21;
cab.lms_cab_set_mic(cab_mic);
cab2_type = slider22;
cab2.lms_cab_set(cab_on ? cab2_type : 0);
cab2_mic = slider23;
cab2.lms_cab_set_mic(cab2_mic);
cab_dual = cab_on && cab_type > 0 && cab2_type > 0;
cab_b_solo = cab_on && cab_type == 0 && cab2_type > 0;

// Impedance interaction — rear panel tap + load mismatch
amp_designed_ohms = slider24 == 0 ? 4 : slider24 == 1 ? 8 : 16;
cab_a_ohms = lms_cab_get_ohms(cab_on ? cab_type : 0);
cab_b_ohms = lms_cab_get_ohms(cab_on ? cab2_type : 0);
cab_load_ohms = lms_cab_compute_load(cab_a_ohms, cab_b_ohms);
cab_load_ohms > 0 ? (
  ohm_ratio = cab_load_ohms / amp_designed_ohms;
  ohm_ratio = max(0.25, min(4.0, ohm_ratio));
  ohm_sag_mult = 1.0 / ohm_ratio;
  ohm_sag_mult = max(0.5, min(2.5, ohm_sag_mult));
  ohm_vol = 1.0 / sqrt(ohm_ratio);
  ohm_vol = max(0.5, min(1.6, ohm_vol));
  ohm_lo_gain = (1.0 - ohm_ratio) * 3.0;
  ohm_lo_gain = max(-4.0, min(4.0, ohm_lo_gain));
  abs(ohm_lo_gain) > 0.2 ? (
    ohm_lo.lms_bq_set_loshelf(120, ohm_lo_gain, 0.7);
  ) : (
    ohm_lo.lms_bq_init();
  );
) : (
  ohm_sag_mult = 1.0;
  ohm_vol = 1.0;
  ohm_lo.lms_bq_init();
);

// ---- Tuner: run pitch detection + smooth display ----
tuner.lms_yin_detect();
tuner_smooth == 0 ? tuner_smooth = exp(-1 / (srate / samplesblock * 0.080));
tuner.freq > 20 && tuner.confidence > 0.3 ? (
  tuner_disp_freq = tuner_smooth * tuner_disp_freq + (1 - tuner_smooth) * tuner.freq;
  tuner_disp_conf = tuner_smooth * tuner_disp_conf + (1 - tuner_smooth) * tuner.confidence;
  tuner_disp_cents = tuner_smooth * tuner_disp_cents + (1 - tuner_smooth) * tuner.cents;
  tuner_disp_note = tuner.midi_int;
) : (
  tuner_disp_conf *= 0.9;
);

bc_my_slot >= 0 ? (
  sb = BC_MY_REGION + bc_my_slot * BC_SLOT_SIZE;
  gmem[sb + 1] != bc_my_id ? (
    bc_my_id = floor(rand() * 1073741824) + 1;
    bc_my_slot = -1;
    bc_i = 0;
    loop(BC_MAX_INST,
      bc_my_slot < 0 ? (
        tsb = BC_MY_REGION + bc_i * BC_SLOT_SIZE;
        (gmem[tsb + 1] == 0) ? bc_my_slot = bc_i;
      );
      bc_i += 1;
    );
    bc_my_slot >= 0 ? (
      sb = BC_MY_REGION + bc_my_slot * BC_SLOT_SIZE;
      gmem[sb + 0] = 0;
      gmem[sb + 1] = bc_my_id;
      gmem[sb + 2] = BC_MY_TYPE;
      gmem[sb + 3] = bc_following;
      gmem[sb + 4] = BC_PARAM_COUNT;
    );
  );
);

bc_my_slot >= 0 && bc_following > 0 ? (
  bc_found_leader = 0;
  bc_scan = 0;
  loop(BC_MAX_INST,
    bc_scan != bc_my_slot ? (
      lsb = BC_MY_REGION + bc_scan * BC_SLOT_SIZE;
      gmem[lsb + 1] == bc_following ? (
        bc_found_leader = 1;
        bc_follow_slot = bc_scan;
        lbase = lsb + 8;
        slider1 = gmem[lbase + 0];
        slider2 = gmem[lbase + 1];
        slider3 = gmem[lbase + 2];
        slider4 = gmem[lbase + 3];
        slider5 = gmem[lbase + 4];
        slider6 = gmem[lbase + 5];
        slider7 = gmem[lbase + 6];
        slider8 = gmem[lbase + 7];
        slider9 = gmem[lbase + 8];
        slider10 = gmem[lbase + 9];
        slider11 = gmem[lbase + 10];
        slider12 = gmem[lbase + 11];
        slider13 = gmem[lbase + 12];
        slider15 = gmem[lbase + 14];
        slider16 = gmem[lbase + 15];
        slider17 = gmem[lbase + 16];
        slider18 = gmem[lbase + 17];
        slider19 = gmem[lbase + 18];
        slider20 = gmem[lbase + 19];
        slider21 = gmem[lbase + 20];
        slider22 = gmem[lbase + 21];
        slider23 = gmem[lbase + 22];
        slider24 = gmem[lbase + 23];
        bc_scan = BC_MAX_INST;
      );
    );
    bc_scan += 1;
  );
  !bc_found_leader ? (
    bc_following = 0;
    bc_follow_slot = -1;
  );
);

bc_my_slot >= 0 && bc_steal_pending ? (
  bc_scan = 0;
  loop(BC_MAX_INST,
    lsb = BC_MY_REGION + bc_scan * BC_SLOT_SIZE;
    gmem[lsb + 1] == bc_steal_target ? (
      lbase = lsb + 8;
      slider1 = gmem[lbase + 0];
      slider2 = gmem[lbase + 1];
      slider3 = gmem[lbase + 2];
      slider4 = gmem[lbase + 3];
      slider5 = gmem[lbase + 4];
      slider6 = gmem[lbase + 5];
      slider7 = gmem[lbase + 6];
      slider8 = gmem[lbase + 7];
      slider9 = gmem[lbase + 8];
      slider10 = gmem[lbase + 9];
      slider11 = gmem[lbase + 10];
      slider12 = gmem[lbase + 11];
      slider13 = gmem[lbase + 12];
      slider15 = gmem[lbase + 14];
      slider16 = gmem[lbase + 15];
      slider17 = gmem[lbase + 16];
      slider18 = gmem[lbase + 17];
      slider19 = gmem[lbase + 18];
      slider20 = gmem[lbase + 19];
      slider21 = gmem[lbase + 20];
      slider22 = gmem[lbase + 21];
      slider23 = gmem[lbase + 22];
      slider24 = gmem[lbase + 23];
      bc_scan = BC_MAX_INST;
    );
    bc_scan += 1;
  );
  bc_steal_pending = 0;
  bc_steal_target = 0;
  bc_steal_mode = 0;
);

bc_my_slot >= 0 ? (
  sb = BC_MY_REGION + bc_my_slot * BC_SLOT_SIZE;
  gmem[sb + 0] += 1;
  gmem[sb + 3] = bc_following;
  pbase = sb + 8;
  gmem[pbase + 0] = slider1;
  gmem[pbase + 1] = slider2;
  gmem[pbase + 2] = slider3;
  gmem[pbase + 3] = slider4;
  gmem[pbase + 4] = slider5;
  gmem[pbase + 5] = slider6;
  gmem[pbase + 6] = slider7;
  gmem[pbase + 7] = slider8;
  gmem[pbase + 8] = slider9;
  gmem[pbase + 9] = slider10;
  gmem[pbase + 10] = slider11;
  gmem[pbase + 11] = slider12;
  gmem[pbase + 12] = slider13;
  gmem[pbase + 14] = slider15;
  gmem[pbase + 15] = slider16;
  gmem[pbase + 16] = slider17;
  gmem[pbase + 17] = slider18;
  gmem[pbase + 18] = slider19;
  gmem[pbase + 19] = slider20;
  gmem[pbase + 20] = slider21;
  gmem[pbase + 21] = slider22;
  gmem[pbase + 22] = slider23;
  gmem[pbase + 23] = slider24;
);

bc_instance_count = 0;
bc_scan = 0;
loop(BC_MAX_INST,
  tsb = BC_MY_REGION + bc_scan * BC_SLOT_SIZE;
  tsid = gmem[tsb + 1];
  tsid > 0 ? (
    bc_scan == bc_my_slot ? (
      bc_instance_count += 1;
    ) : (
      tshb = gmem[tsb + 0];
      tshb == BC_STALE_HB[bc_scan] ? (
        BC_STALE_CT[bc_scan] += samplesblock / srate;
        BC_STALE_CT[bc_scan] > BC_STALE_TIMEOUT ? (
          gmem[tsb + 1] = 0;
          BC_STALE_CT[bc_scan] = 0;
        );
      ) : (
        BC_STALE_HB[bc_scan] = tshb;
        BC_STALE_CT[bc_scan] = 0;
        bc_instance_count += 1;
      );
    );
  );
  bc_scan += 1;
);

@sample
mono = (spl0 + spl1) * 0.5 * in_level;
// Input clamp — catches record-arm spikes before the amp sees them
mono = max(-1.0, min(1.0, mono));

// Tuner — feed dry input for best pitch detection
tuner.lms_yin_write(mono);

// 0. RF filter (68k grid stopper — common Fender input circuit)
mono = rf_filter.bq_proc(mono);

// 1. Input stage (grid physics — 5F6-A tweed, 1M grid leak)
input_intensity > 0.0 ? (
  mono = inp.input_stage_proc(mono, input_intensity);
);

// 2. Input coupling cap
mono = input_hp.bq_proc(mono);

// 3. PSU sag (5U4 tube rectifier — always saggy, the Bassman bloom)
bplus = psu.psu_proc(abs(mono) * (1.0 + gain * 2.5), sag_depth * ohm_sag_mult);

// 4. Bright cap — channel-dependent (120pF, only on Bright channel)
// Normal channel: no bright cap (warm, full)
// Bright channel: gain-dependent treble boost
amp_channel == 1 ? (
  bright_db = (1.0 - gain) * (1.0 - gain) * 3.0;
) : (
  bright_db = 0;
);
bright_cap.bq_set_hishelf(3000, bright_db, 0.7);
mono = bright_cap.bq_proc(mono);

// 5. V1a (12AY7 — 5F6-A preamp, LOWER gain than 12AX7)
// 12AY7: mu=44 (vs 12AX7 mu=100). Less than half the gain.
// This is why the Bassman stays clean longer in the preamp.
// The overdrive comes from the POWER AMP, not the preamp.
v1a_drive = gain * 0.38;  // much less preamp gain (12AY7)
v1a_out = v1a.triode_proc(mono, v1a_drive, bplus,
  1.2, 1.0, 0.80, 0.95, 0.30, 0.10);

// 6. Cathode follower (V1b) — unity-gain buffer before tone stack
// Prevents tone stack loading, adds gentle programme-dependent compression
amp_out = cf.cathode_follower_proc(v1a_out, bplus);

// 7. Bassman tone stack (5F6-A — THE original Fender TMB)
amp_out = ts.fender_tonestack_proc(amp_out);
amp_out *= 6.0;  // restore level after tone stack insertion loss (~12dB)

// 8. Phase inverter (12AX7 LTP — MORE gain than Twin's 12AT7)
// Bassman uses 12AX7 in the PI (higher gain = drives power amp harder).
// This is part of why the Bassman breaks up earlier than the Twin.
// 12AX7: pos_hard=0.9, neg_hard=0.85 (more gain, later clip than 12AT7)
pi_drive = master * 0.40;  // more PI drive than Twin (12AX7 = higher gain)
amp_out = pi.triode_proc(amp_out, pi_drive, bplus,
  0.9, 0.85, 0.85, 0.90, 0.45, 0.10);

// 9. Effects loop (pre-power-amp — signal returns through power tubes + cab)
fx_bypass == 0 ? (
  // Tremolo (bias trem)
  trem_depth > 0 ? (
    amp_out = trem.trem_proc(amp_out, trem_depth, trem_speed);
  );
  // Spring reverb (Fender 3-spring tank)
  spring_mix > 0 ? (
    amp_out = spring.spring_proc(amp_out, spring_mix);
  );
  // Tape echo
  echo_mix > 0 ? (
    amp_out = echo.tape_echo_proc(amp_out, echo_mix, 0.5, echo_feedback);
  );
  // Safety clamp — catches runaway feedback before it hits power tubes
  amp_out = max(-0.95, min(0.95, amp_out));
);

// 10. POWER AMP (Bassman 6L6 push-pull, cathode-biased — both channels share this)
amp_out *= master;
amp_out = bassman_pa.bassman_poweramp_proc(amp_out, bplus);

// 11. Soft gate
amp_out = gate.sgate_proc(amp_out);

// Impedance interaction — power delivery + damping factor
amp_out *= ohm_vol;
amp_out = ohm_lo.lms_bq_proc(amp_out);

// 12. Cabinet (density-aware speaker sim)
cab_dual ? (
  cab_a_out = cab.lms_cab_proc(amp_out, v1a.hd.density);
  cab_b_out = cab2.lms_cab_proc(amp_out, v1a.hd.density);
  amp_out = (cab_a_out + cab_b_out) * 0.5;
) : cab_b_solo ? (
  amp_out = cab2.lms_cab_proc(amp_out, v1a.hd.density);
) : (
  amp_out = cab.lms_cab_proc(amp_out, v1a.hd.density);
);

amp_out *= out_level;
// Brickwall output limiter — transparent safety ceiling
amp_out = max(-0.95, min(0.95, amp_out));

spl0 = amp_out;
spl1 = amp_out;

// Density state for GFX — use v1a (primary preamp stage)
d_env_lo  = v1a.hd.env_lo;  d_env_mid = v1a.hd.env_mid;
d_env_hi  = v1a.hd.env_hi;  d_env_air = v1a.hd.env_air;
d_density = v1a.hd.density;
d_mid_d   = v1a.hd.mid_density;  d_hi_d = v1a.hd.hi_density;  d_air_d = v1a.hd.air_density;
d_miller_freq = v1a.last_miller_freq;  d_miller_q = v1a.last_miller_q;
d_drive_boost = 1.0 + v1a.hd.mid_density * 0.4;
d_grid_cond   = v1a.peak_env;
d_bplus = bplus;

@gfx 600 564

// ============================================================================
//  SCALING — compute scale factor from actual window size vs nominal
// ============================================================================
gfx_ext_retina > 0 ? gfx_ext_retina = 1;
S = gfx_w / 600;
S < 0.5 ? S = 0.5;

// Scaled font sizes
F_TITLE = max(10, floor(22 * S));
F_LABEL = max(8, floor(12 * S));
F_SMALL = max(7, floor(11 * S));
F_TINY  = max(7, floor(10 * S));
// ============================================================================
//  COLOR CONSTANTS
// ============================================================================
COL_BG_R = 0.05; COL_BG_G = 0.05; COL_BG_B = 0.07;
COL_PANEL_R = 0.08; COL_PANEL_G = 0.08; COL_PANEL_B = 0.11;
COL_PANEL_HI_R = 0.12; COL_PANEL_HI_G = 0.12; COL_PANEL_HI_B = 0.16;
COL_BORDER_R = 0.20; COL_BORDER_G = 0.20; COL_BORDER_B = 0.25;
COL_TITLE_R = 0.95; COL_TITLE_G = 0.78; COL_TITLE_B = 0.35;
COL_SEC_R = 0.55; COL_SEC_G = 0.50; COL_SEC_B = 0.40;
COL_TEXT_R = 0.78; COL_TEXT_G = 0.78; COL_TEXT_B = 0.82;
COL_DIM_R = 0.38; COL_DIM_G = 0.38; COL_DIM_B = 0.42;
COL_ACCENT_R = 0.95; COL_ACCENT_G = 0.45; COL_ACCENT_B = 0.15;
COL_GREEN_R = 0.25; COL_GREEN_G = 0.80; COL_GREEN_B = 0.50;
COL_CYAN_R = 0.20; COL_CYAN_G = 0.60; COL_CYAN_B = 0.85;
COL_BAR_BG_R = 0.12; COL_BAR_BG_G = 0.12; COL_BAR_BG_B = 0.16;

// ============================================================================
//  BACKGROUND
// ============================================================================
hdr_h = floor(44 * S);
gfx_r = COL_BG_R; gfx_g = COL_BG_G; gfx_b = COL_BG_B;
gfx_rect(0, 0, gfx_w, gfx_h);
gfx_r = 0.03; gfx_g = 0.03; gfx_b = 0.05;
gfx_rect(0, 0, gfx_w, hdr_h);
gfx_r = COL_TITLE_R * 0.6; gfx_g = COL_TITLE_G * 0.6; gfx_b = COL_TITLE_B * 0.6;
gfx_rect(0, hdr_h, gfx_w, max(1, floor(2 * S)));

// ============================================================================
//  HELPER: draw_bar
// ============================================================================
function draw_bar(bx, by, bw, bh, val, vmin, vmax, label, show_val) (
  gfx_r = COL_BAR_BG_R; gfx_g = COL_BAR_BG_G; gfx_b = COL_BAR_BG_B;
  gfx_rect(bx, by, bw, bh);
  norm = (val - vmin) / (vmax - vmin);
  norm = max(0, min(1, norm));
  fill_w = norm * bw;
  fill_w > 0 ? (
    gfx_r = COL_CYAN_R * 0.6; gfx_g = COL_CYAN_G * 0.6; gfx_b = COL_CYAN_B * 0.6;
    gfx_rect(bx, by, fill_w, bh);
    gfx_r = COL_CYAN_R * 0.8; gfx_g = COL_CYAN_G * 0.8; gfx_b = COL_CYAN_B * 0.8;
    gfx_rect(bx, by, fill_w, floor(bh / 2));
    gfx_r = COL_CYAN_R; gfx_g = COL_CYAN_G; gfx_b = COL_CYAN_B;
    gfx_rect(bx, by, fill_w, 1);
  );
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_rect(bx, by, bw, 1); gfx_rect(bx, by + bh - 1, bw, 1);
  gfx_rect(bx, by, 1, bh); gfx_rect(bx + bw - 1, by, 1, bh);
  gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
  gfx_setfont(1, "Arial", F_LABEL);
  gfx_x = bx + floor(5 * S); gfx_y = by + floor((bh - F_LABEL) / 2);
  gfx_drawstr(label);
  show_val ? (
    gfx_setfont(1, "Arial", F_SMALL);
    gfx_x = bx + bw - floor(40 * S); gfx_y = by + floor((bh - F_SMALL) / 2);
    gfx_drawnumber(val, val == floor(val) ? 0 : 1);
  );
  mouse_cap & 1 ? (
    mouse_x >= bx && mouse_x <= bx + bw &&
    mouse_y >= by && mouse_y <= by + bh ? (
      new_norm = (mouse_x - bx) / bw;
      new_norm = max(0, min(1, new_norm));
      val = vmin + new_norm * (vmax - vmin);
    );
  );
  val;
);

// ============================================================================
//  HELPER: draw_panel
// ============================================================================
function draw_panel(px, py, pw, ph, title) (
  gfx_r = COL_PANEL_R; gfx_g = COL_PANEL_G; gfx_b = COL_PANEL_B;
  gfx_rect(px, py, pw, ph);
  gfx_r = COL_PANEL_HI_R; gfx_g = COL_PANEL_HI_G; gfx_b = COL_PANEL_HI_B;
  gfx_rect(px, py, pw, floor(22 * S));
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_rect(px, py + floor(22 * S), pw, 1);
  gfx_r = COL_BORDER_R * 0.7; gfx_g = COL_BORDER_G * 0.7; gfx_b = COL_BORDER_B * 0.7;
  gfx_rect(px, py, pw, 1); gfx_rect(px, py, 1, ph);
  gfx_rect(px + pw - 1, py, 1, ph); gfx_rect(px, py + ph - 1, pw, 1);
  gfx_r = COL_SEC_R; gfx_g = COL_SEC_G; gfx_b = COL_SEC_B;
  gfx_setfont(1, "Arial", F_LABEL);
  gfx_x = px + floor(8 * S); gfx_y = py + floor(4 * S);
  gfx_drawstr(title);
);

// ============================================================================
//  HELPER: draw_toggle
// ============================================================================
function draw_toggle(tx, ty, is_on, label) (
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_circle(tx + floor(8 * S), ty + floor(8 * S), floor(7 * S), 0);
  is_on ? (
    gfx_r = COL_GREEN_R; gfx_g = COL_GREEN_G; gfx_b = COL_GREEN_B;
    gfx_circle(tx + floor(8 * S), ty + floor(8 * S), floor(5 * S), 1);
  ) : (
    gfx_r = 0.15; gfx_g = 0.15; gfx_b = 0.18;
    gfx_circle(tx + floor(8 * S), ty + floor(8 * S), floor(5 * S), 1);
  );
  gfx_r = is_on ? COL_TEXT_R : COL_DIM_R;
  gfx_g = is_on ? COL_TEXT_G : COL_DIM_G;
  gfx_b = is_on ? COL_TEXT_B : COL_DIM_B;
  gfx_setfont(1, "Arial", F_SMALL);
  gfx_x = tx + floor(20 * S); gfx_y = ty + floor(1 * S);
  gfx_drawstr(label);
  (mouse_cap & 1) && !(last_cap & 1) &&
    mouse_x >= tx && mouse_x <= tx + floor(80 * S) &&
    mouse_y >= ty && mouse_y <= ty + floor(16 * S) ? (
      is_on = 1 - is_on;
  );
  is_on;
);

// ============================================================================
//  HELPER: draw_mode_sel — clickable mode selector
// ============================================================================
function draw_mode_sel(mx, my, mw, mh, val, vmax, label, v0, v1, v2, v3, v4) (
  gfx_r = COL_BAR_BG_R; gfx_g = COL_BAR_BG_G; gfx_b = COL_BAR_BG_B;
  gfx_rect(mx, my, mw, mh);
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_rect(mx, my, mw, 1); gfx_rect(mx, my + mh - 1, mw, 1);
  gfx_rect(mx, my, 1, mh); gfx_rect(mx + mw - 1, my, 1, mh);
  gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
  gfx_setfont(1, "Arial", F_LABEL);
  gfx_x = mx + 5; gfx_y = my + floor((mh - 12) / 2);
  gfx_drawstr(label);
  gfx_r = COL_ACCENT_R; gfx_g = COL_ACCENT_G; gfx_b = COL_ACCENT_B;
  gfx_x = mx + mw - 82; gfx_y = my + floor((mh - 12) / 2);
  val == 0 ? gfx_drawstr(v0);
  val == 1 ? gfx_drawstr(v1);
  val == 2 ? gfx_drawstr(v2);
  val == 3 ? gfx_drawstr(v3);
  val == 4 ? gfx_drawstr(v4);
  (mouse_cap & 1) && !(last_cap & 1) &&
    mouse_x >= mx && mouse_x <= mx + mw &&
    mouse_y >= my && mouse_y <= my + mh ? (
      val = (val + 1) % (vmax + 1);
  );
  (mouse_cap & 2) && !(last_cap & 2) &&
    mouse_x >= mx && mouse_x <= mx + mw &&
    mouse_y >= my && mouse_y <= my + mh ? (
      val = val - 1; val < 0 ? val = vmax;
  );
  val;
);

// ============================================================================
//  LAYOUT
// ============================================================================
margin = floor(8 * S);
gap = floor(6 * S);
bar_h = floor(18 * S);
bar_sp = floor(21 * S);
col_w = 190;
pad = floor(4 * S);
pad2 = pad * 2;
gr_bar_h = max(2, floor(6 * S));
body_y = floor(50 * S) + floor(28 * S);  // offset for tuner strip

// ============================================================================
//  LOGO + TITLE
// ============================================================================
gfx_getimgdim(0, logo_img_w, logo_img_h);
logo_img_w > 0 ? (
  logo_h = floor(32 * S);
  logo_w = floor(logo_h * (logo_img_w / logo_img_h));
  logo_x = floor(6 * S);
  logo_y = floor(((hdr_h - logo_h)) / 2);
  gfx_blit(0, 1, 0, 0, 0, logo_img_w, logo_img_h, logo_x, logo_y, logo_w, logo_h);
) : (
  logo_w = 0;
  logo_x = 0;
);
gfx_r = COL_TITLE_R; gfx_g = COL_TITLE_G; gfx_b = COL_TITLE_B;
gfx_setfont(1, "Arial", F_TITLE);
gfx_x = logo_x + logo_w + floor(8 * S); gfx_y = floor(10 * S);
gfx_drawstr("THE BASSWOMAN v2");
gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
gfx_setfont(1, "Arial", F_LABEL);
gfx_measurestr("Density-Aware Bassman", sub_w, sub_h);
gfx_x = gfx_w - sub_w - floor(10 * S); gfx_y = floor(10 * S);
gfx_drawstr("Density-Aware Bassman");

// ============================================================================
//  TUNER STRIP
// ============================================================================
tuner_h = floor(28 * S);
lms_draw_tuner(0, hdr_h, gfx_w, tuner_h, tuner_disp_freq, tuner_disp_conf, tuner_disp_note, tuner_disp_cents, S);

// ============================================================================
//  COL 1: PREAMP
// ============================================================================
c1x = margin;
draw_panel(c1x, body_y, col_w, 26 + 5 * bar_sp, "PREAMP");
cy = body_y + floor(26 * S);
_old = slider1; slider1 = draw_bar(c1x + pad, cy, col_w - pad2, bar_h, slider1, -24, 24, "Input dB", 1);
slider1 != _old ? slider_automate(2^0);
cy += bar_sp;
_old = slider2; slider2 = draw_bar(c1x + pad, cy, col_w - pad2, bar_h, slider2, 0, 100, "Gain", 1);
slider2 != _old ? slider_automate(2^1);
cy += bar_sp;
_old = slider3; slider3 = draw_mode_sel(c1x + pad, cy, col_w - pad2, bar_h, slider3, 1, "Channel", "Normal", "Bright", "", "", "");
slider3 != _old ? slider_automate(2^2);
cy += bar_sp;
_old = slider9; slider9 = draw_bar(c1x + pad, cy, col_w - pad2, bar_h, slider9, 0, 100, "Input Stg", 1);
slider9 != _old ? slider_automate(2^8);
cy += bar_sp;
_old = slider10; slider10 = draw_bar(c1x + pad, cy, col_w - pad2, bar_h, slider10, 0, 100, "PSU Sag", 1);
slider10 != _old ? slider_automate(2^9);

// ============================================================================
//  COL 2: TONE / POWER
// ============================================================================
c2x = margin + col_w + gap;
draw_panel(c2x, body_y, col_w, 26 + 6 * bar_sp, "TONE / POWER");
cy = body_y + floor(26 * S);
_old = slider4; slider4 = draw_bar(c2x + pad, cy, col_w - pad2, bar_h, slider4, 0, 100, "Bass", 1);
slider4 != _old ? slider_automate(2^3);
cy += bar_sp;
_old = slider5; slider5 = draw_bar(c2x + pad, cy, col_w - pad2, bar_h, slider5, 0, 100, "Mid", 1);
slider5 != _old ? slider_automate(2^4);
cy += bar_sp;
_old = slider6; slider6 = draw_bar(c2x + pad, cy, col_w - pad2, bar_h, slider6, 0, 100, "Treble", 1);
slider6 != _old ? slider_automate(2^5);
cy += bar_sp;
_old = slider7; slider7 = draw_bar(c2x + pad, cy, col_w - pad2, bar_h, slider7, 0, 100, "Presence", 1);
slider7 != _old ? slider_automate(2^6);
cy += bar_sp;
_old = slider8; slider8 = draw_bar(c2x + pad, cy, col_w - pad2, bar_h, slider8, 0, 100, "Master", 1);
slider8 != _old ? slider_automate(2^7);
cy += bar_sp;
_old = slider11; slider11 = draw_bar(c2x + pad, cy, col_w - pad2, bar_h, slider11, -24, 24, "Output dB", 1);
slider11 != _old ? slider_automate(2^10);

// ============================================================================
//  COL 3: EFFECTS
// ============================================================================
c3x = margin + (col_w + gap) * 2;
draw_panel(c3x, body_y, col_w, 26 + 7 * bar_sp, "EFFECTS");
cy = body_y + floor(26 * S);
_old = slider12; slider12 = draw_toggle(c3x + pad, cy + 2, slider12, "FX Bypass");
slider12 != _old ? slider_automate(2^11);
cy += bar_sp;
_old = slider13; slider13 = draw_bar(c3x + pad, cy, col_w - pad2, bar_h, slider13, 0, 100, "Reverb", 1);
slider13 != _old ? slider_automate(2^12);
cy += bar_sp;
_old = slider15; slider15 = draw_bar(c3x + pad, cy, col_w - pad2, bar_h, slider15, 0, 100, "Trem Depth", 1);
slider15 != _old ? slider_automate(2^14);
cy += bar_sp;
_old = slider16; slider16 = draw_bar(c3x + pad, cy, col_w - pad2, bar_h, slider16, 0, 100, "Trem Speed", 1);
slider16 != _old ? slider_automate(2^15);
cy += bar_sp;
_old = slider17; slider17 = draw_bar(c3x + pad, cy, col_w - pad2, bar_h, slider17, 0, 100, "Echo Mix", 1);
slider17 != _old ? slider_automate(2^16);
cy += bar_sp;
_old = slider18; slider18 = draw_bar(c3x + pad, cy, col_w - pad2, bar_h, slider18, 0, 100, "Echo FB", 1);
slider18 != _old ? slider_automate(2^17);

// ============================================================================
//  CABINET PANEL (full width, between controls and density)
// ============================================================================
  p3h = 26 + 7 * bar_sp;  // EFFECTS is tallest
  cab_panel_y = body_y + p3h + gap;
  cab_panel_w = col_w * 3 + gap * 2;
  cab_panel_x = margin;
  cab_panel_h = floor(160 * S);
  draw_panel(cab_panel_x, cab_panel_y, cab_panel_w, cab_panel_h, "CABINET");
  cab_cy = cab_panel_y + floor(26 * S);
  cab_cw = floor(cab_panel_w * 0.60);
  _old = slider19; slider19 = lms_draw_cab_sel(cab_panel_x + 4, cab_cy, cab_cw - 8, bar_h, slider19);
  slider19 != _old ? slider_automate(2^18);
  _old = slider20; slider20 = draw_toggle(cab_panel_x + cab_cw + floor(8 * S), cab_cy, slider20, "Cab Sim");
  slider20 != _old ? slider_automate(2^19);
  _old = slider21; slider21 = draw_bar(cab_panel_x + 4, cab_cy + bar_sp, cab_panel_w - 8, bar_h, slider21, 0, 100, "Mic A Distance", 1);
  slider21 != _old ? slider_automate(2^20);
  _old = slider22; slider22 = lms_draw_cab_sel_b(cab_panel_x + 4, cab_cy + bar_sp * 2, cab_cw - 8, bar_h, slider22);
  slider22 != _old ? slider_automate(2^21);
  _old = slider23; slider23 = draw_bar(cab_panel_x + 4, cab_cy + bar_sp * 3, cab_panel_w - 8, bar_h, slider23, 0, 100, "Mic B Distance", 1);
  slider23 != _old ? slider_automate(2^22);

  // Impedance tap selector (clickable) + readout
  gfx_setfont(1, "Arial", F_TINY);
  ohm_tap_y = cab_cy + bar_sp * 4 + floor(2 * S);
  ohm_tap_x = cab_panel_x + 4;
  ohm_tap_w = floor(70 * S);
  ohm_tap_h = floor(16 * S);
  gfx_r = 0.10; gfx_g = 0.10; gfx_b = 0.14;
  gfx_rect(ohm_tap_x, ohm_tap_y, ohm_tap_w, ohm_tap_h);
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_rect(ohm_tap_x, ohm_tap_y, ohm_tap_w, 1);
  gfx_rect(ohm_tap_x, ohm_tap_y + ohm_tap_h - 1, ohm_tap_w, 1);
  gfx_rect(ohm_tap_x, ohm_tap_y, 1, ohm_tap_h);
  gfx_rect(ohm_tap_x + ohm_tap_w - 1, ohm_tap_y, 1, ohm_tap_h);
  gfx_r = COL_ACCENT_R; gfx_g = COL_ACCENT_G; gfx_b = COL_ACCENT_B;
  gfx_x = ohm_tap_x + floor(4 * S); gfx_y = ohm_tap_y + floor((ohm_tap_h - F_TINY) / 2);
  gfx_drawstr(sprintf(#, "Tap: %dR", amp_designed_ohms));
  (mouse_cap & 1) && !(last_cap & 1) &&
    mouse_x >= ohm_tap_x && mouse_x <= ohm_tap_x + ohm_tap_w &&
    mouse_y >= ohm_tap_y && mouse_y <= ohm_tap_y + ohm_tap_h ? (
      _old = slider24;
      slider24 = (slider24 + 1) % 3;
      slider24 != _old ? slider_automate(2^23);
  );
  cab_load_ohms > 0 ? (
    gfx_x = ohm_tap_x + ohm_tap_w + floor(8 * S); gfx_y = ohm_tap_y + floor((ohm_tap_h - F_TINY) / 2);
    ohm_ratio > 0.9 && ohm_ratio < 1.1 ? (
      gfx_r = 0.25; gfx_g = 0.80; gfx_b = 0.50;
    ) : ohm_ratio > 0.6 && ohm_ratio < 1.5 ? (
      gfx_r = 0.95; gfx_g = 0.78; gfx_b = 0.35;
    ) : (
      gfx_r = 0.95; gfx_g = 0.45; gfx_b = 0.15;
    );
    cab_load_ohms == floor(cab_load_ohms) ? (
      gfx_drawstr(sprintf(#, "Load: %dR", cab_load_ohms));
    ) : (
      gfx_drawstr(sprintf(#, "Load: %.1fR", cab_load_ohms));
    );
    ohm_ratio > 0.9 && ohm_ratio < 1.1 ? (
      gfx_r = 0.25; gfx_g = 0.80; gfx_b = 0.50;
      gfx_drawstr(" matched");
    );
  );

// ============================================================================
//  DENSITY AWARENESS PANEL
// ============================================================================
  dm_panel_y = cab_panel_y + cab_panel_h + gap;
  dm_panel_w = col_w * 3 + gap * 2;
  dm_panel_x = margin;
  dm_cell = max(3, floor(7 * S));
  dm_gap  = max(1, floor(1.5 * S));
  dm_cols = 16; dm_rows = 8;
  dm_grid_w = dm_cols * (dm_cell + dm_gap) - dm_gap;
  dm_grid_h = dm_rows * (dm_cell + dm_gap) - dm_gap;
  dm_meter_h = max(8, floor(12 * S));
  dm_meter_gap = max(2, floor(3 * S));
  dm_hdr = floor(22 * S);
  dm_pad = floor(4 * S);
  dm_panel_h = dm_hdr + dm_pad + dm_grid_h + dm_meter_gap + dm_meter_h + dm_pad;
  draw_panel(dm_panel_x, dm_panel_y, dm_panel_w, dm_panel_h, "DENSITY AWARENESS");
  DM_LO_R = 0.12; DM_LO_G = 0.31; DM_LO_B = 0.86;
  DM_MI_R = 0.86; DM_MI_G = 0.63; DM_MI_B = 0.12;
  DM_HI_R = 0.86; DM_HI_G = 0.24; DM_HI_B = 0.12;
  DM_AI_R = 0.71; DM_AI_G = 0.16; DM_AI_B = 0.86;
  dm_band0 = min(1.0, d_env_lo * 8.0);
  dm_band1 = min(1.0, d_env_mid * 10.0);
  dm_band2 = min(1.0, d_env_hi * 12.0);
  dm_band3 = min(1.0, d_env_air * 16.0);
  dm_frame += 1; dm_t = dm_frame * 0.025;
  dm_gx = dm_panel_x + dm_pad;
  dm_gy = dm_panel_y + dm_hdr + dm_pad;
  dm_r = 0;
  loop(dm_rows,
    dm_c = 0;
    dm_band_idx = floor(dm_r / 2);
    dm_band_idx == 0 ? ( dm_bval = dm_band0; dm_br = DM_LO_R; dm_bg = DM_LO_G; dm_bb = DM_LO_B; );
    dm_band_idx == 1 ? ( dm_bval = dm_band1; dm_br = DM_MI_R; dm_bg = DM_MI_G; dm_bb = DM_MI_B; );
    dm_band_idx == 2 ? ( dm_bval = dm_band2; dm_br = DM_HI_R; dm_bg = DM_HI_G; dm_bb = DM_HI_B; );
    dm_band_idx == 3 ? ( dm_bval = dm_band3; dm_br = DM_AI_R; dm_bg = DM_AI_G; dm_bb = DM_AI_B; );
    loop(dm_cols,
      dm_ci = dm_r * dm_cols + dm_c;
      dm_phase = sin(dm_t * ((dm_ci * 0.37 + dm_r * 1.1) * 0.1) + dm_c * 0.5 + dm_r * 0.8);
      dm_target = max(0, min(1, dm_phase * dm_bval * 1.3));
      dm_cur = DM_CELLS[dm_ci];
      dm_cur += (dm_target - dm_cur) * 0.15;
      DM_CELLS[dm_ci] = dm_cur;
      dm_alpha = max(0.03, dm_cur * 0.9);
      dm_cx = dm_gx + dm_c * (dm_cell + dm_gap);
      dm_cy = dm_gy + dm_r * (dm_cell + dm_gap);
      gfx_r = dm_br * dm_alpha; gfx_g = dm_bg * dm_alpha; gfx_b = dm_bb * dm_alpha;
      gfx_rect(dm_cx, dm_cy, dm_cell, dm_cell);
      dm_c += 1;
    );
    dm_r += 1;
  );
  dm_lbl_x = dm_gx + dm_grid_w + floor(6 * S);
  gfx_setfont(1, "Arial", F_TINY);
  dm_li = 0;
  loop(4,
    dm_lbl_cy = dm_gy + dm_li * 2 * (dm_cell + dm_gap) + floor((dm_cell * 2 + dm_gap - F_TINY) / 2);
    dm_li == 0 ? ( gfx_r = DM_LO_R; gfx_g = DM_LO_G; gfx_b = DM_LO_B; );
    dm_li == 1 ? ( gfx_r = DM_MI_R; gfx_g = DM_MI_G; gfx_b = DM_MI_B; );
    dm_li == 2 ? ( gfx_r = DM_HI_R; gfx_g = DM_HI_G; gfx_b = DM_HI_B; );
    dm_li == 3 ? ( gfx_r = DM_AI_R; gfx_g = DM_AI_G; gfx_b = DM_AI_B; );
    gfx_x = dm_lbl_x; gfx_y = dm_lbl_cy;
    dm_li == 0 ? gfx_drawstr("LO");
    dm_li == 1 ? gfx_drawstr("MID");
    dm_li == 2 ? gfx_drawstr("HI");
    dm_li == 3 ? gfx_drawstr("AIR");
    dm_li += 1;
  );
  dm_info_x = dm_lbl_x + floor(30 * S);
  gfx_setfont(1, "Arial", F_TINY);
  gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
  gfx_x = dm_info_x; gfx_y = dm_gy + floor(2 * S);
  gfx_drawstr("DENSITY");
  gfx_r = COL_ACCENT_R; gfx_g = COL_ACCENT_G; gfx_b = COL_ACCENT_B;
  gfx_setfont(1, "Arial", F_LABEL);
  gfx_x = dm_info_x; gfx_y = dm_gy + floor(14 * S);
  gfx_drawnumber(d_density, 2);
  gfx_drawstr("x");
  dm_my = dm_gy + dm_grid_h + dm_meter_gap;
  dm_meter_count = 5;
  dm_mw = floor((dm_panel_w - dm_pad * 2 - (dm_meter_count - 1) * dm_meter_gap) / dm_meter_count);
  dm_mx = dm_panel_x + dm_pad;
  gfx_r = COL_BAR_BG_R; gfx_g = COL_BAR_BG_G; gfx_b = COL_BAR_BG_B;
  gfx_rect(dm_mx, dm_my, dm_mw, dm_meter_h);
  dm_mfill = max(0, min(1, (d_miller_freq - 5000) / 3500));
  dm_mfill_w = dm_mfill * dm_mw;
  dm_mfill_w > 0 ? ( gfx_r = COL_CYAN_R * 0.6; gfx_g = COL_CYAN_G * 0.6; gfx_b = COL_CYAN_B * 0.6; gfx_rect(dm_mx, dm_my, dm_mfill_w, dm_meter_h); gfx_r = COL_CYAN_R; gfx_g = COL_CYAN_G; gfx_b = COL_CYAN_B; gfx_rect(dm_mx, dm_my, dm_mfill_w, 1); );
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_rect(dm_mx, dm_my, dm_mw, 1); gfx_rect(dm_mx, dm_my + dm_meter_h - 1, dm_mw, 1);
  gfx_rect(dm_mx, dm_my, 1, dm_meter_h); gfx_rect(dm_mx + dm_mw - 1, dm_my, 1, dm_meter_h);
  gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
  gfx_setfont(1, "Arial", max(7, floor(9 * S)));
  gfx_x = dm_mx + floor(2 * S); gfx_y = dm_my + floor((dm_meter_h - floor(9 * S)) / 2);
  gfx_drawstr("MLR LP");
  dm_mx += dm_mw + dm_meter_gap;
  gfx_r = COL_BAR_BG_R; gfx_g = COL_BAR_BG_G; gfx_b = COL_BAR_BG_B;
  gfx_rect(dm_mx, dm_my, dm_mw, dm_meter_h);
  dm_mfill = max(0, min(1, (d_miller_q - 0.6) / 0.35));
  dm_mfill_w = dm_mfill * dm_mw;
  dm_mfill_w > 0 ? ( gfx_r = COL_CYAN_R * 0.6; gfx_g = COL_CYAN_G * 0.6; gfx_b = COL_CYAN_B * 0.6; gfx_rect(dm_mx, dm_my, dm_mfill_w, dm_meter_h); gfx_r = COL_CYAN_R; gfx_g = COL_CYAN_G; gfx_b = COL_CYAN_B; gfx_rect(dm_mx, dm_my, dm_mfill_w, 1); );
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_rect(dm_mx, dm_my, dm_mw, 1); gfx_rect(dm_mx, dm_my + dm_meter_h - 1, dm_mw, 1);
  gfx_rect(dm_mx, dm_my, 1, dm_meter_h); gfx_rect(dm_mx + dm_mw - 1, dm_my, 1, dm_meter_h);
  gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
  gfx_setfont(1, "Arial", max(7, floor(9 * S)));
  gfx_x = dm_mx + floor(2 * S); gfx_y = dm_my + floor((dm_meter_h - floor(9 * S)) / 2);
  gfx_drawstr("MLR Q");
  dm_mx += dm_mw + dm_meter_gap;
  gfx_r = COL_BAR_BG_R; gfx_g = COL_BAR_BG_G; gfx_b = COL_BAR_BG_B;
  gfx_rect(dm_mx, dm_my, dm_mw, dm_meter_h);
  dm_mfill = max(0, min(1, d_grid_cond / 0.35));
  dm_mfill_w = dm_mfill * dm_mw;
  dm_mfill_w > 0 ? ( gfx_r = COL_CYAN_R * 0.6; gfx_g = COL_CYAN_G * 0.6; gfx_b = COL_CYAN_B * 0.6; gfx_rect(dm_mx, dm_my, dm_mfill_w, dm_meter_h); gfx_r = COL_CYAN_R; gfx_g = COL_CYAN_G; gfx_b = COL_CYAN_B; gfx_rect(dm_mx, dm_my, dm_mfill_w, 1); );
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_rect(dm_mx, dm_my, dm_mw, 1); gfx_rect(dm_mx, dm_my + dm_meter_h - 1, dm_mw, 1);
  gfx_rect(dm_mx, dm_my, 1, dm_meter_h); gfx_rect(dm_mx + dm_mw - 1, dm_my, 1, dm_meter_h);
  gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
  gfx_setfont(1, "Arial", max(7, floor(9 * S)));
  gfx_x = dm_mx + floor(2 * S); gfx_y = dm_my + floor((dm_meter_h - floor(9 * S)) / 2);
  gfx_drawstr("GRID");
  dm_mx += dm_mw + dm_meter_gap;
  gfx_r = COL_BAR_BG_R; gfx_g = COL_BAR_BG_G; gfx_b = COL_BAR_BG_B;
  gfx_rect(dm_mx, dm_my, dm_mw, dm_meter_h);
  dm_mfill = max(0, min(1, (d_drive_boost - 1.0) / 0.4));
  dm_mfill_w = dm_mfill * dm_mw;
  dm_mfill_w > 0 ? ( gfx_r = COL_CYAN_R * 0.6; gfx_g = COL_CYAN_G * 0.6; gfx_b = COL_CYAN_B * 0.6; gfx_rect(dm_mx, dm_my, dm_mfill_w, dm_meter_h); gfx_r = COL_CYAN_R; gfx_g = COL_CYAN_G; gfx_b = COL_CYAN_B; gfx_rect(dm_mx, dm_my, dm_mfill_w, 1); );
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_rect(dm_mx, dm_my, dm_mw, 1); gfx_rect(dm_mx, dm_my + dm_meter_h - 1, dm_mw, 1);
  gfx_rect(dm_mx, dm_my, 1, dm_meter_h); gfx_rect(dm_mx + dm_mw - 1, dm_my, 1, dm_meter_h);
  gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
  gfx_setfont(1, "Arial", max(7, floor(9 * S)));
  gfx_x = dm_mx + floor(2 * S); gfx_y = dm_my + floor((dm_meter_h - floor(9 * S)) / 2);
  gfx_drawstr("DRIVE");
  dm_mx += dm_mw + dm_meter_gap;
  gfx_r = COL_BAR_BG_R; gfx_g = COL_BAR_BG_G; gfx_b = COL_BAR_BG_B;
  gfx_rect(dm_mx, dm_my, dm_mw, dm_meter_h);
  dm_mfill = max(0, min(1, (d_bplus - 0.75) / 0.25));
  dm_mfill_w = dm_mfill * dm_mw;
  dm_mfill_w > 0 ? ( gfx_r = COL_CYAN_R * 0.6; gfx_g = COL_CYAN_G * 0.6; gfx_b = COL_CYAN_B * 0.6; gfx_rect(dm_mx, dm_my, dm_mfill_w, dm_meter_h); gfx_r = COL_CYAN_R; gfx_g = COL_CYAN_G; gfx_b = COL_CYAN_B; gfx_rect(dm_mx, dm_my, dm_mfill_w, 1); );
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_rect(dm_mx, dm_my, dm_mw, 1); gfx_rect(dm_mx, dm_my + dm_meter_h - 1, dm_mw, 1);
  gfx_rect(dm_mx, dm_my, 1, dm_meter_h); gfx_rect(dm_mx + dm_mw - 1, dm_my, 1, dm_meter_h);
  gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
  gfx_setfont(1, "Arial", max(7, floor(9 * S)));
  gfx_x = dm_mx + floor(2 * S); gfx_y = dm_my + floor((dm_meter_h - floor(9 * S)) / 2);
  gfx_drawstr("B+");

// ============================================================================
//  INSTANCE MANAGER PANEL
// ============================================================================
  bc_rows_per_page = 5;
  bc_row_h = floor(14 * S);
  bc_bar_h = floor(30 * S);
  bc_btn_h = floor(20 * S);
  bc_panel_h = bc_panel_expanded ? (bc_bar_h + bc_rows_per_page * bc_row_h + floor(18 * S)) : bc_bar_h;
  bc_panel_y = gfx_h - bc_panel_h;

  gfx_r = 0.04; gfx_g = 0.04; gfx_b = 0.06;
  gfx_rect(0, bc_panel_y, gfx_w, bc_panel_h);
  gfx_r = 0.15; gfx_g = 0.15; gfx_b = 0.20;
  gfx_rect(0, bc_panel_y, gfx_w, 1);

  gfx_setfont(1, "Arial", F_SMALL);
  gfx_r = 0.95; gfx_g = 0.45; gfx_b = 0.15;
  gfx_x = floor(8 * S); gfx_y = bc_panel_y + floor(8 * S);
  bc_my_slot >= 0 ? (
    gfx_drawstr("I");
    gfx_drawnumber(bc_my_slot + 1, 0);
    gfx_drawstr("/");
    gfx_drawnumber(bc_instance_count, 0);
  ) : (
    gfx_drawstr("--");
  );

  bc_following > 0 ? (
    gfx_r = 0.2; gfx_g = 0.8; gfx_b = 0.3;
    gfx_drawstr("  Following: I");
    bc_fs = 0;
    loop(BC_MAX_INST,
      fsb = BC_MY_REGION + bc_fs * BC_SLOT_SIZE;
      gmem[fsb + 1] == bc_following ? (
        gfx_drawnumber(bc_fs + 1, 0);
        bc_fs = BC_MAX_INST;
      );
      bc_fs += 1;
    );
  ) : (
    gfx_r = 0.3; gfx_g = 0.3; gfx_b = 0.4;
    gfx_drawstr("  Following: --");
  );

  exp_x = gfx_w - floor(200 * S);
  exp_y = bc_panel_y + floor(4 * S);
  exp_w = floor(65 * S);
  exp_h = floor(20 * S);
  gfx_r = 0.12; gfx_g = 0.12; gfx_b = 0.16;
  gfx_rect(exp_x, exp_y, exp_w, exp_h);
  gfx_r = 0.5; gfx_g = 0.5; gfx_b = 0.6;
  gfx_x = exp_x + floor(5 * S); gfx_y = exp_y + floor(4 * S);
  bc_panel_expanded ? gfx_drawstr("COLLAPSE") : gfx_drawstr("EXPAND");
  (mouse_cap & 1) && !(last_cap & 1) &&
    mouse_x >= exp_x && mouse_x < exp_x + exp_w &&
    mouse_y >= exp_y && mouse_y < exp_y + exp_h ? (
    bc_panel_expanded = !bc_panel_expanded;
    bc_steal_mode = 0;
  );

  stl_x = gfx_w - floor(125 * S);
  stl_y = bc_panel_y + floor(4 * S);
  stl_w = floor(50 * S);
  stl_h = floor(20 * S);
  bc_steal_mode ? (
    gfx_r = 0.6; gfx_g = 0.2; gfx_b = 0.1;
  ) : (
    gfx_r = 0.2; gfx_g = 0.1; gfx_b = 0.1;
  );
  gfx_rect(stl_x, stl_y, stl_w, stl_h);
  gfx_r = 0.9; gfx_g = 0.5; gfx_b = 0.2;
  gfx_x = stl_x + floor(6 * S); gfx_y = stl_y + floor(4 * S);
  gfx_drawstr("STEAL");
  (mouse_cap & 1) && !(last_cap & 1) &&
    mouse_x >= stl_x && mouse_x < stl_x + stl_w &&
    mouse_y >= stl_y && mouse_y < stl_y + stl_h ? (
    bc_steal_mode = !bc_steal_mode;
    !bc_panel_expanded ? bc_panel_expanded = 1;
  );

  bc_following > 0 ? (
    unf_x = gfx_w - floor(65 * S);
    unf_y = bc_panel_y + floor(4 * S);
    unf_w = floor(55 * S);
    unf_h = floor(20 * S);
    gfx_r = 0.1; gfx_g = 0.2; gfx_b = 0.1;
    gfx_rect(unf_x, unf_y, unf_w, unf_h);
    gfx_r = 0.5; gfx_g = 0.9; gfx_b = 0.5;
    gfx_x = unf_x + floor(4 * S); gfx_y = unf_y + floor(4 * S);
    gfx_drawstr("UNFLW");
    (mouse_cap & 1) && !(last_cap & 1) &&
      mouse_x >= unf_x && mouse_x < unf_x + unf_w &&
      mouse_y >= unf_y && mouse_y < unf_y + unf_h ? (
      bc_following = 0;
      bc_follow_slot = -1;
    );
  );

  bc_panel_expanded ? (
    row_y = bc_panel_y + bc_bar_h;
    row_h = bc_row_h;

    bc_my_page = bc_my_slot >= 0 ? floor(bc_my_slot / bc_rows_per_page) : 0;
    bc_page < 0 ? bc_page = 0;

    bc_active_slots = 0;
    bc_si = 0;
    loop(BC_MAX_INST,
      gmem[BC_MY_REGION + bc_si * BC_SLOT_SIZE + 1] > 0 ? bc_active_slots += 1;
      bc_si += 1;
    );
    bc_total_pages = max(1, ceil(bc_active_slots / bc_rows_per_page));
    bc_page >= bc_total_pages ? bc_page = bc_total_pages - 1;

    pg_btn_w = floor(18 * S); pg_btn_h = floor(14 * S);
    pg_prev_x = floor(8 * S); pg_prev_y = bc_panel_y + bc_bar_h + bc_rows_per_page * row_h + floor(2 * S);
    bc_total_pages > 1 ? (
      gfx_r = 0.25; gfx_g = 0.25; gfx_b = 0.32;
      gfx_rect(pg_prev_x, pg_prev_y, pg_btn_w, pg_btn_h);
      gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.8;
      gfx_x = pg_prev_x + floor(4 * S); gfx_y = pg_prev_y + floor(2 * S);
      gfx_drawstr("<");
      (mouse_cap & 1) && !(last_cap & 1) &&
        mouse_x >= pg_prev_x && mouse_x < pg_prev_x + pg_btn_w &&
        mouse_y >= pg_prev_y && mouse_y < pg_prev_y + pg_btn_h ? (
        bc_page > 0 ? bc_page -= 1;
      );

      gfx_r = 0.25; gfx_g = 0.25; gfx_b = 0.32;
      gfx_rect(pg_prev_x + pg_btn_w + 2, pg_prev_y, pg_btn_w, pg_btn_h);
      gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.8;
      gfx_x = pg_prev_x + pg_btn_w + floor(6 * S); gfx_y = pg_prev_y + floor(2 * S);
      gfx_drawstr(">");
      (mouse_cap & 1) && !(last_cap & 1) &&
        mouse_x >= pg_prev_x + pg_btn_w + 2 && mouse_x < pg_prev_x + pg_btn_w * 2 + 2 &&
        mouse_y >= pg_prev_y && mouse_y < pg_prev_y + pg_btn_h ? (
        bc_page < bc_total_pages - 1 ? bc_page += 1;
      );

      gfx_r = 0.4; gfx_g = 0.4; gfx_b = 0.5;
      gfx_x = pg_prev_x + pg_btn_w * 2 + floor(8 * S); gfx_y = pg_prev_y + floor(2 * S);
      gfx_drawnumber(bc_page + 1, 0);
      gfx_drawstr("/");
      gfx_drawnumber(bc_total_pages, 0);

      bc_page != bc_my_page ? (
        you_x = pg_prev_x + pg_btn_w * 2 + floor(40 * S);
        gfx_r = 0.15; gfx_g = 0.15; gfx_b = 0.20;
        gfx_rect(you_x, pg_prev_y, floor(30 * S), pg_btn_h);
        gfx_r = 0.95; gfx_g = 0.45; gfx_b = 0.15;
        gfx_x = you_x + floor(3 * S); gfx_y = pg_prev_y + floor(2 * S);
        gfx_drawstr("YOU");
        (mouse_cap & 1) && !(last_cap & 1) &&
          mouse_x >= you_x && mouse_x < you_x + floor(30 * S) &&
          mouse_y >= pg_prev_y && mouse_y < pg_prev_y + pg_btn_h ? (
          bc_page = bc_my_page;
        );
      );
    );

    bc_page_start = bc_page * bc_rows_per_page;
    bc_page_end = bc_page_start + bc_rows_per_page - 1;
    bc_visible = 0;
    bc_s = 0;
    loop(BC_MAX_INST,
      isb = BC_MY_REGION + bc_s * BC_SLOT_SIZE;
      isid = gmem[isb + 1];

      isid > 0 ? (
        bc_visible >= bc_page_start && bc_visible <= bc_page_end ? (
          draw_row_y = row_y + (bc_visible - bc_page_start) * row_h;

          mouse_y >= draw_row_y && mouse_y < draw_row_y + row_h &&
            mouse_x >= floor(8 * S) && mouse_x < gfx_w - floor(8 * S) &&
            bc_s != bc_my_slot ? (
            gfx_r = 0.10; gfx_g = 0.10; gfx_b = 0.14;
            gfx_rect(floor(4 * S), draw_row_y, gfx_w - floor(8 * S), row_h);
          );

          gfx_setfont(1, "Arial", F_TINY);
          bc_s == bc_my_slot ? (
            gfx_r = 0.95; gfx_g = 0.45; gfx_b = 0.15;
          ) : (
            gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.8;
          );
          gfx_x = floor(12 * S); gfx_y = draw_row_y + floor(1 * S);
          gfx_drawstr("I");
          gfx_drawnumber(bc_s + 1, 0);
          gfx_drawstr("  ");

          bc_s == bc_my_slot ? (
            gfx_drawstr("[YOU]");
          ) : (
            iwho = gmem[isb + 3];
            bc_has_follower = 0;
            bc_fsc = 0;
            loop(BC_MAX_INST,
              fsb2 = BC_MY_REGION + bc_fsc * BC_SLOT_SIZE;
              gmem[fsb2 + 1] > 0 && gmem[fsb2 + 3] == isid ? bc_has_follower = 1;
              bc_fsc += 1;
            );
            iwho > 0 ? (
              gfx_r = 0.4; gfx_g = 0.6; gfx_b = 0.9;
              gfx_drawstr("[FOLLOWER]");
            ) : bc_has_follower ? (
              gfx_r = 0.95; gfx_g = 0.78; gfx_b = 0.35;
              gfx_drawstr("[LEADER]");
            ) : (
              gfx_r = 0.38; gfx_g = 0.38; gfx_b = 0.45;
              gfx_drawstr("[UNASSIGNED]");
            );
            gfx_r = 0.35; gfx_g = 0.45; gfx_b = 0.35;
            bc_steal_mode ? (
              gfx_drawstr("  click: steal");
            ) : (
              gfx_drawstr("  click: follow");
            );
            (mouse_cap & 1) && !(last_cap & 1) &&
              mouse_y >= draw_row_y && mouse_y < draw_row_y + row_h &&
              mouse_x >= floor(8 * S) && mouse_x < gfx_w - floor(8 * S) ? (
              bc_steal_mode ? (
                bc_steal_target = isid;
                bc_steal_pending = 1;
                bc_steal_mode = 0;
              ) : (
                bc_can_follow = 1;
                bc_cursor = isid;
                bc_hops = 0;
                while(bc_cursor > 0 && bc_hops < BC_MAX_INST) (
                  bc_cursor == bc_my_id ? (
                    bc_can_follow = 0;
                    bc_cursor = 0;
                  ) : (
                    bc_next = 0;
                    bc_cs = 0;
                    loop(BC_MAX_INST,
                      csb = BC_MY_REGION + bc_cs * BC_SLOT_SIZE;
                      gmem[csb + 1] == bc_cursor ? (
                        bc_next = gmem[csb + 3];
                        bc_cs = BC_MAX_INST;
                      );
                      bc_cs += 1;
                    );
                    bc_cursor = bc_next;
                  );
                  bc_hops += 1;
                );
                bc_can_follow ? (
                  bc_following = isid;
                );
              );
            );
          );
        );
        bc_visible += 1;
      );
      bc_s += 1;
    );
  );

  last_cap = mouse_cap;

  // --- BUY + NOTICE BUTTONS ---
  notice_btn_x = gfx_w - floor(60 * S);
  notice_btn_y = bc_panel_y - floor(18 * S);
  buy_btn_x = notice_btn_x - floor(50 * S);
  buy_btn_y = notice_btn_y;
  gfx_r = 0.6; gfx_g = 0.5; gfx_b = 0.3;
  gfx_rect(buy_btn_x, buy_btn_y, floor(45 * S), floor(15 * S));
  gfx_r = 0; gfx_g = 0; gfx_b = 0;
  gfx_x = buy_btn_x + floor(4 * S); gfx_y = buy_btn_y + floor(2 * S);
  gfx_drawstr("BUY");
  (mouse_cap & 1) && mouse_x >= buy_btn_x && mouse_x <= buy_btn_x + floor(45 * S) && mouse_y >= buy_btn_y && mouse_y <= buy_btn_y + floor(15 * S) && !buy_clicked ? (
    buy_show = !buy_show; buy_show ? notice_show = 0;
    buy_clicked = 1;
  );
  !(mouse_cap & 1) ? buy_clicked = 0;
  gfx_r = 0.6; gfx_g = 0.5; gfx_b = 0.3;
  gfx_rect(notice_btn_x, notice_btn_y, floor(55 * S), floor(15 * S));
  gfx_r = 0; gfx_g = 0; gfx_b = 0;
  gfx_x = notice_btn_x + floor(4 * S); gfx_y = notice_btn_y + floor(2 * S);
  gfx_drawstr("NOTICE");
  (mouse_cap & 1) && mouse_x >= notice_btn_x && mouse_x <= notice_btn_x + floor(55 * S) && mouse_y >= notice_btn_y && mouse_y <= notice_btn_y + floor(15 * S) && !notice_clicked ? (
    notice_show = !notice_show; notice_show ? buy_show = 0;
    notice_clicked = 1;
  );
  !(mouse_cap & 1) ? notice_clicked = 0;
  buy_show ? (
    gfx_r = 0.05; gfx_g = 0.05; gfx_b = 0.05; gfx_a = 0.95;
    gfx_rect(0, 0, gfx_w, gfx_h); gfx_a = 1;
    gfx_r = 0.9; gfx_g = 0.8; gfx_b = 0.5;
    gfx_x = floor(15 * S); gfx_y = floor(10 * S);
    gfx_drawstr("SUPPORT LMS");
    gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.7;
    gfx_x = floor(15 * S); gfx_y = floor(35 * S);
    gfx_drawstr("These plugins are offered for free use by anyone not able to afford it.");
    gfx_x = floor(15 * S); gfx_y = floor(50 * S);
    gfx_drawstr("No need to prove anything to us. But if you can afford to buy this suite,");
    gfx_x = floor(15 * S); gfx_y = floor(65 * S);
    gfx_drawstr("we would sure appreciate it. 50 dollars gets you every update and every");
    gfx_x = floor(15 * S); gfx_y = floor(80 * S);
    gfx_drawstr("plugin added to this suite forever. Its in its baby stages and these will");
    gfx_x = floor(15 * S); gfx_y = floor(95 * S);
    gfx_drawstr("only get doper over time. We also offer 6 months installments. But if you");
    gfx_x = floor(15 * S); gfx_y = floor(110 * S);
    gfx_drawstr("dont have the money, dont sweat it, you can use as much and as long as");
    gfx_x = floor(15 * S); gfx_y = floor(125 * S);
    gfx_drawstr("you like. Hail Satan. - LMS");
    gfx_r = 0.5; gfx_g = 0.7; gfx_b = 1.0;
    gfx_x = floor(15 * S); gfx_y = floor(150 * S);
    gfx_drawstr("bryanleaf.gumroad.com/l/zzgmzx");
    gfx_r = 0.6; gfx_g = 0.5; gfx_b = 0.3;
    gfx_rect(buy_btn_x, buy_btn_y, floor(45 * S), floor(15 * S));
    gfx_rect(notice_btn_x, notice_btn_y, floor(55 * S), floor(15 * S));
    gfx_r = 0; gfx_g = 0; gfx_b = 0;
    gfx_x = buy_btn_x + floor(4 * S); gfx_y = buy_btn_y + floor(2 * S);
    gfx_drawstr("BUY");
    gfx_x = notice_btn_x + floor(4 * S); gfx_y = notice_btn_y + floor(2 * S);
    gfx_drawstr("NOTICE");
  );
  notice_show ? (
    gfx_r = 0.05; gfx_g = 0.05; gfx_b = 0.05; gfx_a = 0.95;
    gfx_rect(0, 0, gfx_w, gfx_h); gfx_a = 1;
    gfx_r = 0.9; gfx_g = 0.8; gfx_b = 0.5;
    gfx_x = floor(15 * S); gfx_y = floor(10 * S);
    gfx_drawstr("NOTICE: THEY ARE TRYING TO STEAL YOUR COMPUTER");
    gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.7;
    gfx_x = floor(15 * S); gfx_y = floor(30 * S);
    gfx_drawstr("The algorithms in our favorite software are decades old.");
    gfx_x = floor(15 * S); gfx_y = floor(45 * S);
    gfx_drawstr("A mathematical model is a truth about the world,");
    gfx_x = floor(15 * S); gfx_y = floor(60 * S);
    gfx_drawstr("not a copyrightable product. You do not have to stay");
    gfx_x = floor(15 * S); gfx_y = floor(75 * S);
    gfx_drawstr("a slave to subscription software. Install Linux.");
    gfx_x = floor(15 * S); gfx_y = floor(90 * S);
    gfx_drawstr("Build your own tools. Believe in yourself.");
    gfx_r = 0.5; gfx_g = 0.7; gfx_b = 1.0;
    gfx_x = floor(15 * S); gfx_y = floor(115 * S);
    gfx_drawstr("github.com/LMSBAND  |  instagram.com/LMSSKABAND");
    gfx_r = 0.6; gfx_g = 0.5; gfx_b = 0.3;
    gfx_rect(buy_btn_x, buy_btn_y, floor(45 * S), floor(15 * S));
    gfx_rect(notice_btn_x, notice_btn_y, floor(55 * S), floor(15 * S));
    gfx_r = 0; gfx_g = 0; gfx_b = 0;
    gfx_x = buy_btn_x + floor(4 * S); gfx_y = buy_btn_y + floor(2 * S);
    gfx_drawstr("BUY");
    gfx_x = notice_btn_x + floor(4 * S); gfx_y = notice_btn_y + floor(2 * S);
    gfx_drawstr("NOTICE");
  );

// ============================================================
// @SERIALIZE — Persist follow state
// ============================================================
@serialize
file_var(0, bc_following);
file_var(0, bc_my_id);
