desc:LMS DrumbangerDrone MIDI
//author: LMS
//version: 0.2.0
//license: GPL-3.0
//
// MIDI output satellite for LMS Drumbanger.
// Place BEFORE a synth in the FX chain.
// Reacts to pad triggers from Drumbanger via gmem[] and
// outputs MIDI notes, chords, and arpeggios.
//
// Features:
//   - Single Pad or All Pads mode
//   - 8 scale types for note mapping
//   - Chord types: diatonic triads/7ths, major, minor, dom7, power, octave
//   - Arpeggiator: up, down, up-down, random with tempo sync
//   - Arp gate control for staccato/legato
//
// Signal chain:  DroneMIDI → Synth → DroneFX
//
// Requires LMS Drumbanger running on another track.

options:gmem=DrumBanger

// ============================================================
// SLIDERS
// ============================================================

// -- Connection --
slider1:0<0,16,1{All Pads,Pad 1,Pad 2,Pad 3,Pad 4,Pad 5,Pad 6,Pad 7,Pad 8,Pad 9,Pad 10,Pad 11,Pad 12,Pad 13,Pad 14,Pad 15,Pad 16}>Watch
slider2:0<0,8,1{Follow,Pat 1,Pat 2,Pat 3,Pat 4,Pat 5,Pat 6,Pat 7,Pat 8}>Pattern

// -- MIDI --
slider4:0<0,15,1{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16}>MIDI Channel
slider5:100<0,127,1>Velocity

// -- Note / Scale --
slider6:48<24,96,1>Root Note
slider7:1<0,7,1{Chromatic,Major,Minor,Dorian,Mixolydian,Pent Maj,Pent Min,Blues}>Scale
slider8:0<-2,2,1>Octave Offset

// -- Chord --
slider10:0<0,7,1{Off,Diatonic,Diatonic 7,Major,Minor,Dom7,Power,Octave}>Chord

// -- Arp --
slider15:0<0,4,1{Off,Up,Down,Up-Down,Random}>Arp
slider16:2<0,5,1{1/4,1/8,1/16,1/32,1/8T,1/16T}>Arp Rate
slider17:80<10,100,1>Arp Gate (%)

@init

// ============================================================
// MEMORY LAYOUT
// ============================================================
// 0-63:      NOTES_ON — currently sounding MIDI notes
// 100-163:   ARP_POOL — notes in current arp cycle
// 200-263:   STEP_NOTES — notes for current step
// 300-363:   STEP_VELS — velocities for step notes
// 1000-1191: SCALES — 8 scales × 24 semitone offsets
// 2000-4047: LOCAL_PAT — cached pattern data (8 patterns × 256 slots)

NOTES_ON   = 0;
ARP_POOL   = 100;
STEP_NOTES = 200;
STEP_VELS  = 300;
SCALES     = 1000;
LOCAL_PAT  = 2000;

notes_on_count = 0;
arp_pool_count = 0;
step_notes_count = 0;

// ---- State ----
last_heartbeat = 0;
connected = 0;
connected_timeout = 0;
last_step = -1;
prev_playing = 0;
drone_pattern = 0;
sync_request = 0;
pattern_synced = 0;
sync_flash = 0;

// ---- Arp state ----
arp_current_note = -1;
arp_pos = 0;
arp_dir = 1;       // 1=up, -1=down (for up-down mode)
arp_counter = 0;    // sample counter
arp_gate_counter = 0;

// ============================================================
// BUILD SCALE TABLES (24 entries each, semitones from root)
// ============================================================

// Chromatic: 1,1,1,1,...
i = 0; loop(24, SCALES[0 * 24 + i] = i; i += 1; );

// Major: W W H W W W H
SCALES[1*24+ 0]= 0; SCALES[1*24+ 1]= 2; SCALES[1*24+ 2]= 4;
SCALES[1*24+ 3]= 5; SCALES[1*24+ 4]= 7; SCALES[1*24+ 5]= 9;
SCALES[1*24+ 6]=11; SCALES[1*24+ 7]=12; SCALES[1*24+ 8]=14;
SCALES[1*24+ 9]=16; SCALES[1*24+10]=17; SCALES[1*24+11]=19;
SCALES[1*24+12]=21; SCALES[1*24+13]=23; SCALES[1*24+14]=24;
SCALES[1*24+15]=26; SCALES[1*24+16]=28; SCALES[1*24+17]=29;
SCALES[1*24+18]=31; SCALES[1*24+19]=33; SCALES[1*24+20]=35;
SCALES[1*24+21]=36; SCALES[1*24+22]=38; SCALES[1*24+23]=40;

// Minor (natural): W H W W H W W
SCALES[2*24+ 0]= 0; SCALES[2*24+ 1]= 2; SCALES[2*24+ 2]= 3;
SCALES[2*24+ 3]= 5; SCALES[2*24+ 4]= 7; SCALES[2*24+ 5]= 8;
SCALES[2*24+ 6]=10; SCALES[2*24+ 7]=12; SCALES[2*24+ 8]=14;
SCALES[2*24+ 9]=15; SCALES[2*24+10]=17; SCALES[2*24+11]=19;
SCALES[2*24+12]=20; SCALES[2*24+13]=22; SCALES[2*24+14]=24;
SCALES[2*24+15]=26; SCALES[2*24+16]=27; SCALES[2*24+17]=29;
SCALES[2*24+18]=31; SCALES[2*24+19]=32; SCALES[2*24+20]=34;
SCALES[2*24+21]=36; SCALES[2*24+22]=38; SCALES[2*24+23]=39;

// Dorian: W H W W W H W
SCALES[3*24+ 0]= 0; SCALES[3*24+ 1]= 2; SCALES[3*24+ 2]= 3;
SCALES[3*24+ 3]= 5; SCALES[3*24+ 4]= 7; SCALES[3*24+ 5]= 9;
SCALES[3*24+ 6]=10; SCALES[3*24+ 7]=12; SCALES[3*24+ 8]=14;
SCALES[3*24+ 9]=15; SCALES[3*24+10]=17; SCALES[3*24+11]=19;
SCALES[3*24+12]=21; SCALES[3*24+13]=22; SCALES[3*24+14]=24;
SCALES[3*24+15]=26; SCALES[3*24+16]=27; SCALES[3*24+17]=29;
SCALES[3*24+18]=31; SCALES[3*24+19]=33; SCALES[3*24+20]=34;
SCALES[3*24+21]=36; SCALES[3*24+22]=38; SCALES[3*24+23]=39;

// Mixolydian: W W H W W H W
SCALES[4*24+ 0]= 0; SCALES[4*24+ 1]= 2; SCALES[4*24+ 2]= 4;
SCALES[4*24+ 3]= 5; SCALES[4*24+ 4]= 7; SCALES[4*24+ 5]= 9;
SCALES[4*24+ 6]=10; SCALES[4*24+ 7]=12; SCALES[4*24+ 8]=14;
SCALES[4*24+ 9]=16; SCALES[4*24+10]=17; SCALES[4*24+11]=19;
SCALES[4*24+12]=21; SCALES[4*24+13]=22; SCALES[4*24+14]=24;
SCALES[4*24+15]=26; SCALES[4*24+16]=28; SCALES[4*24+17]=29;
SCALES[4*24+18]=31; SCALES[4*24+19]=33; SCALES[4*24+20]=34;
SCALES[4*24+21]=36; SCALES[4*24+22]=38; SCALES[4*24+23]=40;

// Pentatonic Major: W W m3 W m3
SCALES[5*24+ 0]= 0; SCALES[5*24+ 1]= 2; SCALES[5*24+ 2]= 4;
SCALES[5*24+ 3]= 7; SCALES[5*24+ 4]= 9; SCALES[5*24+ 5]=12;
SCALES[5*24+ 6]=14; SCALES[5*24+ 7]=16; SCALES[5*24+ 8]=19;
SCALES[5*24+ 9]=21; SCALES[5*24+10]=24; SCALES[5*24+11]=26;
SCALES[5*24+12]=28; SCALES[5*24+13]=31; SCALES[5*24+14]=33;
SCALES[5*24+15]=36; SCALES[5*24+16]=38; SCALES[5*24+17]=40;
SCALES[5*24+18]=43; SCALES[5*24+19]=45; SCALES[5*24+20]=48;
SCALES[5*24+21]=50; SCALES[5*24+22]=52; SCALES[5*24+23]=55;

// Pentatonic Minor: m3 W W m3 W
SCALES[6*24+ 0]= 0; SCALES[6*24+ 1]= 3; SCALES[6*24+ 2]= 5;
SCALES[6*24+ 3]= 7; SCALES[6*24+ 4]=10; SCALES[6*24+ 5]=12;
SCALES[6*24+ 6]=15; SCALES[6*24+ 7]=17; SCALES[6*24+ 8]=19;
SCALES[6*24+ 9]=22; SCALES[6*24+10]=24; SCALES[6*24+11]=27;
SCALES[6*24+12]=29; SCALES[6*24+13]=31; SCALES[6*24+14]=34;
SCALES[6*24+15]=36; SCALES[6*24+16]=39; SCALES[6*24+17]=41;
SCALES[6*24+18]=43; SCALES[6*24+19]=46; SCALES[6*24+20]=48;
SCALES[6*24+21]=51; SCALES[6*24+22]=53; SCALES[6*24+23]=55;

// Blues: m3 W H H m3 W
SCALES[7*24+ 0]= 0; SCALES[7*24+ 1]= 3; SCALES[7*24+ 2]= 5;
SCALES[7*24+ 3]= 6; SCALES[7*24+ 4]= 7; SCALES[7*24+ 5]=10;
SCALES[7*24+ 6]=12; SCALES[7*24+ 7]=15; SCALES[7*24+ 8]=17;
SCALES[7*24+ 9]=18; SCALES[7*24+10]=19; SCALES[7*24+11]=22;
SCALES[7*24+12]=24; SCALES[7*24+13]=27; SCALES[7*24+14]=29;
SCALES[7*24+15]=30; SCALES[7*24+16]=31; SCALES[7*24+17]=34;
SCALES[7*24+18]=36; SCALES[7*24+19]=39; SCALES[7*24+20]=41;
SCALES[7*24+21]=42; SCALES[7*24+22]=43; SCALES[7*24+23]=46;

// ---- Colors (match DrumBanger palette) ----
COL_BG_R = 0.08; COL_BG_G = 0.08; COL_BG_B = 0.10;
COL_PAD_R = 0.15; COL_PAD_G = 0.16; COL_PAD_B = 0.20;
COL_HIT_R = 0.95; COL_HIT_G = 0.45; COL_HIT_B = 0.15;
COL_TXT_R = 0.85; COL_TXT_G = 0.85; COL_TXT_B = 0.88;
COL_ACC_R = 0.95; COL_ACC_G = 0.45; COL_ACC_B = 0.15;
COL_STEP_R = 0.30; COL_STEP_G = 0.75; COL_STEP_B = 0.55;
COL_DIM_R = 0.45; COL_DIM_G = 0.45; COL_DIM_B = 0.50;

// ============================================================
// FUNCTIONS
// ============================================================

// ---- Send note-off for all tracked notes ----
function all_notes_off() local(i, midi_ch) (
  midi_ch = slider4;

  // Turn off all chord/sustained notes
  i = 0;
  loop(notes_on_count,
    midisend(0, 0x80 | midi_ch, NOTES_ON[i], 0);
    i += 1;
  );
  notes_on_count = 0;

  // Turn off arp note
  arp_current_note >= 0 ? (
    midisend(0, 0x80 | midi_ch, arp_current_note, 0);
    arp_current_note = -1;
  );
);

// ---- Add a note to STEP_NOTES (clamped to MIDI range) ----
function add_step_note(note, vel) (
  note >= 0 && note <= 127 && step_notes_count < 64 ? (
    STEP_NOTES[step_notes_count] = note;
    STEP_VELS[step_notes_count] = min(127, vel);
    step_notes_count += 1;
  );
);

// ---- Build chord notes for a pad ----
function build_chord_for_pad(pad_idx, vel) local(scale_id, oct, root, n2, n3, n4, chord) (
  scale_id = slider7;
  oct = slider8 * 12;
  root = slider6 + SCALES[scale_id * 24 + pad_idx] + oct;
  chord = slider10;

  chord == 0 ? (
    // Off — single note
    add_step_note(root, vel);
  ) : chord == 1 ? (
    // Diatonic triad — stack 3rds from scale
    add_step_note(root, vel);
    add_step_note(slider6 + SCALES[scale_id * 24 + pad_idx + 2] + oct, vel);
    add_step_note(slider6 + SCALES[scale_id * 24 + pad_idx + 4] + oct, vel);
  ) : chord == 2 ? (
    // Diatonic 7th — stack four 3rds from scale
    add_step_note(root, vel);
    add_step_note(slider6 + SCALES[scale_id * 24 + pad_idx + 2] + oct, vel);
    add_step_note(slider6 + SCALES[scale_id * 24 + pad_idx + 4] + oct, vel);
    add_step_note(slider6 + SCALES[scale_id * 24 + pad_idx + 6] + oct, vel);
  ) : chord == 3 ? (
    // Major triad (forced)
    add_step_note(root, vel);
    add_step_note(root + 4, vel);
    add_step_note(root + 7, vel);
  ) : chord == 4 ? (
    // Minor triad (forced)
    add_step_note(root, vel);
    add_step_note(root + 3, vel);
    add_step_note(root + 7, vel);
  ) : chord == 5 ? (
    // Dominant 7th (forced)
    add_step_note(root, vel);
    add_step_note(root + 4, vel);
    add_step_note(root + 7, vel);
    add_step_note(root + 10, vel);
  ) : chord == 6 ? (
    // Power chord
    add_step_note(root, vel);
    add_step_note(root + 7, vel);
    add_step_note(root + 12, vel);
  ) : chord == 7 ? (
    // Octave
    add_step_note(root, vel);
    add_step_note(root + 12, vel);
  );
);

// ---- Calculate arp interval in samples ----
function get_arp_interval() local(bpm, beat_len) (
  bpm = gmem[14];
  bpm <= 0 ? bpm = 120;
  beat_len = srate * 60 / bpm;

  slider16 == 0 ? beat_len :         // 1/4
  slider16 == 1 ? beat_len / 2 :     // 1/8
  slider16 == 2 ? beat_len / 4 :     // 1/16
  slider16 == 3 ? beat_len / 8 :     // 1/32
  slider16 == 4 ? beat_len / 3 :     // 1/8T
  slider16 == 5 ? beat_len / 6 :     // 1/16T
  beat_len / 4;
);

// ---- Fire all step notes (non-arp mode) ----
function fire_all_notes() local(i, midi_ch) (
  midi_ch = slider4;
  i = 0;
  loop(step_notes_count,
    midisend(0, 0x90 | midi_ch, STEP_NOTES[i], STEP_VELS[i]);
    NOTES_ON[notes_on_count] = STEP_NOTES[i];
    notes_on_count += 1;
    i += 1;
  );
);

// ---- Start arp from step notes ----
function start_arp() local(i) (
  // Copy step notes to arp pool
  arp_pool_count = step_notes_count;
  i = 0;
  loop(step_notes_count,
    ARP_POOL[i] = STEP_NOTES[i];
    i += 1;
  );

  // Sort arp pool ascending (simple bubble sort, max 64 notes)
  sorted = 0;
  while (!sorted) (
    sorted = 1;
    i = 0;
    loop(arp_pool_count - 1,
      ARP_POOL[i] > ARP_POOL[i + 1] ? (
        tmp = ARP_POOL[i];
        ARP_POOL[i] = ARP_POOL[i + 1];
        ARP_POOL[i + 1] = tmp;
        sorted = 0;
      );
      i += 1;
    );
  );

  // Reset arp position
  arp_mode = slider15;
  arp_mode == 3 ? (
    // Down: start at top
    arp_pos = arp_pool_count - 1;
    arp_dir = -1;
  ) : (
    arp_pos = 0;
    arp_dir = 1;
  );

  arp_counter = 0;

  // Fire first note immediately
  arp_pool_count > 0 ? (
    note = ARP_POOL[arp_pos];
    midi_ch = slider4;
    midisend(0, 0x90 | midi_ch, note, slider5);
    arp_current_note = note;

    // Set gate timer
    arp_interval = get_arp_interval();
    arp_gate_counter = arp_interval * slider17 / 100;
  );
);

// ---- Advance arp to next note ----
function advance_arp() local(midi_ch, note, arp_mode) (
  arp_pool_count > 0 ? (
    midi_ch = slider4;
    arp_mode = slider15;

    // Advance position based on arp mode
    arp_mode == 1 ? (
      // Up
      arp_pos += 1;
      arp_pos >= arp_pool_count ? arp_pos = 0;
    ) : arp_mode == 2 ? (
      // Down
      arp_pos -= 1;
      arp_pos < 0 ? arp_pos = arp_pool_count - 1;
    ) : arp_mode == 3 ? (
      // Up-Down
      arp_pos += arp_dir;
      arp_pos >= arp_pool_count ? (
        arp_dir = -1;
        arp_pos = max(0, arp_pool_count - 2);
      ) : arp_pos < 0 ? (
        arp_dir = 1;
        arp_pos = min(1, arp_pool_count - 1);
      );
    ) : arp_mode == 4 ? (
      // Random
      arp_pos = (rand(arp_pool_count) | 0);
    );

    // Fire new note
    note = ARP_POOL[arp_pos];
    midisend(0, 0x90 | midi_ch, note, slider5);
    arp_current_note = note;

    // Reset gate timer
    arp_interval = get_arp_interval();
    arp_gate_counter = arp_interval * slider17 / 100;
  );
);

// ---- Draw a MIDI note name ----
function draw_note_name(note) local(n, oct) (
  n = note % 12;
  oct = (note / 12 | 0) - 1;
  n ==  0 ? gfx_drawstr("C") :
  n ==  1 ? gfx_drawstr("C#") :
  n ==  2 ? gfx_drawstr("D") :
  n ==  3 ? gfx_drawstr("D#") :
  n ==  4 ? gfx_drawstr("E") :
  n ==  5 ? gfx_drawstr("F") :
  n ==  6 ? gfx_drawstr("F#") :
  n ==  7 ? gfx_drawstr("G") :
  n ==  8 ? gfx_drawstr("G#") :
  n ==  9 ? gfx_drawstr("A") :
  n == 10 ? gfx_drawstr("A#") :
  n == 11 ? gfx_drawstr("B");
  gfx_drawnumber(oct, 0);
);

// ============================================================
// @BLOCK — Read Drumbanger state + output MIDI
// ============================================================
@block

// ---- Decode Watch slider ----
slider1 == 0 ? (
  watch_all = 1;
  watch_pad = 0;
) : (
  watch_all = 0;
  watch_pad = slider1 - 1;
);
midi_ch = slider4;

// ---- Check connection (timeout-based, no flicker) ----
heartbeat = gmem[10];
heartbeat != last_heartbeat ? (
  last_heartbeat = heartbeat;
  connected_timeout = srate * 0.5;  // hold "connected" for 0.5s
);
connected_timeout > 0 ? (
  connected_timeout -= samplesblock;
  connected = 1;
) : (
  connected = 0;
);

// ---- Read Drumbanger state ----
db_step = gmem[11];
db_steps_per_measure = gmem[12];
db_pattern = gmem[13];
db_bpm = gmem[14];
db_playing = gmem[15];

// ---- Transport stop: kill all notes ----
!db_playing && prev_playing ? (
  all_notes_off();
  arp_counter = 0;
  arp_gate_counter = 0;
);
prev_playing = db_playing;

// ---- Auto-sync pattern cache on first connection ----
connected && !pattern_synced ? sync_request = 1;

// ---- Copy patterns from DrumBanger to local cache on request ----
sync_request ? (
  sync_i = 0;
  loop(8 * 16 * 16,
    LOCAL_PAT[sync_i] = gmem[1000 + sync_i];
    sync_i += 1;
  );
  pattern_synced = 1;
  sync_request = 0;
);

// ---- Arp gate expiry (note off between arp ticks) ----
slider15 > 0 && arp_gate_counter > 0 ? (
  arp_gate_counter -= samplesblock;
  arp_gate_counter <= 0 && arp_current_note >= 0 ? (
    midisend(0, 0x80 | midi_ch, arp_current_note, 0);
    arp_current_note = -1;
  );
);

// ---- Arp tick (advance to next note) ----
slider15 > 0 && arp_pool_count > 0 && db_playing ? (
  arp_counter += samplesblock;
  arp_interval = get_arp_interval();
  arp_counter >= arp_interval ? (
    arp_counter -= arp_interval;

    // Note off current
    arp_current_note >= 0 ? (
      midisend(0, 0x80 | midi_ch, arp_current_note, 0);
      arp_current_note = -1;
    );

    // Advance and fire next
    advance_arp();
  );
);

// ---- Detect step change (for note lifetime, not re-sequencing) ----
step_changed = (db_step != last_step) && db_playing;

// ---- Determine pattern source ----
slider2 == 0 ? (
  drone_pattern = db_pattern;   // Follow DrumBanger
) : (
  drone_pattern = slider2 - 1;  // Locked to specific pattern
);

// ---- React to pad triggers ----
connected && db_playing ? (
  any_trigger = 0;
  step_notes_count = 0;

  slider2 == 0 ? (
    // FOLLOW MODE: use trigger flags from DrumBanger
    watch_all ? (
      p = 0;
      loop(16,
        trig_vel = gmem[100 + p];
        trig_vel > 0 ? (
          build_chord_for_pad(p, min(127, trig_vel));
          any_trigger = 1;
        );
        p += 1;
      );
    ) : (
      trig_vel = gmem[100 + watch_pad];
      trig_vel > 0 ? (
        build_chord_for_pad(watch_pad, min(127, trig_vel));
        any_trigger = 1;
      );
    );
  ) : step_changed ? (
    // LOCKED MODE: read from local cached pattern data
    watch_all ? (
      p = 0;
      loop(16,
        pvel = LOCAL_PAT[drone_pattern * 256 + db_step * 16 + p];
        pvel > 0 ? (
          build_chord_for_pad(p, min(127, pvel));
          any_trigger = 1;
        );
        p += 1;
      );
    ) : (
      pvel = LOCAL_PAT[drone_pattern * 256 + db_step * 16 + watch_pad];
      pvel > 0 ? (
        build_chord_for_pad(watch_pad, min(127, pvel));
        any_trigger = 1;
      );
    );
  );

  any_trigger ? (
    // New trigger: kill old notes, fire new ones
    all_notes_off();
    step_notes_count > 0 ? (
      slider15 > 0 ? start_arp() : fire_all_notes();
    );
  ) : step_changed ? (
    // Step moved with no new triggers: kill hanging notes + stop arp
    all_notes_off();
    arp_pool_count = 0;
    arp_counter = 0;
    arp_gate_counter = 0;
  );
);

last_step = db_step;

// ============================================================
// @SAMPLE — Pure passthrough
// ============================================================
@sample
// Audio passes through untouched

// ============================================================
// @GFX — User Interface (DrumBanger-matched aesthetic)
// ============================================================
@gfx 750 460

// ---- Background ----
gfx_r = COL_BG_R; gfx_g = COL_BG_G; gfx_b = COL_BG_B;
gfx_rect(0, 0, gfx_w, gfx_h);

margin = 10;
gfx_setfont(1, "Arial", 12);

// ============================================
// HEADER
// ============================================
gfx_r = COL_HIT_R; gfx_g = COL_HIT_G; gfx_b = COL_HIT_B;
gfx_x = margin; gfx_y = 4;
gfx_drawstr("DRONE MIDI");

// Signal chain hint
gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
gfx_x = gfx_w - 160; gfx_y = 6;
gfx_drawstr(">> SYNTH >> DroneFX");

// Connection + mode info
gfx_x = margin; gfx_y = 22;
connected ? (
  gfx_r = COL_STEP_R; gfx_g = COL_STEP_G; gfx_b = COL_STEP_B;
  gfx_drawstr("LINKED");
) : (
  gfx_r = 0.9; gfx_g = 0.15; gfx_b = 0.1;
  gfx_drawstr("NO SIGNAL");
);
gfx_r = COL_TXT_R; gfx_g = COL_TXT_G; gfx_b = COL_TXT_B;
slider1 == 0 ? (
  gfx_drawstr("  |  ALL PADS");
) : (
  gfx_drawstr("  |  Pad: ");
  gfx_drawnumber(slider1, 0);
);
gfx_drawstr("  |  Pat: ");
gfx_drawnumber(drone_pattern + 1, 0);
slider2 > 0 ? (
  gfx_r = COL_HIT_R; gfx_g = COL_HIT_G; gfx_b = COL_HIT_B;
  gfx_drawstr(" LOCK");
);

// ---- SYNC button (big, right side of connection row) ----
sync_btn_w = 70;
sync_btn_h = 20;
sync_btn_x = gfx_w - 90;
sync_btn_y = 18;

// Flash timer (counts down after click)
sync_flash > 0 ? sync_flash -= 1;

// Button background
sync_flash > 0 ? (
  gfx_r = COL_HIT_R; gfx_g = COL_HIT_G; gfx_b = COL_HIT_B;
) : pattern_synced ? (
  gfx_r = 0.18; gfx_g = 0.35; gfx_b = 0.22;
) : (
  gfx_r = 0.40; gfx_g = 0.15; gfx_b = 0.12;
);
gfx_rect(sync_btn_x, sync_btn_y, sync_btn_w, sync_btn_h);

// Button border (bright)
gfx_r = COL_TXT_R; gfx_g = COL_TXT_G; gfx_b = COL_TXT_B;
gfx_rect(sync_btn_x, sync_btn_y, sync_btn_w, 1);
gfx_rect(sync_btn_x, sync_btn_y + sync_btn_h - 1, sync_btn_w, 1);
gfx_rect(sync_btn_x, sync_btn_y, 1, sync_btn_h);
gfx_rect(sync_btn_x + sync_btn_w - 1, sync_btn_y, 1, sync_btn_h);

// Button label (centered)
gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_x = sync_btn_x + 10; gfx_y = sync_btn_y + 4;
gfx_drawstr("SYNC");

// Click handler — detect fresh mouse-down inside button
(mouse_cap & 1) && !(last_mouse_cap & 1) &&
  mouse_x >= sync_btn_x && mouse_x <= sync_btn_x + sync_btn_w &&
  mouse_y >= sync_btn_y && mouse_y <= sync_btn_y + sync_btn_h ? (
    sync_request = 1;
    sync_flash = 30;
);

// ============================================
// STEP DISPLAY
// ============================================
step_y = 44;
step_w = (gfx_w - margin * 2 - 15 * 3) / 16;
step_h = 24;

connected ? (
  s = 0;
  loop(16,
    sx = margin + s * (step_w + margin / 5);

    // Read pattern data: locked mode uses LOCAL_PAT, follow uses gmem
    slider2 > 0 ? (
      slider1 > 0 ? (
        sv = LOCAL_PAT[drone_pattern * 256 + s * 16 + (slider1 - 1)];
      ) : (
        sv = 0;
        pp = 0;
        loop(16,
          tv = LOCAL_PAT[drone_pattern * 256 + s * 16 + pp];
          tv > sv ? sv = tv;
          pp += 1;
        );
      );
    ) : (
      slider1 > 0 ? (
        sv = gmem[1000 + drone_pattern * 256 + s * 16 + (slider1 - 1)];
      ) : (
        sv = 0;
        pp = 0;
        loop(16,
          tv = gmem[1000 + drone_pattern * 256 + s * 16 + pp];
          tv > sv ? sv = tv;
          pp += 1;
        );
      );
    );

    s < db_steps_per_measure ? (
      sv > 0 ? (
        gfx_r = COL_STEP_R * (sv / 127);
        gfx_g = COL_STEP_G * (sv / 127);
        gfx_b = COL_STEP_B * (sv / 127);
      ) : (
        gfx_r = 0.12; gfx_g = 0.12; gfx_b = 0.15;
      );
    ) : (
      gfx_r = 0.06; gfx_g = 0.06; gfx_b = 0.08;
    );

    gfx_rect(sx, step_y, step_w, step_h);

    // Playhead border
    s == db_step && db_playing ? (
      gfx_r = 1; gfx_g = 1; gfx_b = 1;
      gfx_rect(sx, step_y, step_w, 2);
      gfx_rect(sx, step_y + step_h - 2, step_w, 2);
      gfx_rect(sx, step_y, 2, step_h);
      gfx_rect(sx + step_w - 2, step_y, 2, step_h);
    );

    // Beat markers
    s % 4 == 0 ? (
      gfx_r = 0.4; gfx_g = 0.4; gfx_b = 0.4;
      gfx_rect(sx, step_y + step_h + 2, step_w, 2);
    );

    s += 1;
  );
) : (
  gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
  gfx_x = margin; gfx_y = step_y + 4;
  gfx_drawstr("Waiting for Drumbanger...");
);

// ============================================
// SCALE MAP (pad → note)
// ============================================
map_y = step_y + step_h + 12;
gfx_setfont(3, "Arial", 9);

connected ? (
  s = 0;
  loop(16,
    sx = margin + s * (step_w + margin / 5);
    note = slider6 + SCALES[slider7 * 24 + s] + slider8 * 12;

    slider1 > 0 && s == (slider1 - 1) ? (
      gfx_r = COL_HIT_R; gfx_g = COL_HIT_G; gfx_b = COL_HIT_B;
    ) : (
      gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
    );

    gfx_x = sx; gfx_y = map_y;
    draw_note_name(note);

    s += 1;
  );
);

gfx_setfont(1, "Arial", 12);

// ============================================
// SECTION: NOTE SETTINGS (draggable bars)
// ============================================
ctrl_h = 20;
ctrl_bar_w = gfx_w - margin * 2 - 120;
ctrl_x = margin + 120;
ctrl_y = map_y + 18;

// -- Section label --
gfx_r = 0.7; gfx_g = 0.5; gfx_b = 0.3;
gfx_x = margin; gfx_y = ctrl_y - 14;
gfx_drawstr("NOTE SETTINGS");

// ---- Root Note bar ----
root_note = slider6;
rn_nn = root_note % 12;
rn_oct = (root_note / 12 | 0) - 1;

gfx_r = COL_TXT_R; gfx_g = COL_TXT_G; gfx_b = COL_TXT_B;
gfx_x = margin; gfx_y = ctrl_y + 2;
gfx_drawstr("Root ");
rn_nn == 0  ? gfx_drawstr("C") :
rn_nn == 1  ? gfx_drawstr("C#") :
rn_nn == 2  ? gfx_drawstr("D") :
rn_nn == 3  ? gfx_drawstr("D#") :
rn_nn == 4  ? gfx_drawstr("E") :
rn_nn == 5  ? gfx_drawstr("F") :
rn_nn == 6  ? gfx_drawstr("F#") :
rn_nn == 7  ? gfx_drawstr("G") :
rn_nn == 8  ? gfx_drawstr("G#") :
rn_nn == 9  ? gfx_drawstr("A") :
rn_nn == 10 ? gfx_drawstr("A#") :
gfx_drawstr("B");
gfx_drawnumber(rn_oct, 0);

// Bar background
gfx_r = 0.12; gfx_g = 0.12; gfx_b = 0.15;
gfx_rect(ctrl_x, ctrl_y, ctrl_bar_w, ctrl_h);
// Root note indicator
rn_norm = (root_note - 24) / 72;  // 24..96 → 0..1
gfx_r = COL_HIT_R; gfx_g = COL_HIT_G; gfx_b = COL_HIT_B;
rn_px = ctrl_x + max(0, min(1, rn_norm)) * ctrl_bar_w;
gfx_rect(rn_px - 4, ctrl_y, 8, ctrl_h);

// Drag root note
mouse_cap & 1 ? (
  mouse_x >= ctrl_x && mouse_x <= ctrl_x + ctrl_bar_w &&
  mouse_y >= ctrl_y && mouse_y < ctrl_y + ctrl_h ? (
    new_rn = max(24, min(96, floor(((mouse_x - ctrl_x) / ctrl_bar_w) * 72 + 24 + 0.5)));
    slider6 = new_rn;
  );
);

// ---- Octave Offset bar ----
ctrl_y2 = ctrl_y + ctrl_h + 6;
cur_oct = slider8;
gfx_r = COL_TXT_R; gfx_g = COL_TXT_G; gfx_b = COL_TXT_B;
gfx_x = margin; gfx_y = ctrl_y2 + 2;
gfx_drawstr("Oct  ");
cur_oct >= 0 ? gfx_drawstr("+");
gfx_drawnumber(cur_oct, 0);

// Bar background
gfx_r = 0.12; gfx_g = 0.12; gfx_b = 0.15;
gfx_rect(ctrl_x, ctrl_y2, ctrl_bar_w, ctrl_h);
// Center line
gfx_r = 0.25; gfx_g = 0.25; gfx_b = 0.3;
gfx_rect(ctrl_x + ctrl_bar_w / 2 - 1, ctrl_y2, 2, ctrl_h);
// Octave indicator
oct_norm = (cur_oct + 2) / 4;  // -2..+2 → 0..1
gfx_r = 0.5; gfx_g = 0.6; gfx_b = 1.0;
oct_px = ctrl_x + max(0, min(1, oct_norm)) * ctrl_bar_w;
gfx_rect(oct_px - 4, ctrl_y2, 8, ctrl_h);

// Drag octave
mouse_cap & 1 ? (
  mouse_x >= ctrl_x && mouse_x <= ctrl_x + ctrl_bar_w &&
  mouse_y >= ctrl_y2 && mouse_y < ctrl_y2 + ctrl_h ? (
    new_oct = max(-2, min(2, floor(((mouse_x - ctrl_x) / ctrl_bar_w) * 4 - 2 + 0.5)));
    slider8 = new_oct;
  );
);

// ---- Velocity bar ----
ctrl_y3 = ctrl_y2 + ctrl_h + 6;
cur_vel = slider5;
gfx_r = COL_TXT_R; gfx_g = COL_TXT_G; gfx_b = COL_TXT_B;
gfx_x = margin; gfx_y = ctrl_y3 + 2;
gfx_drawstr("Vel  ");
gfx_drawnumber(cur_vel, 0);

// Bar background
gfx_r = 0.12; gfx_g = 0.12; gfx_b = 0.15;
gfx_rect(ctrl_x, ctrl_y3, ctrl_bar_w, ctrl_h);
// Bar fill
gfx_r = COL_STEP_R; gfx_g = COL_STEP_G; gfx_b = COL_STEP_B;
gfx_rect(ctrl_x, ctrl_y3, ctrl_bar_w * (cur_vel / 127), ctrl_h);

// Drag velocity
mouse_cap & 1 ? (
  mouse_x >= ctrl_x && mouse_x <= ctrl_x + ctrl_bar_w &&
  mouse_y >= ctrl_y3 && mouse_y < ctrl_y3 + ctrl_h ? (
    slider5 = max(0, min(127, floor((mouse_x - ctrl_x) / ctrl_bar_w * 127 + 0.5)));
  );
);

// ============================================
// SECTION: CHORD + ARP INFO
// ============================================
ctrl_y4 = ctrl_y3 + ctrl_h + 16;

// -- Section label --
gfx_r = 0.7; gfx_g = 0.5; gfx_b = 0.3;
gfx_x = margin; gfx_y = ctrl_y4 - 14;
gfx_drawstr("CHORD / ARP");

// Chord + Scale info row
gfx_r = COL_TXT_R; gfx_g = COL_TXT_G; gfx_b = COL_TXT_B;
gfx_x = margin; gfx_y = ctrl_y4;
gfx_drawstr("Scale: ");
gfx_r = COL_STEP_R; gfx_g = COL_STEP_G; gfx_b = COL_STEP_B;
slider7 == 0 ? gfx_drawstr("Chromatic") :
slider7 == 1 ? gfx_drawstr("Major") :
slider7 == 2 ? gfx_drawstr("Minor") :
slider7 == 3 ? gfx_drawstr("Dorian") :
slider7 == 4 ? gfx_drawstr("Mixolydian") :
slider7 == 5 ? gfx_drawstr("Pent Maj") :
slider7 == 6 ? gfx_drawstr("Pent Min") :
gfx_drawstr("Blues");

gfx_r = COL_TXT_R; gfx_g = COL_TXT_G; gfx_b = COL_TXT_B;
gfx_drawstr("   Chord: ");
slider10 == 0 ? (
  gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
  gfx_drawstr("OFF");
) : (
  gfx_r = 0.5; gfx_g = 0.6; gfx_b = 1.0;
  slider10 == 1 ? gfx_drawstr("Diatonic") :
  slider10 == 2 ? gfx_drawstr("Diatonic 7th") :
  slider10 == 3 ? gfx_drawstr("Major") :
  slider10 == 4 ? gfx_drawstr("Minor") :
  slider10 == 5 ? gfx_drawstr("Dom7") :
  slider10 == 6 ? gfx_drawstr("Power") :
  gfx_drawstr("Octave");
);

// Arp info row
ctrl_y5 = ctrl_y4 + 18;
gfx_x = margin; gfx_y = ctrl_y5;
gfx_r = COL_TXT_R; gfx_g = COL_TXT_G; gfx_b = COL_TXT_B;
gfx_drawstr("Arp: ");

slider15 == 0 ? (
  gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
  gfx_drawstr("OFF");
) : (
  gfx_r = 0.8; gfx_g = 0.5; gfx_b = 0.2;
  slider15 == 1 ? gfx_drawstr("UP") :
  slider15 == 2 ? gfx_drawstr("DOWN") :
  slider15 == 3 ? gfx_drawstr("UP-DOWN") :
  gfx_drawstr("RANDOM");

  gfx_r = COL_TXT_R; gfx_g = COL_TXT_G; gfx_b = COL_TXT_B;
  gfx_drawstr("  Rate: ");
  gfx_r = 0.8; gfx_g = 0.5; gfx_b = 0.2;
  slider16 == 0 ? gfx_drawstr("1/4") :
  slider16 == 1 ? gfx_drawstr("1/8") :
  slider16 == 2 ? gfx_drawstr("1/16") :
  slider16 == 3 ? gfx_drawstr("1/32") :
  slider16 == 4 ? gfx_drawstr("1/8T") :
  gfx_drawstr("1/16T");

  gfx_r = COL_TXT_R; gfx_g = COL_TXT_G; gfx_b = COL_TXT_B;
  gfx_drawstr("  Notes: ");
  gfx_r = COL_STEP_R; gfx_g = COL_STEP_G; gfx_b = COL_STEP_B;
  gfx_drawnumber(arp_pool_count, 0);
);

// ---- Arp Gate bar ----
ctrl_y6 = ctrl_y5 + 20;
cur_gate = slider17;
gfx_r = COL_TXT_R; gfx_g = COL_TXT_G; gfx_b = COL_TXT_B;
gfx_x = margin; gfx_y = ctrl_y6 + 2;
gfx_drawstr("Gate ");
gfx_drawnumber(cur_gate, 0);
gfx_drawstr("%");

// Bar background
gfx_r = 0.12; gfx_g = 0.12; gfx_b = 0.15;
gfx_rect(ctrl_x, ctrl_y6, ctrl_bar_w, ctrl_h);
// Bar fill
slider15 > 0 ? (
  gfx_r = 0.8; gfx_g = 0.5; gfx_b = 0.2;
) : (
  gfx_r = 0.2; gfx_g = 0.2; gfx_b = 0.22;
);
gfx_rect(ctrl_x, ctrl_y6, ctrl_bar_w * ((cur_gate - 10) / 90), ctrl_h);

// Drag gate
mouse_cap & 1 ? (
  mouse_x >= ctrl_x && mouse_x <= ctrl_x + ctrl_bar_w &&
  mouse_y >= ctrl_y6 && mouse_y < ctrl_y6 + ctrl_h ? (
    slider17 = max(10, min(100, floor((mouse_x - ctrl_x) / ctrl_bar_w * 90 + 10 + 0.5)));
  );
);

// ============================================
// ACTIVE NOTES DISPLAY
// ============================================
notes_y = ctrl_y6 + ctrl_h + 14;
gfx_x = margin; gfx_y = notes_y;
gfx_r = COL_TXT_R; gfx_g = COL_TXT_G; gfx_b = COL_TXT_B;

arp_current_note >= 0 ? (
  gfx_drawstr("Playing: ");
  gfx_r = COL_STEP_R; gfx_g = COL_STEP_G; gfx_b = COL_STEP_B;
  draw_note_name(arp_current_note);
) : notes_on_count > 0 ? (
  gfx_drawstr("Playing: ");
  gfx_r = COL_STEP_R; gfx_g = COL_STEP_G; gfx_b = COL_STEP_B;
  i = 0;
  loop(min(notes_on_count, 8),
    i > 0 ? gfx_drawstr(" ");
    draw_note_name(NOTES_ON[i]);
    i += 1;
  );
  notes_on_count > 8 ? gfx_drawstr(" ...");
) : (
  gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
  gfx_drawstr("idle");
);

// ============================================
// DEBUG: raw pattern data readout
// ============================================
dbg_y = notes_y + 22;
gfx_setfont(3, "Arial", 9);

gfx_r = 0.6; gfx_g = 0.4; gfx_b = 0.2;
gfx_x = margin; gfx_y = dbg_y;
gfx_drawstr("DBG  drone_pat=");
gfx_drawnumber(drone_pattern, 0);
gfx_drawstr("  db_pat=");
gfx_drawnumber(db_pattern, 0);
gfx_drawstr("  db_step=");
gfx_drawnumber(db_step, 0);
gfx_drawstr("  slider2=");
gfx_drawnumber(slider2, 0);
gfx_drawstr("  synced=");
gfx_drawnumber(pattern_synced, 0);

// Show first 16 values of gmem pattern data for current drone_pattern, step 0
dbg_y += 12;
gfx_x = margin; gfx_y = dbg_y;
gfx_r = 0.5; gfx_g = 0.5; gfx_b = 0.7;
gfx_drawstr("gmem step0: ");
dbg_p = 0;
loop(16,
  gfx_drawnumber(gmem[1000 + drone_pattern * 256 + 0 * 16 + dbg_p], 0);
  gfx_drawstr(" ");
  dbg_p += 1;
);

// Show first 16 values of LOCAL_PAT for current drone_pattern, step 0
dbg_y += 12;
gfx_x = margin; gfx_y = dbg_y;
gfx_r = 0.5; gfx_g = 0.7; gfx_b = 0.5;
gfx_drawstr("local step0: ");
dbg_p = 0;
loop(16,
  gfx_drawnumber(LOCAL_PAT[drone_pattern * 256 + 0 * 16 + dbg_p], 0);
  gfx_drawstr(" ");
  dbg_p += 1;
);

// Show total non-zero count across all steps for this pattern (gmem)
dbg_y += 12;
gfx_x = margin; gfx_y = dbg_y;
gfx_r = 0.5; gfx_g = 0.5; gfx_b = 0.7;
dbg_nz_gmem = 0;
dbg_i = 0;
loop(256,
  gmem[1000 + drone_pattern * 256 + dbg_i] > 0 ? dbg_nz_gmem += 1;
  dbg_i += 1;
);
gfx_drawstr("gmem nonzero: ");
gfx_drawnumber(dbg_nz_gmem, 0);

// Same for LOCAL_PAT
gfx_r = 0.5; gfx_g = 0.7; gfx_b = 0.5;
dbg_nz_loc = 0;
dbg_i = 0;
loop(256,
  LOCAL_PAT[drone_pattern * 256 + dbg_i] > 0 ? dbg_nz_loc += 1;
  dbg_i += 1;
);
gfx_drawstr("  local nonzero: ");
gfx_drawnumber(dbg_nz_loc, 0);

gfx_setfont(1, "Arial", 12);

// ---- Store mouse state for debounce ----
last_mouse_cap = mouse_cap;

// ============================================
// STATUS BAR
// ============================================
gfx_r = COL_TXT_R; gfx_g = COL_TXT_G; gfx_b = COL_TXT_B;
gfx_x = margin; gfx_y = gfx_h - 18;
connected ? (
  db_playing ? gfx_drawstr("▶ ") : gfx_drawstr("■ ");
  gfx_drawstr("BPM: ");
  gfx_drawnumber(db_bpm, 1);
  gfx_drawstr("  Step: ");
  gfx_drawnumber(db_step + 1, 0);
  gfx_drawstr("/");
  gfx_drawnumber(db_steps_per_measure, 0);
  gfx_drawstr("  Pat: ");
  gfx_drawnumber(drone_pattern + 1, 0);
  slider2 > 0 ? gfx_drawstr(" LCK");
) : (
  gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
  gfx_drawstr("No Drumbanger detected — add LMS Drumbanger to any track");
);
