desc:LMS Drumbanger
//author: LMS
//version: 0.1.0
//license: GPL-3.0
//
// A simple 16-pad drum sampler + step sequencer for Reaper.
// Digitakt-inspired UI. Load kits from wav folders.
// MIDI notes 36-51 (C1 to D#2) trigger pads 1-16.

options:maxmem=16777216

// ============================================================
// SLIDER DEFINITIONS
// ============================================================
// Global controls
slider1:120<30,300,0.1>BPM (host sync overrides)
slider2:0<0,100,1>Swing %
slider3:0<0,7,1{Pattern 1,Pattern 2,Pattern 3,Pattern 4,Pattern 5,Pattern 6,Pattern 7,Pattern 8}>-Current Pattern
slider4:0.8<0,1,0.01>Master Volume
slider5:1<0,1,1{Off,On}>Sequencer
slider6:0<0,1,1{Off,Rec}>Record Input
slider7:0<0,7,1{Kit 1,Kit 2,Kit 3,Kit 4,Kit 5,Kit 6,Kit 7,Kit 8}>Kit Select

// Per-pad volume (pads 1-16) — sliders 10-25 (hidden, controlled via GFX)
slider10:0.8<0,1,0.01>-Pad 01 Vol
slider11:0.8<0,1,0.01>-Pad 02 Vol
slider12:0.8<0,1,0.01>-Pad 03 Vol
slider13:0.8<0,1,0.01>-Pad 04 Vol
slider14:0.8<0,1,0.01>-Pad 05 Vol
slider15:0.8<0,1,0.01>-Pad 06 Vol
slider16:0.8<0,1,0.01>-Pad 07 Vol
slider17:0.8<0,1,0.01>-Pad 08 Vol
slider18:0.8<0,1,0.01>-Pad 09 Vol
slider19:0.8<0,1,0.01>-Pad 10 Vol
slider20:0.8<0,1,0.01>-Pad 11 Vol
slider21:0.8<0,1,0.01>-Pad 12 Vol
slider22:0.8<0,1,0.01>-Pad 13 Vol
slider23:0.8<0,1,0.01>-Pad 14 Vol
slider24:0.8<0,1,0.01>-Pad 15 Vol
slider25:0.8<0,1,0.01>-Pad 16 Vol

// Per-pad pan (pads 1-16) — sliders 30-45 (hidden, controlled via GFX)
slider30:0<-1,1,0.01>-Pad 01 Pan
slider31:0<-1,1,0.01>-Pad 02 Pan
slider32:0<-1,1,0.01>-Pad 03 Pan
slider33:0<-1,1,0.01>-Pad 04 Pan
slider34:0<-1,1,0.01>-Pad 05 Pan
slider35:0<-1,1,0.01>-Pad 06 Pan
slider36:0<-1,1,0.01>-Pad 07 Pan
slider37:0<-1,1,0.01>-Pad 08 Pan
slider38:0<-1,1,0.01>-Pad 09 Pan
slider39:0<-1,1,0.01>-Pad 10 Pan
slider40:0<-1,1,0.01>-Pad 11 Pan
slider41:0<-1,1,0.01>-Pad 12 Pan
slider42:0<-1,1,0.01>-Pad 13 Pan
slider43:0<-1,1,0.01>-Pad 14 Pan
slider44:0<-1,1,0.01>-Pad 15 Pan
slider45:0<-1,1,0.01>-Pad 16 Pan

// Per-pad pitch (semitones) — sliders 50-65 (hidden, controlled via GFX)
slider50:0<-24,24,0.1>-Pad 01 Pitch
slider51:0<-24,24,0.1>-Pad 02 Pitch
slider52:0<-24,24,0.1>-Pad 03 Pitch
slider53:0<-24,24,0.1>-Pad 04 Pitch
slider54:0<-24,24,0.1>-Pad 05 Pitch
slider55:0<-24,24,0.1>-Pad 06 Pitch
slider56:0<-24,24,0.1>-Pad 07 Pitch
slider57:0<-24,24,0.1>-Pad 08 Pitch
slider58:0<-24,24,0.1>-Pad 09 Pitch
slider59:0<-24,24,0.1>-Pad 10 Pitch
slider60:0<-24,24,0.1>-Pad 11 Pitch
slider61:0<-24,24,0.1>-Pad 12 Pitch
slider62:0<-24,24,0.1>-Pad 13 Pitch
slider63:0<-24,24,0.1>-Pad 14 Pitch
slider64:0<-24,24,0.1>-Pad 15 Pitch
slider65:0<-24,24,0.1>-Pad 16 Pitch

// Output bus (hidden, controlled via GFX)
slider70:0<0,100,0.1>-Sat Drive (%)
slider71:0<0,100,0.1>-Comp Peak Reduction (%)
slider72:0<-12,12,0.1>-Comp Gain (dB)

// ============================================================
// MEMORY MAP
// ============================================================
// Memory layout (using JSFX global memory):
//
// 0-15:        pad_playing[16]     — 1 if pad is currently playing
// 16-31:       pad_pos[16]         — current playback position (samples)
// 32-47:       pad_velocity[16]    — last trigger velocity (0-1)
// 48-63:       pad_decay[16]       — decay envelope value
// 64-79:       pad_length[16]      — sample length in samples
// 80-95:       pad_handle[16]      — file handle for loaded sample
// 96-111:      pad_nch[16]         — channels in loaded sample (1=mono, 2=stereo)
// 112-127:     pad_srate[16]       — original sample rate of loaded file
//
// 1000-9999:   sequencer patterns
//   pattern N (0-7), step S (0-15), pad P (0-15):
//   address = 1000 + N*256 + S*16 + P
//   value = velocity (0-127), 0 = off
//
// 10000+:      sample data buffer (loaded via file_open)

@init

// ---- Constants ----
NUM_PADS = 16;
NUM_STEPS = 16;
NUM_PATTERNS = 8;
MIDI_NOTE_BASE = 36;  // C1

// ---- Memory offsets ----
PAD_PLAYING   = 0;
PAD_POS       = 16;
PAD_VELOCITY  = 32;
PAD_DECAY     = 48;
PAD_LENGTH    = 64;
PAD_HANDLE    = 80;
PAD_NCH       = 96;
PAD_SRATE     = 112;
PAD_KILL_POS  = 128;   // saved position of killed voice for crossfade
PAD_KILL_VEL  = 144;   // saved velocity of killed voice
PAD_KILL_FADE = 160;   // fade counter (counts down from XFADE_LEN to 0)

XFADE_LEN     = 64;    // crossfade length in samples (~1.3ms at 48kHz)

SEQ_BASE      = 1000;
SAMPLE_BUF    = 10000;

// ---- Sequencer state ----
seq_step = 0;
seq_running = 0;
steps_per_measure = NUM_STEPS;
beats_per_measure = 4;
measure_num = 0;
transport_playing = 0;

// ---- Per-pad sample buffer offsets ----
// Each pad gets up to 5 seconds of stereo audio at 48kHz
// 48000 * 5 = 240000 frames * 2 channels = 480000 interleaved samples
PAD_BUF_SIZE = 480000;

// Pad playback state (PAD_PLAYING, PAD_POS, PAD_VELOCITY, PAD_DECAY) is NOT
// zeroed here. JSFX memory starts at 0 on first load. On subsequent @init
// calls (sample rate change, undo, etc.), active voices survive uninterrupted.
// Pattern data at SEQ_BASE is also preserved — @serialize handles persistence.

// ---- Request memory for sample buffers ----
freembuf(SAMPLE_BUF + NUM_PADS * PAD_BUF_SIZE);

// ---- Load kit function (defined before first call) ----
function load_kit_samples(kit_num) local(i, handle, nch, sr, buf_offset, num_read) (
  // Stop all voices — sample data is about to be overwritten
  i = 0;
  loop(NUM_PADS,
    PAD_PLAYING[i] = 0;
    PAD_KILL_FADE[i] = 0;
    i += 1;
  );
  kit_loaded = 0;
  i = 0;
  loop(NUM_PADS,
    PAD_NCH[i] = 0;
    PAD_SRATE[i] = 0;
    PAD_LENGTH[i] = 0;
    sprintf(#pad_filename, "kits/%d/%02d.wav", kit_num + 1, i + 1);
    handle = file_open(#pad_filename);
    handle >= 0 ? (
      file_riff(handle, nch, sr);
      nch > 0 ? (
        PAD_NCH[i] = nch;
        PAD_SRATE[i] = sr;
        buf_offset = SAMPLE_BUF + i * PAD_BUF_SIZE;
        num_read = file_mem(handle, buf_offset, PAD_BUF_SIZE);
        PAD_LENGTH[i] = nch > 1 ? (num_read / nch) : num_read;
        kit_loaded += 1;
      );
      file_close(handle);
    );
    i += 1;
  );
  loaded_kit_num = kit_num;
);

// ---- Load initial kit ----
// Kits live in: <effect_dir>/kits/1/01.wav through 16.wav
//               <effect_dir>/kits/2/01.wav through 16.wav  etc.
// 8 kit slots, numbered folders 1-8. 16 wav files each (01.wav-16.wav).
loaded_kit_num = -1;
load_kit_samples(slider7);

// ---- Sample pool (for right-click pad assignment) ----
// Pool lives in: <effect_dir>/pool/*.wav
// Run scan_pool.sh to generate pool/manifest.txt
pool_count = 0;
pool_manifest = file_open("pool/manifest.txt");
pool_manifest >= 0 ? (
  file_text(pool_manifest);
  while(file_avail(pool_manifest) > 0 && pool_count < 500) (
    file_string(pool_manifest, 100 + pool_count);
    // Trim trailing whitespace / newlines / carriage returns
    while(strlen(100 + pool_count) > 0 &&
          str_getchar(100 + pool_count, strlen(100 + pool_count) - 1) <= 32) (
      str_setlen(100 + pool_count, strlen(100 + pool_count) - 1);
    );
    // Only count non-empty lines
    strlen(100 + pool_count) > 0 ? (
      pool_count += 1;
    );
  );
  file_close(pool_manifest);
);

// ---- Pool load request (GFX → block communication) ----
pool_load_pad = -1;   // -1 = no request, 0-15 = pad to load into
pool_load_idx = -1;   // pool manifest index to load

// ---- UI state ----
// ui_selected_pad persists naturally (defaults to 0 on first load, survives @init)
notice_show = 0;

// ---- Colors (Digitakt-inspired palette) ----
// Background
COL_BG_R = 0.08; COL_BG_G = 0.08; COL_BG_B = 0.10;
// Pad off
COL_PAD_R = 0.15; COL_PAD_G = 0.16; COL_PAD_B = 0.20;
// Pad active/triggered
COL_HIT_R = 0.95; COL_HIT_G = 0.45; COL_HIT_B = 0.15;
// Step on
COL_STEP_R = 0.30; COL_STEP_G = 0.75; COL_STEP_B = 0.55;
// Step current (playhead)
COL_HEAD_R = 1.0; COL_HEAD_G = 1.0; COL_HEAD_B = 1.0;
// Text
COL_TXT_R = 0.85; COL_TXT_G = 0.85; COL_TXT_B = 0.88;

// ---- Output bus state ----
// Opto compressor (LA-2A style)
opto_gr = 0;      // current gain reduction in dB
opto_fast = 0;    // fast release envelope
opto_slow = 0;    // slow release envelope
comp_gr_display = 0;  // GR for GFX meter

// DC blocker (removes offset from saturation)
dc_xl = 0; dc_xr = 0;
dc_yl = 0; dc_yr = 0;
dc_r = 1 - (220 / srate);

// ============================================================
// FUNCTIONS
// ============================================================

// tanh approximation (JSFX doesn't have built-in tanh)
function tanh(x) local(e2x) (
  x > 10 ? 1 : x < -10 ? -1 : (
    e2x = exp(2 * x);
    (e2x - 1) / (e2x + 1);
  );
);

function trigger_pad(pad, vel) local(v) (
  pad >= 0 && pad < NUM_PADS ? (
    // If already playing, save old voice for crossfade-out
    PAD_PLAYING[pad] ? (
      PAD_KILL_POS[pad] = PAD_POS[pad];
      PAD_KILL_VEL[pad] = PAD_VELOCITY[pad];
      PAD_KILL_FADE[pad] = XFADE_LEN;
    );
    v = vel / 127;
    PAD_PLAYING[pad] = 1;
    PAD_POS[pad] = 0;
    PAD_VELOCITY[pad] = v;
    PAD_DECAY[pad] = 1.0;
  );
);

function get_seq_addr(pattern, step, pad) (
  SEQ_BASE + pattern * 256 + step * 16 + pad;
);

function set_seq_step(pattern, step, pad, vel) (
  get_seq_addr(pattern, step, pad)[] = vel;
);

function get_seq_step(pattern, step, pad) (
  get_seq_addr(pattern, step, pad)[];
);

function toggle_seq_step(pattern, step, pad) local(addr, val) (
  addr = get_seq_addr(pattern, step, pad);
  val = addr[];
  val > 0 ? addr[] = 0 : addr[] = 100;
);

function load_pad_from_pool(pad, pool_idx) local(handle, nch, sr, buf_offset, num_read) (
  // Build path: pool/<filename>
  strcpy(#pool_path, "pool/");
  strcat(#pool_path, 100 + pool_idx);
  handle = file_open(#pool_path);
  handle >= 0 ? (
    file_riff(handle, nch, sr);
    nch > 0 ? (
      PAD_PLAYING[pad] = 0;
      PAD_KILL_FADE[pad] = 0;
      PAD_NCH[pad] = nch;
      PAD_SRATE[pad] = sr;
      buf_offset = SAMPLE_BUF + pad * PAD_BUF_SIZE;
      num_read = file_mem(handle, buf_offset, PAD_BUF_SIZE);
      PAD_LENGTH[pad] = nch > 1 ? (num_read / nch) : num_read;
    );
    file_close(handle);
  );
);

// ============================================================
// @BLOCK — MIDI + Sequencer (runs per audio block)
// ============================================================
@block

// ---- Kit hot-reload on slider change ----
slider7 != loaded_kit_num ? load_kit_samples(slider7);

// ---- Pool sample load request from GFX ----
pool_load_pad >= 0 ? (
  load_pad_from_pool(pool_load_pad, pool_load_idx);
  trigger_pad(pool_load_pad, 100);
  pool_load_pad = -1;
);

// ---- Sequencer on/off (MIDI always triggers pads regardless) ----
seq_mode = (slider5 == 1);

// ---- Timeline sync (computed first — needed for recording) ----

// Time signature → steps per measure
// 4/4 → 16 steps, 3/4 → 12, 6/8 → 12, 7/8 → 14 (capped at 16)
ts_denom > 0 ? (
  beats_per_measure = ts_num * 4.0 / ts_denom;
) : (
  beats_per_measure = 4;
);
steps_per_measure = min(floor(beats_per_measure * 4 + 0.5), NUM_STEPS);
steps_per_measure = max(steps_per_measure, 1);

// Current timeline position → step (with swing)
beats_per_measure > 0 ? (
  measure_num = floor(beat_position / beats_per_measure);
  beat_in_measure = beat_position - measure_num * beats_per_measure;
  raw_pos = beat_in_measure * 4;  // fractional step position (0 to steps_per_measure)

  // Swing: shift the split point within each pair of steps
  // At 0% swing = straight (split at 1.0), at 100% = heavy shuffle (split at 1.9)
  swing_split = 1.0 + (slider2 / 100) * 0.9;
  pair = (raw_pos / 2) | 0;           // which pair (0-7)
  pos_in_pair = raw_pos - pair * 2;   // 0.0 to 2.0
  pos_in_pair < swing_split ? (
    timeline_step = pair * 2;
  ) : (
    timeline_step = pair * 2 + 1;
  );

  timeline_step = max(0, min(timeline_step, steps_per_measure - 1));
) : (
  timeline_step = 0;
  measure_num = 0;
);

// Detect transport state transitions
prev_transport = transport_playing;
transport_playing = (play_state & 1);
transport_started = transport_playing && !prev_transport;

// Trigger pads on step change OR transport start (sequence mode only)
seq_mode && transport_playing && (timeline_step != seq_step || transport_started) ? (
  cur_pattern = slider3;
  p = 0;
  loop(NUM_PADS,
    vel = get_seq_step(cur_pattern, timeline_step, p);
    vel > 0 ? trigger_pad(p, vel);
    p += 1;
  );
);

// Track timeline position (must be set before MIDI for recording)
seq_step = timeline_step;

// ---- Read incoming MIDI ----
while(midirecv(offset, msg1, msg2, msg3)) (
  status = msg1 & 0xF0;
  // Note On — MIDI always triggers pads (like a real drum machine)
  status == 0x90 && msg3 > 0 ? (
    note = msg2;
    pad = note - MIDI_NOTE_BASE;
    pad >= 0 && pad < NUM_PADS ? (
      trigger_pad(pad, msg3);
      // REC: also write to pattern when sequencer is running
      seq_mode && slider6 == 1 && transport_playing ? (
        set_seq_step(slider3, seq_step, pad, msg3);
      );
    );
  );
  // Always pass MIDI through
  midisend(offset, msg1, msg2, msg3);
);

// ============================================================
// @SAMPLE — Audio generation (runs per sample)
// ============================================================
@sample

out_l = 0;
out_r = 0;
master_vol = slider4;

p = 0;
loop(NUM_PADS,
  PAD_PLAYING[p] || PAD_KILL_FADE[p] > 0 ? (
    len = PAD_LENGTH[p];
    nch = PAD_NCH[p];
    buf_offset = SAMPLE_BUF + p * PAD_BUF_SIZE;

    // Per-pad parameters (computed once for main voice + kill tail)
    semitones = slider(50 + p);
    pitch_rate = pow(2, semitones / 12);
    PAD_SRATE[p] > 0 ? pitch_rate *= PAD_SRATE[p] / srate;
    pad_vol = slider(10 + p);
    pad_pan = slider(30 + p);
    pan_l = cos(($pi/4) * (pad_pan + 1));
    pan_r = sin(($pi/4) * (pad_pan + 1));

    // ---- Main voice ----
    PAD_PLAYING[p] ? (
      pos = PAD_POS[p];

      // Loaded sample playback
      len > 0 && nch > 0 && pos < len ? (
        // Linear interpolation
        idx = (pos | 0);
        frac = pos - idx;
        idx1 = min(idx + 1, len - 1);

        nch >= 2 ? (
          sample_l = buf_offset[idx * 2]     + frac * (buf_offset[idx1 * 2]     - buf_offset[idx * 2]);
          sample_r = buf_offset[idx * 2 + 1] + frac * (buf_offset[idx1 * 2 + 1] - buf_offset[idx * 2 + 1]);
        ) : (
          sample_l = buf_offset[idx] + frac * (buf_offset[idx1] - buf_offset[idx]);
          sample_r = sample_l;
        );

        // Fade-in on new triggers (crossfade with kill tail)
        pos < XFADE_LEN ? (
          sample_l *= pos / XFADE_LEN;
          sample_r *= pos / XFADE_LEN;
        );

        sample_l *= PAD_VELOCITY[p];
        sample_r *= PAD_VELOCITY[p];

        out_l += sample_l * pad_vol * pan_l;
        out_r += sample_r * pad_vol * pan_r;

        PAD_POS[p] = pos + pitch_rate;

      // No sample loaded — placeholder noise burst
      ) : len == 0 ? (
        ipos = (PAD_POS[p] | 0);
        ipos < 200 ? (
          pad_out = (rand(2) - 1) * PAD_VELOCITY[p] * PAD_DECAY[p];
          PAD_DECAY[p] *= 0.9997;
          out_l += pad_out * pad_vol * pan_l;
          out_r += pad_out * pad_vol * pan_r;
          PAD_POS[p] += 1;
        ) : (
          PAD_PLAYING[p] = 0;
        );

      // Sample finished
      ) : (
        PAD_PLAYING[p] = 0;
      );
    );

    // ---- Kill tail: fade out the old voice on retrigger ----
    PAD_KILL_FADE[p] > 0 && len > 0 && nch > 0 ? (
      kill_pos = PAD_KILL_POS[p];
      kill_pos < len ? (
        kidx = (kill_pos | 0);
        kfrac = kill_pos - kidx;
        kidx1 = min(kidx + 1, len - 1);

        nch >= 2 ? (
          kl = buf_offset[kidx * 2]     + kfrac * (buf_offset[kidx1 * 2]     - buf_offset[kidx * 2]);
          kr = buf_offset[kidx * 2 + 1] + kfrac * (buf_offset[kidx1 * 2 + 1] - buf_offset[kidx * 2 + 1]);
        ) : (
          kl = buf_offset[kidx] + kfrac * (buf_offset[kidx1] - buf_offset[kidx]);
          kr = kl;
        );

        kill_fade = PAD_KILL_FADE[p] / XFADE_LEN;
        kl *= PAD_KILL_VEL[p] * kill_fade;
        kr *= PAD_KILL_VEL[p] * kill_fade;

        out_l += kl * pad_vol * pan_l;
        out_r += kr * pad_vol * pan_r;

        PAD_KILL_POS[p] = kill_pos + pitch_rate;
      );
      PAD_KILL_FADE[p] -= 1;
    );
  );
  p += 1;
);

// ---- OUTPUT BUS: Tape Saturation ----
sat_drive = slider70 / 100;
sat_drive > 0 ? (
  sat_amt = sat_drive * 1.5;
  out_l = (2 / $pi) * atan(out_l * (1 + sat_amt) * $pi * 0.5);
  out_r = (2 / $pi) * atan(out_r * (1 + sat_amt) * $pi * 0.5);
);

// ---- OUTPUT BUS: LA-2A Optical Compressor ----
comp_amount = slider71 / 100;
comp_amount > 0 ? (
  // Peak detection (stereo linked)
  det = max(abs(out_l), abs(out_r));
  det_db = det > 0.0000001 ? 20 * log10(det) : -140;

  // Soft-knee threshold (scales with Peak Reduction knob)
  thresh_db = -6 - comp_amount * 40;
  over_db = det_db - thresh_db;

  // Soft-knee gain computer (~3:1 ratio, LA-2A style)
  over_db > 0 ? (
    target_gr_db = over_db * (1 - 1/3);
  ) : over_db > -6 ? (
    // Soft knee region
    target_gr_db = (over_db + 6) * (over_db + 6) / 18;
  ) : (
    target_gr_db = 0;
  );

  // Opto cell model: fast attack (~10ms), dual-stage release
  opto_att = exp(-1 / (0.010 * srate));
  opto_rel_fast = exp(-1 / (0.060 * srate));
  opto_rel_slow = exp(-1 / (1.0 * srate));

  target_gr_db > opto_gr ? (
    // Attack
    opto_gr = opto_att * opto_gr + (1 - opto_att) * target_gr_db;
  ) : (
    // Dual-stage release (T4B photocell behavior)
    opto_fast = opto_rel_fast * opto_fast + (1 - opto_rel_fast) * target_gr_db;
    opto_slow = opto_rel_slow * opto_slow + (1 - opto_rel_slow) * target_gr_db;
    opto_gr = max(opto_fast, opto_slow);
  );

  // Apply gain reduction
  gr_lin = 10 ^ (-opto_gr / 20);
  out_l *= gr_lin;
  out_r *= gr_lin;

  // Makeup gain
  comp_gain = 10 ^ (slider72 / 20);
  out_l *= comp_gain;
  out_r *= comp_gain;

  // Store GR for meter display
  comp_gr_display = opto_gr;
) : (
  comp_gr_display = 0;
);

// ---- OUTPUT BUS: DC Blocker ----
sat_drive > 0 || comp_amount > 0 ? (
  dc_yl = out_l - dc_xl + dc_r * dc_yl; dc_xl = out_l; out_l = dc_yl;
  dc_yr = out_r - dc_xr + dc_r * dc_yr; dc_xr = out_r; out_r = dc_yr;
);

spl0 = out_l * master_vol;
spl1 = out_r * master_vol;

// ============================================================
// @GFX — User Interface
// ============================================================
@gfx 750 580

// ---- Bounds-check UI state ----
ui_selected_pad = max(0, min(NUM_PADS - 1, ui_selected_pad | 0));

// ---- Background ----
gfx_r = COL_BG_R; gfx_g = COL_BG_G; gfx_b = COL_BG_B;
gfx_rect(0, 0, gfx_w, gfx_h);

// ---- Layout constants ----
margin = 10;
pad_area_y = 20;
pad_area_h = 180;
seq_area_y = pad_area_y + pad_area_h + 20;
seq_area_h = 180;
mixer_y = seq_area_y + seq_area_h + 20;

// ============================================
// SECTION 1: PAD GRID (4x4)
// ============================================
pad_size = min((gfx_w - margin * 5) / 4, (pad_area_h - margin * 5) / 4);
pad_grid_w = pad_size * 4 + margin * 3;
pad_grid_x = (gfx_w - pad_grid_w) / 2;

gfx_setfont(1, "Arial", 12);

gfx_p = 0;
loop(NUM_PADS,
  row = (gfx_p / 4) | 0;
  col = gfx_p % 4;

  px = pad_grid_x + col * (pad_size + margin);
  py = pad_area_y + row * (pad_size + margin);

  // Pad color: lit up if currently playing
  PAD_PLAYING[gfx_p] ? (
    gfx_r = COL_HIT_R; gfx_g = COL_HIT_G; gfx_b = COL_HIT_B;
  ) : (
    gfx_p == ui_selected_pad ? (
      gfx_r = 0.25; gfx_g = 0.27; gfx_b = 0.32;
    ) : (
      gfx_r = COL_PAD_R; gfx_g = COL_PAD_G; gfx_b = COL_PAD_B;
    );
  );
  gfx_rect(px, py, pad_size, pad_size);

  // Pad label
  gfx_r = COL_TXT_R; gfx_g = COL_TXT_G; gfx_b = COL_TXT_B;
  gfx_x = px + 4; gfx_y = py + 4;
  gfx_drawnumber(gfx_p + 1, 0);

  // Left-click — select pad + trigger (debounced: only on mouse-down edge)
  mouse_cap & 1 && !(last_mouse_cap & 1) ? (
    mouse_x >= px && mouse_x < px + pad_size &&
    mouse_y >= py && mouse_y < py + pad_size ? (
      ui_selected_pad = gfx_p;
      trigger_pad(gfx_p, 100);
      // Record pad click to sequencer when REC is armed
      slider6 == 1 && seq_mode && transport_playing ? (
        set_seq_step(slider3, seq_step, gfx_p, 100);
      );
    );
  );

  gfx_p += 1;
);

// ============================================
// SECTION 2: STEP SEQUENCER (for selected pad)
// ============================================
step_w = (gfx_w - margin * 2 - margin * 15) / 16;
step_h = 30;
seq_grid_x = margin;
seq_grid_y = seq_area_y;

// Label with time signature
gfx_r = COL_TXT_R; gfx_g = COL_TXT_G; gfx_b = COL_TXT_B;
gfx_x = margin; gfx_y = seq_grid_y - 16;
gfx_drawstr("STEPS — Pad ");
gfx_drawnumber(ui_selected_pad + 1, 0);
gfx_drawstr("  [");
gfx_drawnumber(ts_num, 0);
gfx_drawstr("/");
gfx_drawnumber(ts_denom, 0);
gfx_drawstr("]");

// -- Pattern select buttons (1-8, right-aligned in header row) --
gfx_pat_btn_w = 26;
gfx_pat_btn_h = 16;
gfx_pat_btn_gap = 4;
gfx_pat_row_w = NUM_PATTERNS * gfx_pat_btn_w + (NUM_PATTERNS - 1) * gfx_pat_btn_gap;
gfx_pat_x0 = gfx_w - margin - gfx_pat_row_w;
gfx_pat_y = seq_grid_y - 18;
gfx_pb = 0;
loop(NUM_PATTERNS,
  gfx_pbx = gfx_pat_x0 + gfx_pb * (gfx_pat_btn_w + gfx_pat_btn_gap);
  gfx_pb == slider3 ? (
    // Active pattern — highlighted
    gfx_r = COL_STEP_R; gfx_g = COL_STEP_G; gfx_b = COL_STEP_B;
  ) : (
    // Inactive pattern — dim
    gfx_r = 0.18; gfx_g = 0.18; gfx_b = 0.22;
  );
  gfx_rect(gfx_pbx, gfx_pat_y, gfx_pat_btn_w, gfx_pat_btn_h);
  gfx_r = COL_TXT_R; gfx_g = COL_TXT_G; gfx_b = COL_TXT_B;
  gfx_x = gfx_pbx + 9; gfx_y = gfx_pat_y + 2;
  gfx_drawnumber(gfx_pb + 1, 0);
  // Click handler
  mouse_cap & 1 && !(last_mouse_cap & 1) ? (
    mouse_x >= gfx_pbx && mouse_x < gfx_pbx + gfx_pat_btn_w &&
    mouse_y >= gfx_pat_y && mouse_y < gfx_pat_y + gfx_pat_btn_h ? (
      slider3 = gfx_pb;
      slider_automate(slider3);
    );
  );
  gfx_pb += 1;
);

gfx_cur_pattern = slider3;

s = 0;
loop(NUM_STEPS,
  sx = seq_grid_x + s * (step_w + margin / 4);
  sy = seq_grid_y;

  gfx_vel = get_seq_step(gfx_cur_pattern, s, ui_selected_pad);

  // Step color — dim steps beyond the time signature
  s < steps_per_measure ? (
    gfx_vel > 0 ? (
      // Active step
      gfx_r = COL_STEP_R; gfx_g = COL_STEP_G; gfx_b = COL_STEP_B;
      brightness = gfx_vel / 127;
      gfx_r *= brightness;
      gfx_g *= brightness;
      gfx_b *= brightness;
    ) : (
      // Inactive step
      gfx_r = 0.12; gfx_g = 0.12; gfx_b = 0.15;
    );
  ) : (
    // Beyond time signature — dimmed out
    gfx_r = 0.06; gfx_g = 0.06; gfx_b = 0.08;
  );

  gfx_rect(sx, sy, step_w, step_h);

  // Timeline position — white border around current step
  s == seq_step ? (
    gfx_r = COL_HEAD_R; gfx_g = COL_HEAD_G; gfx_b = COL_HEAD_B;
    gfx_rect(sx, sy, step_w, 2);
    gfx_rect(sx, sy + step_h - 2, step_w, 2);
    gfx_rect(sx, sy, 2, step_h);
    gfx_rect(sx + step_w - 2, sy, 2, step_h);
  );

  // Beat markers (every 4 steps)
  s % 4 == 0 ? (
    gfx_r = 0.4; gfx_g = 0.4; gfx_b = 0.4;
    gfx_rect(sx, sy + step_h + 2, step_w, 2);
  );

  // Click to toggle step (only active steps within time sig)
  mouse_cap & 1 && s < steps_per_measure ? (
    mouse_x >= sx && mouse_x < sx + step_w &&
    mouse_y >= sy && mouse_y < sy + step_h ? (
      !last_mouse_cap ? (
        toggle_seq_step(gfx_cur_pattern, s, ui_selected_pad);
      );
    );
  );

  // REC overlay on current step
  s == seq_step && slider6 == 1 && transport_playing && seq_mode ? (
    gfx_r = 0.9; gfx_g = 0.15; gfx_b = 0.1; gfx_a = 0.4;
    gfx_rect(sx + 2, sy + 2, step_w - 4, step_h - 4);
    gfx_a = 1.0;
  );

  s += 1;
);

// ============================================
// FILL BUTTONS + REC
// ============================================
gfx_fill_btn_y = seq_grid_y + step_h + 10;
gfx_fill_btn_h = 22;
gfx_fill_btn_w = 50;
gfx_fill_btn_gap = 8;

// -- CLR button --
gfx_fbx = margin;
gfx_r = 0.3; gfx_g = 0.15; gfx_b = 0.15;
gfx_rect(gfx_fbx, gfx_fill_btn_y, gfx_fill_btn_w, gfx_fill_btn_h);
gfx_r = COL_TXT_R; gfx_g = COL_TXT_G; gfx_b = COL_TXT_B;
gfx_x = gfx_fbx + 12; gfx_y = gfx_fill_btn_y + 4;
gfx_drawstr("CLR");
mouse_cap & 1 && !last_mouse_cap ? (
  mouse_x >= gfx_fbx && mouse_x < gfx_fbx + gfx_fill_btn_w &&
  mouse_y >= gfx_fill_btn_y && mouse_y < gfx_fill_btn_y + gfx_fill_btn_h ? (
    gfx_fs = 0;
    loop(NUM_STEPS,
      set_seq_step(gfx_cur_pattern, gfx_fs, ui_selected_pad, 0);
      gfx_fs += 1;
    );
  );
);

// -- 1 button (quarter notes: 0, 4, 8, 12) --
gfx_fbx += gfx_fill_btn_w + gfx_fill_btn_gap;
gfx_r = 0.15; gfx_g = 0.20; gfx_b = 0.25;
gfx_rect(gfx_fbx, gfx_fill_btn_y, gfx_fill_btn_w, gfx_fill_btn_h);
gfx_r = COL_TXT_R; gfx_g = COL_TXT_G; gfx_b = COL_TXT_B;
gfx_x = gfx_fbx + 20; gfx_y = gfx_fill_btn_y + 4;
gfx_drawstr("1");
mouse_cap & 1 && !last_mouse_cap ? (
  mouse_x >= gfx_fbx && mouse_x < gfx_fbx + gfx_fill_btn_w &&
  mouse_y >= gfx_fill_btn_y && mouse_y < gfx_fill_btn_y + gfx_fill_btn_h ? (
    gfx_fs = 0;
    loop(NUM_STEPS,
      gfx_fs % 4 == 0 ? set_seq_step(gfx_cur_pattern, gfx_fs, ui_selected_pad, 100)
                       : set_seq_step(gfx_cur_pattern, gfx_fs, ui_selected_pad, 0);
      gfx_fs += 1;
    );
  );
);

// -- 1/2 button (8th notes: every 2nd step) --
gfx_fbx += gfx_fill_btn_w + gfx_fill_btn_gap;
gfx_r = 0.15; gfx_g = 0.20; gfx_b = 0.25;
gfx_rect(gfx_fbx, gfx_fill_btn_y, gfx_fill_btn_w, gfx_fill_btn_h);
gfx_r = COL_TXT_R; gfx_g = COL_TXT_G; gfx_b = COL_TXT_B;
gfx_x = gfx_fbx + 14; gfx_y = gfx_fill_btn_y + 4;
gfx_drawstr("1/2");
mouse_cap & 1 && !last_mouse_cap ? (
  mouse_x >= gfx_fbx && mouse_x < gfx_fbx + gfx_fill_btn_w &&
  mouse_y >= gfx_fill_btn_y && mouse_y < gfx_fill_btn_y + gfx_fill_btn_h ? (
    gfx_fs = 0;
    loop(NUM_STEPS,
      gfx_fs % 2 == 0 ? set_seq_step(gfx_cur_pattern, gfx_fs, ui_selected_pad, 100)
                       : set_seq_step(gfx_cur_pattern, gfx_fs, ui_selected_pad, 0);
      gfx_fs += 1;
    );
  );
);

// -- 1/4 button (16th notes: all steps) --
gfx_fbx += gfx_fill_btn_w + gfx_fill_btn_gap;
gfx_r = 0.15; gfx_g = 0.20; gfx_b = 0.25;
gfx_rect(gfx_fbx, gfx_fill_btn_y, gfx_fill_btn_w, gfx_fill_btn_h);
gfx_r = COL_TXT_R; gfx_g = COL_TXT_G; gfx_b = COL_TXT_B;
gfx_x = gfx_fbx + 14; gfx_y = gfx_fill_btn_y + 4;
gfx_drawstr("1/4");
mouse_cap & 1 && !last_mouse_cap ? (
  mouse_x >= gfx_fbx && mouse_x < gfx_fbx + gfx_fill_btn_w &&
  mouse_y >= gfx_fill_btn_y && mouse_y < gfx_fill_btn_y + gfx_fill_btn_h ? (
    gfx_fs = 0;
    loop(NUM_STEPS,
      set_seq_step(gfx_cur_pattern, gfx_fs, ui_selected_pad, 100);
      gfx_fs += 1;
    );
  );
);

// -- Nudge < button (shift pattern left, wraps) --
gfx_fbx += gfx_fill_btn_w + gfx_fill_btn_gap + 10;
gfx_nudge_w = 30;
gfx_r = 0.18; gfx_g = 0.15; gfx_b = 0.25;
gfx_rect(gfx_fbx, gfx_fill_btn_y, gfx_nudge_w, gfx_fill_btn_h);
gfx_r = COL_TXT_R; gfx_g = COL_TXT_G; gfx_b = COL_TXT_B;
gfx_x = gfx_fbx + 10; gfx_y = gfx_fill_btn_y + 4;
gfx_drawstr("<");
mouse_cap & 1 && !last_mouse_cap ? (
  mouse_x >= gfx_fbx && mouse_x < gfx_fbx + gfx_nudge_w &&
  mouse_y >= gfx_fill_btn_y && mouse_y < gfx_fill_btn_y + gfx_fill_btn_h ? (
    // Save step 0, shift everything left, wrap step 0 to end
    gfx_nudge_save = get_seq_step(gfx_cur_pattern, 0, ui_selected_pad);
    gfx_fs = 0;
    loop(NUM_STEPS - 1,
      set_seq_step(gfx_cur_pattern, gfx_fs, ui_selected_pad,
        get_seq_step(gfx_cur_pattern, gfx_fs + 1, ui_selected_pad));
      gfx_fs += 1;
    );
    set_seq_step(gfx_cur_pattern, NUM_STEPS - 1, ui_selected_pad, gfx_nudge_save);
  );
);

// -- Nudge > button (shift pattern right, wraps) --
gfx_fbx += gfx_nudge_w + 4;
gfx_r = 0.18; gfx_g = 0.15; gfx_b = 0.25;
gfx_rect(gfx_fbx, gfx_fill_btn_y, gfx_nudge_w, gfx_fill_btn_h);
gfx_r = COL_TXT_R; gfx_g = COL_TXT_G; gfx_b = COL_TXT_B;
gfx_x = gfx_fbx + 10; gfx_y = gfx_fill_btn_y + 4;
gfx_drawstr(">");
mouse_cap & 1 && !last_mouse_cap ? (
  mouse_x >= gfx_fbx && mouse_x < gfx_fbx + gfx_nudge_w &&
  mouse_y >= gfx_fill_btn_y && mouse_y < gfx_fill_btn_y + gfx_fill_btn_h ? (
    // Save last step, shift everything right, wrap last to step 0
    gfx_nudge_save = get_seq_step(gfx_cur_pattern, NUM_STEPS - 1, ui_selected_pad);
    gfx_fs = NUM_STEPS - 1;
    loop(NUM_STEPS - 1,
      set_seq_step(gfx_cur_pattern, gfx_fs, ui_selected_pad,
        get_seq_step(gfx_cur_pattern, gfx_fs - 1, ui_selected_pad));
      gfx_fs -= 1;
    );
    set_seq_step(gfx_cur_pattern, 0, ui_selected_pad, gfx_nudge_save);
  );
);

// -- REC button (right-aligned) --
gfx_rec_w = 50;
gfx_rec_x = gfx_w - margin - gfx_rec_w;
slider6 == 1 ? (
  gfx_rec_blink = (gfx_rec_blink + 1) % 30;
  gfx_rec_blink < 20 ? (
    gfx_r = 0.9; gfx_g = 0.1; gfx_b = 0.1;
  ) : (
    gfx_r = 0.5; gfx_g = 0.05; gfx_b = 0.05;
  );
) : (
  gfx_r = 0.2; gfx_g = 0.08; gfx_b = 0.08;
  gfx_rec_blink = 0;
);
gfx_rect(gfx_rec_x, gfx_fill_btn_y, gfx_rec_w, gfx_fill_btn_h);
gfx_r = 1.0; gfx_g = 1.0; gfx_b = 1.0;
gfx_x = gfx_rec_x + 10; gfx_y = gfx_fill_btn_y + 4;
gfx_drawstr("REC");
mouse_cap & 1 && !last_mouse_cap ? (
  mouse_x >= gfx_rec_x && mouse_x < gfx_rec_x + gfx_rec_w &&
  mouse_y >= gfx_fill_btn_y && mouse_y < gfx_fill_btn_y + gfx_fill_btn_h ? (
    slider6 = 1 - slider6;
    slider_automate(slider6);
  );
);

// ============================================
// SECTION 3: SELECTED PAD CONTROLS (Vol / Pan / Pitch)
// ============================================
ctrl_h = 20;
ctrl_bar_w = gfx_w - margin * 2 - 120;
ctrl_x = margin + 120;
ctrl_y = mixer_y;
sp = ui_selected_pad;

// Header: pad number
gfx_r = COL_HIT_R; gfx_g = COL_HIT_G; gfx_b = COL_HIT_B;
gfx_x = margin; gfx_y = mixer_y - 18;
gfx_drawstr("PAD ");
gfx_drawnumber(sp + 1, 0);
// Show if sample is loaded
PAD_NCH[sp] > 0 ? (
  gfx_r = COL_STEP_R; gfx_g = COL_STEP_G; gfx_b = COL_STEP_B;
  gfx_drawstr("  loaded");
) : (
  gfx_r = 0.5; gfx_g = 0.2; gfx_b = 0.2;
  gfx_drawstr("  no sample");
);

// -- POOL button (swap sample on selected pad) --
pool_count > 0 ? (
  gfx_pool_btn_x = gfx_w - margin - 60;
  gfx_pool_btn_w = 60;
  gfx_pool_btn_h = 16;
  gfx_pool_btn_y = mixer_y - 18;
  gfx_r = 0.15; gfx_g = 0.20; gfx_b = 0.30;
  gfx_rect(gfx_pool_btn_x, gfx_pool_btn_y, gfx_pool_btn_w, gfx_pool_btn_h);
  gfx_r = COL_TXT_R; gfx_g = COL_TXT_G; gfx_b = COL_TXT_B;
  gfx_x = gfx_pool_btn_x + 8; gfx_y = gfx_pool_btn_y + 2;
  gfx_drawstr("POOL");
  mouse_cap & 1 && !(last_mouse_cap & 1) ? (
    mouse_x >= gfx_pool_btn_x && mouse_x < gfx_pool_btn_x + gfx_pool_btn_w &&
    mouse_y >= gfx_pool_btn_y && mouse_y < gfx_pool_btn_y + gfx_pool_btn_h ? (
      // Build menu from pool manifest
      #pool_menu = "";
      gfx_pm = 0;
      loop(pool_count,
        gfx_pm > 0 ? strcat(#pool_menu, "|");
        strcpy(#pool_item, 100 + gfx_pm);
        // Strip .wav extension for display
        gfx_ext_pos = strlen(#pool_item) - 4;
        gfx_ext_pos > 0 ? str_setlen(#pool_item, gfx_ext_pos);
        strcat(#pool_menu, #pool_item);
        gfx_pm += 1;
      );
      gfx_x = mouse_x;
      gfx_y = mouse_y;
      gfx_pool_choice = gfx_showmenu(#pool_menu);
      gfx_pool_choice > 0 ? (
        // Signal @block to load the sample
        pool_load_idx = gfx_pool_choice - 1;
        pool_load_pad = ui_selected_pad;
      );
    );
  );
);

// ---- Volume bar ----
cur_vol = slider(10 + sp);
gfx_r = COL_TXT_R; gfx_g = COL_TXT_G; gfx_b = COL_TXT_B;
gfx_x = margin; gfx_y = ctrl_y + 2;
gfx_drawstr("Vol  ");
gfx_drawnumber(floor(cur_vol * 100 + 0.5), 0);
gfx_drawstr("%");

// Bar background
gfx_r = 0.12; gfx_g = 0.12; gfx_b = 0.15;
gfx_rect(ctrl_x, ctrl_y, ctrl_bar_w, ctrl_h);
// Bar fill
gfx_r = COL_STEP_R; gfx_g = COL_STEP_G; gfx_b = COL_STEP_B;
gfx_rect(ctrl_x, ctrl_y, ctrl_bar_w * cur_vol, ctrl_h);

// Drag to adjust volume
mouse_cap & 1 ? (
  mouse_x >= ctrl_x && mouse_x <= ctrl_x + ctrl_bar_w &&
  mouse_y >= ctrl_y && mouse_y < ctrl_y + ctrl_h ? (
    new_vol = max(0, min(1, (mouse_x - ctrl_x) / ctrl_bar_w));
    slider(10 + sp) = new_vol;
  );
);

// ---- Pan bar ----
ctrl_y2 = ctrl_y + ctrl_h + 6;
cur_pan = slider(30 + sp);
gfx_r = COL_TXT_R; gfx_g = COL_TXT_G; gfx_b = COL_TXT_B;
gfx_x = margin; gfx_y = ctrl_y2 + 2;
gfx_drawstr("Pan  ");
cur_pan < -0.01 ? (
  gfx_drawstr("L");
  gfx_drawnumber(floor(abs(cur_pan) * 100 + 0.5), 0);
) : cur_pan > 0.01 ? (
  gfx_drawstr("R");
  gfx_drawnumber(floor(cur_pan * 100 + 0.5), 0);
) : (
  gfx_drawstr("C");
);

// Bar background
gfx_r = 0.12; gfx_g = 0.12; gfx_b = 0.15;
gfx_rect(ctrl_x, ctrl_y2, ctrl_bar_w, ctrl_h);
// Center line
gfx_r = 0.25; gfx_g = 0.25; gfx_b = 0.3;
gfx_rect(ctrl_x + ctrl_bar_w / 2 - 1, ctrl_y2, 2, ctrl_h);
// Pan indicator
pan_norm = (cur_pan + 1) / 2;  // 0 to 1
gfx_r = COL_HIT_R; gfx_g = COL_HIT_G; gfx_b = COL_HIT_B;
pan_px = ctrl_x + pan_norm * ctrl_bar_w;
gfx_rect(pan_px - 4, ctrl_y2, 8, ctrl_h);

// Drag to adjust pan
mouse_cap & 1 ? (
  mouse_x >= ctrl_x && mouse_x <= ctrl_x + ctrl_bar_w &&
  mouse_y >= ctrl_y2 && mouse_y < ctrl_y2 + ctrl_h ? (
    new_pan = max(-1, min(1, ((mouse_x - ctrl_x) / ctrl_bar_w) * 2 - 1));
    slider(30 + sp) = new_pan;
  );
);

// ---- Pitch bar ----
ctrl_y3 = ctrl_y2 + ctrl_h + 6;
cur_pitch = slider(50 + sp);
gfx_r = COL_TXT_R; gfx_g = COL_TXT_G; gfx_b = COL_TXT_B;
gfx_x = margin; gfx_y = ctrl_y3 + 2;
gfx_drawstr("Pitch ");
cur_pitch >= 0 ? gfx_drawstr("+");
gfx_drawnumber(floor(cur_pitch + 0.5), 0);
gfx_drawstr("st");

// Bar background
gfx_r = 0.12; gfx_g = 0.12; gfx_b = 0.15;
gfx_rect(ctrl_x, ctrl_y3, ctrl_bar_w, ctrl_h);
// Center line (0 semitones)
gfx_r = 0.25; gfx_g = 0.25; gfx_b = 0.3;
gfx_rect(ctrl_x + ctrl_bar_w / 2 - 1, ctrl_y3, 2, ctrl_h);
// Pitch indicator
pitch_norm = (cur_pitch + 24) / 48;  // -24..+24 → 0..1
gfx_r = 0.5; gfx_g = 0.6; gfx_b = 1.0;
pitch_px = ctrl_x + max(0, min(1, pitch_norm)) * ctrl_bar_w;
gfx_rect(pitch_px - 4, ctrl_y3, 8, ctrl_h);

// Drag to adjust pitch
mouse_cap & 1 ? (
  mouse_x >= ctrl_x && mouse_x <= ctrl_x + ctrl_bar_w &&
  mouse_y >= ctrl_y3 && mouse_y < ctrl_y3 + ctrl_h ? (
    new_pitch = max(-24, min(24, ((mouse_x - ctrl_x) / ctrl_bar_w) * 48 - 24));
    // Snap to semitones
    new_pitch = floor(new_pitch + 0.5);
    slider(50 + sp) = new_pitch;
  );
);

// ============================================
// SECTION 3B: OUTPUT BUS (Sat / Comp / Gain)
// ============================================
ctrl_y4 = ctrl_y3 + ctrl_h + 16;

// -- Section label --
gfx_r = 0.7; gfx_g = 0.5; gfx_b = 0.3;
gfx_x = margin; gfx_y = ctrl_y4 - 14;
gfx_drawstr("OUTPUT BUS");

// ---- Saturation Drive bar ----
cur_sat = slider70;
gfx_r = COL_TXT_R; gfx_g = COL_TXT_G; gfx_b = COL_TXT_B;
gfx_x = margin; gfx_y = ctrl_y4 + 2;
gfx_drawstr("Sat  ");
gfx_drawnumber(floor(cur_sat + 0.5), 0);
gfx_drawstr("%");

// Bar background
gfx_r = 0.12; gfx_g = 0.12; gfx_b = 0.15;
gfx_rect(ctrl_x, ctrl_y4, ctrl_bar_w, ctrl_h);
// Bar fill (warm orange)
cur_sat > 0 ? (
  gfx_r = 0.8; gfx_g = 0.5; gfx_b = 0.2;
  gfx_rect(ctrl_x, ctrl_y4, ctrl_bar_w * (cur_sat / 100), ctrl_h);
);

// Drag to adjust saturation
mouse_cap & 1 ? (
  mouse_x >= ctrl_x && mouse_x <= ctrl_x + ctrl_bar_w &&
  mouse_y >= ctrl_y4 && mouse_y < ctrl_y4 + ctrl_h ? (
    slider70 = max(0, min(100, (mouse_x - ctrl_x) / ctrl_bar_w * 100));
  );
);

// ---- Comp Peak Reduction bar ----
ctrl_y5 = ctrl_y4 + ctrl_h + 6;
cur_comp = slider71;
gfx_r = COL_TXT_R; gfx_g = COL_TXT_G; gfx_b = COL_TXT_B;
gfx_x = margin; gfx_y = ctrl_y5 + 2;
gfx_drawstr("Comp ");
gfx_drawnumber(floor(cur_comp + 0.5), 0);
gfx_drawstr("%");

// Bar background
gfx_r = 0.12; gfx_g = 0.12; gfx_b = 0.15;
gfx_rect(ctrl_x, ctrl_y5, ctrl_bar_w, ctrl_h);
// Bar fill (orange-red)
cur_comp > 0 ? (
  gfx_r = 0.9; gfx_g = 0.4; gfx_b = 0.15;
  gfx_rect(ctrl_x, ctrl_y5, ctrl_bar_w * (cur_comp / 100), ctrl_h);
);

// Drag to adjust comp
mouse_cap & 1 ? (
  mouse_x >= ctrl_x && mouse_x <= ctrl_x + ctrl_bar_w &&
  mouse_y >= ctrl_y5 && mouse_y < ctrl_y5 + ctrl_h ? (
    slider71 = max(0, min(100, (mouse_x - ctrl_x) / ctrl_bar_w * 100));
  );
);

// ---- GR Meter ----
ctrl_y6 = ctrl_y5 + ctrl_h + 4;
gfx_r = COL_TXT_R; gfx_g = COL_TXT_G; gfx_b = COL_TXT_B;
gfx_x = margin; gfx_y = ctrl_y6 + 1;
gfx_drawstr("GR   -");
gfx_drawnumber(comp_gr_display, 1);
gfx_drawstr("dB");

// GR meter background
gfx_r = 0.08; gfx_g = 0.08; gfx_b = 0.10;
gfx_rect(ctrl_x, ctrl_y6, ctrl_bar_w, 12);
// GR meter fill (red, capped at 30dB for visual range)
comp_gr_display > 0.1 ? (
  gfx_r = 0.9; gfx_g = 0.15; gfx_b = 0.1;
  gr_fill_w = min(comp_gr_display / 30, 1) * ctrl_bar_w;
  gfx_rect(ctrl_x, ctrl_y6, gr_fill_w, 12);
);

// ---- Comp Gain bar ----
ctrl_y7 = ctrl_y6 + 18;
cur_gain = slider72;
gfx_r = COL_TXT_R; gfx_g = COL_TXT_G; gfx_b = COL_TXT_B;
gfx_x = margin; gfx_y = ctrl_y7 + 2;
gfx_drawstr("Gain ");
cur_gain >= 0 ? gfx_drawstr("+");
gfx_drawnumber(cur_gain, 1);
gfx_drawstr("dB");

// Bar background
gfx_r = 0.12; gfx_g = 0.12; gfx_b = 0.15;
gfx_rect(ctrl_x, ctrl_y7, ctrl_bar_w, ctrl_h);
// Center line (0 dB)
gfx_r = 0.25; gfx_g = 0.25; gfx_b = 0.3;
gfx_rect(ctrl_x + ctrl_bar_w / 2 - 1, ctrl_y7, 2, ctrl_h);
// Gain indicator
gain_norm = (cur_gain + 12) / 24;  // -12..+12 → 0..1
gfx_r = 0.4; gfx_g = 0.6; gfx_b = 1.0;
gain_px = ctrl_x + max(0, min(1, gain_norm)) * ctrl_bar_w;
gfx_rect(gain_px - 4, ctrl_y7, 8, ctrl_h);

// Drag to adjust gain
mouse_cap & 1 ? (
  mouse_x >= ctrl_x && mouse_x <= ctrl_x + ctrl_bar_w &&
  mouse_y >= ctrl_y7 && mouse_y < ctrl_y7 + ctrl_h ? (
    new_gain = max(-12, min(12, ((mouse_x - ctrl_x) / ctrl_bar_w) * 24 - 12));
    // Snap to 0.5 dB
    new_gain = floor(new_gain * 2 + 0.5) / 2;
    slider72 = new_gain;
  );
);

// ---- Store mouse state for debounce ----
last_mouse_cap = mouse_cap;

// ============================================
// SECTION 4: STATUS BAR
// ============================================
gfx_r = COL_TXT_R; gfx_g = COL_TXT_G; gfx_b = COL_TXT_B;
gfx_x = margin; gfx_y = gfx_h - 18;
transport_playing ? gfx_drawstr("▶ ") : gfx_drawstr("■ ");
seq_mode ? gfx_drawstr("SEQ  ") : gfx_drawstr("FREE  ");
gfx_drawstr("BPM: ");
bpm_display = tempo > 0 ? tempo : slider1;
gfx_drawnumber(bpm_display, 1);
gfx_drawstr("  Bar: ");
gfx_drawnumber(measure_num + 1, 0);
gfx_drawstr("  Step: ");
gfx_drawnumber(seq_step + 1, 0);
gfx_drawstr("/");
gfx_drawnumber(steps_per_measure, 0);
gfx_drawstr("  Pat: ");
gfx_drawnumber(slider3 + 1, 0);
gfx_drawstr("  Kit: ");
gfx_drawnumber(kit_loaded, 0);
gfx_drawstr("/16");
slider6 == 1 ? (
  gfx_r = 0.9; gfx_g = 0.1; gfx_b = 0.1;
  gfx_drawstr("  REC");
);

// --- NOTICE BUTTON ---
notice_btn_x = gfx_w - 60;
notice_btn_y = gfx_h - 18;
gfx_r = 0.6; gfx_g = 0.5; gfx_b = 0.3;
gfx_rect(notice_btn_x, notice_btn_y, 55, 15);
gfx_r = 0; gfx_g = 0; gfx_b = 0;
gfx_x = notice_btn_x + 4; gfx_y = notice_btn_y + 2;
gfx_drawstr("NOTICE");
(mouse_cap & 1) && mouse_x >= notice_btn_x && mouse_x <= notice_btn_x + 55 && mouse_y >= notice_btn_y && mouse_y <= notice_btn_y + 15 && !notice_clicked ? (
  notice_show = !notice_show;
  notice_clicked = 1;
);
!(mouse_cap & 1) ? notice_clicked = 0;
notice_show ? (
  gfx_r = 0.05; gfx_g = 0.05; gfx_b = 0.05; gfx_a = 0.95;
  gfx_rect(0, 0, gfx_w, gfx_h);
  gfx_a = 1;
  gfx_r = 0.9; gfx_g = 0.8; gfx_b = 0.5;
  gfx_x = 15; gfx_y = 10;
  gfx_drawstr("NOTICE: THEY ARE TRYING TO STEAL YOUR COMPUTER");
  gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.7;
  gfx_x = 15; gfx_y = 35;
  gfx_drawstr("The algorithms in our favorite software are decades old.");
  gfx_x = 15; gfx_y = 50;
  gfx_drawstr("A mathematical model is a truth about the world,");
  gfx_x = 15; gfx_y = 65;
  gfx_drawstr("not a copyrightable product. Our digital products are all");
  gfx_x = 15; gfx_y = 80;
  gfx_drawstr("Turing machines replicating our favorite physical machines,");
  gfx_x = 15; gfx_y = 95;
  gfx_drawstr("with math.");
  gfx_x = 15; gfx_y = 120;
  gfx_drawstr("You do not have to stay a slave to subscription software.");
  gfx_x = 15; gfx_y = 135;
  gfx_drawstr("Install Linux. Build your own tools. Believe in yourself.");
  gfx_r = 0.5; gfx_g = 0.7; gfx_b = 1.0;
  gfx_x = 15; gfx_y = 165;
  gfx_drawstr("github.com/bleavelle");
  // Redraw NOTICE button on top of overlay so it's clickable
  gfx_r = 0.6; gfx_g = 0.5; gfx_b = 0.3;
  gfx_rect(notice_btn_x, notice_btn_y, 55, 15);
  gfx_r = 0; gfx_g = 0; gfx_b = 0;
  gfx_x = notice_btn_x + 4; gfx_y = notice_btn_y + 2;
  gfx_drawstr("NOTICE");
);

// ============================================================
// @SERIALIZE — Save/restore sequencer patterns
// ============================================================
@serialize

serial_version = 2;
file_var(0, serial_version);

// Save/restore all pattern data
i = 0;
loop(NUM_PATTERNS * NUM_STEPS * NUM_PADS,
  file_var(0, SEQ_BASE[i]);
  i += 1;
);

// v2: save UI state
serial_version >= 2 ? (
  file_var(0, ui_selected_pad);
);
