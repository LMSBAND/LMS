desc:Matchering Realtime Master (FIR Convolution)
//tags: mastering EQ limiter matchering convolution
//author: LMS + Claude

import lms_core.jsfx-inc

filename:0,matchering_fir_data.txt

options:gmem=DrumBanger

slider1:-2.70<-20,20,0.1>-Input Gain (dB)
slider2:100<0,100,1>-Dry/Wet (%)
slider3:1<0,1,1{Off,On}>-Limiter
slider4:-0.01<-6,0,0.01>-Limiter Threshold (dB)
slider5:0<-6,6,0.1>-Low Tweak (dB)
slider6:0<-6,6,0.1>-Mid Tweak (dB)
slider7:0<-6,6,0.1>-High Tweak (dB)
slider8:500<100,2000,1>-Mid Freq (Hz)
slider9:0<0,1,1{Off,On}>-42069 Compressor
slider10:-12<-40,0,0.5>-42069 Threshold (dB)
slider11:4<0,3,1{4:1,8:1,12:1,20:1}>-42069 Ratio
slider12:0.2<0.02,0.8,0.01>-42069 Attack (ms)
slider13:250<50,1100,10>-42069 Release (ms)
slider14:100<0,100,1>-42069 Mix (%)

@init
  fir_len = 4096;
  fft_size = 8192;
  chunk_size = 4096;

  // Memory pointers - all FFT buffers within first 65536 block
  mid_fir_fft = 0;           // 0..8191
  side_fir_fft = 8192;       // 8192..16383
  // Double-buffer input
  input_buf_l0 = 16384;      // 16384..20479
  input_buf_r0 = 20480;      // 20480..24575
  input_buf_l1 = 24576;      // 24576..28671
  input_buf_r1 = 28672;      // 28672..32767
  work_buf_mid = 32768;      // 32768..40959
  work_buf_side = 40960;     // 40960..49151
  overlap_mid = 49152;       // 49152..53247
  overlap_side = 53248;      // 53248..57343
  output_buf_l = 57344;      // 57344..61439
  output_buf_r = 61440;      // 61440..65535

  buf_pos = 0;
  output_ready = 0;
  cur_input_l = input_buf_l0;
  cur_input_r = input_buf_r0;

  // Initialize slider-derived values (in case @slider hasn't run yet)
  master_gain = lms_db2lin(-2.70);
  dry_wet = 1.0;
  limiter_on = 1;
  limiter_thresh = lms_db2lin(-0.01);

  // Initialize biquad instances for post-tweak EQ
  ls.lms_bq_init();   // low shelf
  mp.lms_bq_init();   // mid peak
  hs.lms_bq_init();   // high shelf

  // Initialize 42069 compressor
  comp42.lms_comp_init();

  // --- Load FIR coefficients from data file ---
  // Clear both FFT buffers
  i = 0;
  loop(fft_size,
    mid_fir_fft[i] = 0;
    side_fir_fft[i] = 0;
    i += 1;
  );

  // Read mid FIR (first fir_len values) and side FIR (next fir_len values)
  fh = file_open(0);
  fh >= 0 ? (
    file_mem(fh, mid_fir_fft, fir_len);
    file_mem(fh, side_fir_fft, fir_len);
    file_close(fh);
  );

  // FFT both FIRs in place
  fft_real(mid_fir_fft, fft_size);
  fft_real(side_fir_fft, fft_size);

  // Clear overlap buffers
  i = 0;
  loop(fir_len,
    overlap_mid[i] = 0;
    overlap_side[i] = 0;
    i += 1;
  );

  // Clear output buffers
  i = 0;
  loop(chunk_size,
    output_buf_l[i] = 0;
    output_buf_r[i] = 0;
    i += 1;
  );

notice_show = 0;

  // Report latency to REAPER for PDC
  pdc_delay = chunk_size;
  pdc_bot_ch = 0;
  pdc_top_ch = 2;

  // ============================================================
  // BROADCAST SYSTEM — Instance Registry
  // ============================================================
  BC_BASE = 100000;
  BC_MY_TYPE = 11;           // Matchering
  BC_SLOT_SIZE = 512;
  BC_MAX_INST = 32;
  BC_PARAM_COUNT = 14;
  BC_MY_REGION = BC_BASE + BC_MY_TYPE * 4096;
  BC_STALE_TIMEOUT = 2;

  // Generate unique instance ID (only on first init, preserve across transport stop/start)
  bc_my_id == 0 ? bc_my_id = floor(rand() * 1073741824) + 1;
  bc_my_slot = -1;
  // bc_following preserved by @serialize — do NOT zero here
  bc_follow_slot = -1;
  bc_steal_pending = 0;
  bc_steal_target = 0;
  bc_panel_expanded = 0;
  bc_page = 0;
  bc_steal_mode = 0;
  bc_instance_count = 0;

  BC_STALE_HB = 70000;
  BC_STALE_CT = 70032;
  i = 0;
  loop(BC_MAX_INST,
    BC_STALE_HB[i] = -1;
    BC_STALE_CT[i] = 0;
    i += 1;
  );

  bc_i = 0;
  loop(BC_MAX_INST,
    bc_my_slot < 0 ? (
      sb = BC_MY_REGION + bc_i * BC_SLOT_SIZE;
      sid = gmem[sb + 1];
      (sid == 0 || sid == bc_my_id) ? (
        bc_my_slot = bc_i;
      );
    );
    bc_i += 1;
  );

  bc_my_slot >= 0 ? (
    sb = BC_MY_REGION + bc_my_slot * BC_SLOT_SIZE;
    gmem[sb + 0] = 0;
    gmem[sb + 1] = bc_my_id;
    gmem[sb + 2] = BC_MY_TYPE;
    gmem[sb + 3] = 0;
    gmem[sb + 4] = BC_PARAM_COUNT;
  );

@slider
  master_gain = lms_db2lin(slider1);
  dry_wet = slider2 / 100;
  limiter_on = slider3;
  limiter_thresh = lms_db2lin(slider4);

  // Post-tweak EQ via library biquads
  low_gain = slider5;
  mid_gain = slider6;
  high_gain = slider7;
  mid_freq = slider8;

  ls.lms_bq_set_loshelf(200, low_gain, 0.707);
  hs.lms_bq_set_hishelf(8000, high_gain, 0.707);
  mp.lms_bq_set_peak(mid_freq, mid_gain, 0.7);

  // 42069 compressor
  comp_on = slider9;
  // Ratio: slider11 is 0=4:1, 1=8:1, 2=12:1, 3=20:1
  slider11 == 0 ? comp_ratio = 4;
  slider11 == 1 ? comp_ratio = 8;
  slider11 == 2 ? comp_ratio = 12;
  slider11 == 3 ? comp_ratio = 20;
  comp42.lms_comp_set(slider10, comp_ratio, slider12, slider13);
  comp_mix = slider14 / 100;

// ============================================================
// @BLOCK — Broadcast, heartbeat, stale-check, follow, steal
// ============================================================
@block
// ---- Recalculate from sliders (GFX changes don't trigger @slider) ----
master_gain = lms_db2lin(slider1);
dry_wet = slider2 / 100;
limiter_on = slider3;
limiter_thresh = lms_db2lin(slider4);

// Post-tweak EQ via library biquads
low_gain = slider5;
mid_gain = slider6;
high_gain = slider7;
mid_freq = slider8;

ls.lms_bq_set_loshelf(200, low_gain, 0.707);
hs.lms_bq_set_hishelf(8000, high_gain, 0.707);
mp.lms_bq_set_peak(mid_freq, mid_gain, 0.7);

// 42069 compressor
comp_on = slider9;
slider11 == 0 ? comp_ratio = 4;
slider11 == 1 ? comp_ratio = 8;
slider11 == 2 ? comp_ratio = 12;
slider11 == 3 ? comp_ratio = 20;
comp42.lms_comp_set(slider10, comp_ratio, slider12, slider13);
comp_mix = slider14 / 100;

bc_my_slot >= 0 ? (
  sb = BC_MY_REGION + bc_my_slot * BC_SLOT_SIZE;
  gmem[sb + 1] != bc_my_id ? (
    bc_my_id = floor(rand() * 1073741824) + 1;
    bc_my_slot = -1;
    bc_i = 0;
    loop(BC_MAX_INST,
      bc_my_slot < 0 ? (
        tsb = BC_MY_REGION + bc_i * BC_SLOT_SIZE;
        (gmem[tsb + 1] == 0) ? bc_my_slot = bc_i;
      );
      bc_i += 1;
    );
    bc_my_slot >= 0 ? (
      sb = BC_MY_REGION + bc_my_slot * BC_SLOT_SIZE;
      gmem[sb + 0] = 0;
      gmem[sb + 1] = bc_my_id;
      gmem[sb + 2] = BC_MY_TYPE;
      gmem[sb + 3] = bc_following;
      gmem[sb + 4] = BC_PARAM_COUNT;
    );
  );
);

bc_my_slot >= 0 && bc_following > 0 ? (
  bc_found_leader = 0;
  bc_scan = 0;
  loop(BC_MAX_INST,
    bc_scan != bc_my_slot ? (
      lsb = BC_MY_REGION + bc_scan * BC_SLOT_SIZE;
      gmem[lsb + 1] == bc_following ? (
        bc_found_leader = 1;
        bc_follow_slot = bc_scan;
        lbase = lsb + 8;
        slider1 = gmem[lbase + 0];
        slider2 = gmem[lbase + 1];
        slider3 = gmem[lbase + 2];
        slider4 = gmem[lbase + 3];
        slider5 = gmem[lbase + 4];
        slider6 = gmem[lbase + 5];
        slider7 = gmem[lbase + 6];
        slider8 = gmem[lbase + 7];
        slider9 = gmem[lbase + 8];
        slider10 = gmem[lbase + 9];
        slider11 = gmem[lbase + 10];
        slider12 = gmem[lbase + 11];
        slider13 = gmem[lbase + 12];
        slider14 = gmem[lbase + 13];
        bc_scan = BC_MAX_INST;
      );
    );
    bc_scan += 1;
  );
  !bc_found_leader ? (
    bc_following = 0;
    bc_follow_slot = -1;
  );
);

bc_my_slot >= 0 && bc_steal_pending ? (
  bc_scan = 0;
  loop(BC_MAX_INST,
    lsb = BC_MY_REGION + bc_scan * BC_SLOT_SIZE;
    gmem[lsb + 1] == bc_steal_target ? (
      lbase = lsb + 8;
      slider1 = gmem[lbase + 0];
      slider2 = gmem[lbase + 1];
      slider3 = gmem[lbase + 2];
      slider4 = gmem[lbase + 3];
      slider5 = gmem[lbase + 4];
      slider6 = gmem[lbase + 5];
      slider7 = gmem[lbase + 6];
      slider8 = gmem[lbase + 7];
      slider9 = gmem[lbase + 8];
      slider10 = gmem[lbase + 9];
      slider11 = gmem[lbase + 10];
      slider12 = gmem[lbase + 11];
      slider13 = gmem[lbase + 12];
      slider14 = gmem[lbase + 13];
      bc_scan = BC_MAX_INST;
    );
    bc_scan += 1;
  );
  bc_steal_pending = 0;
  bc_steal_target = 0;
  bc_steal_mode = 0;
);

bc_my_slot >= 0 ? (
  sb = BC_MY_REGION + bc_my_slot * BC_SLOT_SIZE;
  gmem[sb + 0] += 1;
  gmem[sb + 3] = bc_following;
  pbase = sb + 8;
  gmem[pbase + 0] = slider1;
  gmem[pbase + 1] = slider2;
  gmem[pbase + 2] = slider3;
  gmem[pbase + 3] = slider4;
  gmem[pbase + 4] = slider5;
  gmem[pbase + 5] = slider6;
  gmem[pbase + 6] = slider7;
  gmem[pbase + 7] = slider8;
  gmem[pbase + 8] = slider9;
  gmem[pbase + 9] = slider10;
  gmem[pbase + 10] = slider11;
  gmem[pbase + 11] = slider12;
  gmem[pbase + 12] = slider13;
  gmem[pbase + 13] = slider14;
);

bc_instance_count = 0;
bc_scan = 0;
loop(BC_MAX_INST,
  tsb = BC_MY_REGION + bc_scan * BC_SLOT_SIZE;
  tsid = gmem[tsb + 1];
  tsid > 0 ? (
    bc_scan == bc_my_slot ? (
      bc_instance_count += 1;
    ) : (
      tshb = gmem[tsb + 0];
      tshb == BC_STALE_HB[bc_scan] ? (
        BC_STALE_CT[bc_scan] += samplesblock / srate;
        BC_STALE_CT[bc_scan] > BC_STALE_TIMEOUT ? (
          gmem[tsb + 1] = 0;
          BC_STALE_CT[bc_scan] = 0;
        );
      ) : (
        BC_STALE_HB[bc_scan] = tshb;
        BC_STALE_CT[bc_scan] = 0;
        bc_instance_count += 1;
      );
    );
  );
  bc_scan += 1;
);

@sample
  // Store input samples into current input buffer
  cur_input_l[buf_pos] = spl0;
  cur_input_r[buf_pos] = spl1;

  // Output from previous processed block
  output_ready ? (
    spl0 = output_buf_l[buf_pos];
    spl1 = output_buf_r[buf_pos];
  ) : (
    spl0 = 0;
    spl1 = 0;
  );

  buf_pos += 1;

  // When we have a full chunk, process it
  buf_pos >= chunk_size ? (
    buf_pos = 0;

    // Swap input buffers: process the one we just filled,
    // start filling the other one
    proc_l = cur_input_l;
    proc_r = cur_input_r;
    cur_input_l == input_buf_l0 ? (
      cur_input_l = input_buf_l1;
      cur_input_r = input_buf_r1;
    ) : (
      cur_input_l = input_buf_l0;
      cur_input_r = input_buf_r0;
    );

    // Convert L/R to Mid/Side
    i = 0;
    loop(chunk_size,
      l = proc_l[i];
      r = proc_r[i];
      work_buf_mid[i] = (l + r) * 0.5;
      work_buf_side[i] = (l - r) * 0.5;
      i += 1;
    );

    // Zero-pad to fft_size
    i = chunk_size;
    loop(fft_size - chunk_size,
      work_buf_mid[i] = 0;
      work_buf_side[i] = 0;
      i += 1;
    );

    // FFT the mid and side chunks
    fft_real(work_buf_mid, fft_size);
    fft_real(work_buf_side, fft_size);

    // Convolve with pre-computed FIR FFTs
    convolve_c(work_buf_mid, mid_fir_fft, fft_size / 2);
    convolve_c(work_buf_side, side_fir_fft, fft_size / 2);

    // IFFT back to time domain
    ifft_real(work_buf_mid, fft_size);
    ifft_real(work_buf_side, fft_size);

    // Scale by 1/fft_size and overlap-add
    scale = 1 / fft_size;
    i = 0;

    // First part: add overlap from previous block
    loop(fir_len - 1,
      m = work_buf_mid[i] * scale + overlap_mid[i];
      s = work_buf_side[i] * scale + overlap_side[i];
      i < chunk_size ? (
        // Convert M/S back to L/R, apply master gain
        output_buf_l[i] = (m + s) * master_gain;
        output_buf_r[i] = (m - s) * master_gain;
      );
      i += 1;
    );

    // Middle part: no overlap needed (only if chunk_size > fir_len-1)
    loop(chunk_size - (fir_len - 1),
      m = work_buf_mid[i] * scale;
      s = work_buf_side[i] * scale;
      output_buf_l[i] = (m + s) * master_gain;
      output_buf_r[i] = (m - s) * master_gain;
      i += 1;
    );

    // Save the tail for overlap-add next block
    j = 0;
    loop(fir_len - 1,
      overlap_mid[j] = work_buf_mid[chunk_size + j] * scale;
      overlap_side[j] = work_buf_side[chunk_size + j] * scale;
      j += 1;
    );

    output_ready = 1;

    // Apply post-tweak EQ and dry/wet to output buffer
    i = 0;
    loop(chunk_size,
      wet_l = output_buf_l[i];
      wet_r = output_buf_r[i];

      // Low shelf
      abs(low_gain) > 0.05 ? (
        wet_l = ls.lms_bq_proc_l(wet_l);
        wet_r = ls.lms_bq_proc_r(wet_r);
      );

      // Mid peak
      abs(mid_gain) > 0.05 ? (
        wet_l = mp.lms_bq_proc_l(wet_l);
        wet_r = mp.lms_bq_proc_r(wet_r);
      );

      // High shelf
      abs(high_gain) > 0.05 ? (
        wet_l = hs.lms_bq_proc_l(wet_l);
        wet_r = hs.lms_bq_proc_r(wet_r);
      );

      // 42069 FET Compressor (stereo linked, feed-forward)
      comp_on ? (
        comp42.lms_comp_proc(wet_l, wet_r);

        // Parallel compression mix
        comp_mix < 1 ? (
          wet_l = wet_l * (1 - comp_mix) + wet_l * comp42.gr * comp_mix;
          wet_r = wet_r * (1 - comp_mix) + wet_r * comp42.gr * comp_mix;
        ) : (
          wet_l *= comp42.gr;
          wet_r *= comp42.gr;
        );
      );

      // Limiter
      limiter_on ? (
        abs(wet_l) > limiter_thresh ? wet_l = sign(wet_l) * limiter_thresh;
        abs(wet_r) > limiter_thresh ? wet_r = sign(wet_r) * limiter_thresh;
      );

      // Dry/wet mix (dry from the just-processed input buffer)
      output_buf_l[i] = proc_l[i] * (1 - dry_wet) + wet_l * dry_wet;
      output_buf_r[i] = proc_r[i] * (1 - dry_wet) + wet_r * dry_wet;

      i += 1;
    );
  );

@gfx 520 340
// ============================================================================
//  COLOR CONSTANTS
// ============================================================================
COL_BG_R = 0.05; COL_BG_G = 0.05; COL_BG_B = 0.07;
COL_PANEL_R = 0.08; COL_PANEL_G = 0.08; COL_PANEL_B = 0.11;
COL_PANEL_HI_R = 0.12; COL_PANEL_HI_G = 0.12; COL_PANEL_HI_B = 0.16;
COL_BORDER_R = 0.20; COL_BORDER_G = 0.20; COL_BORDER_B = 0.25;
COL_TITLE_R = 0.95; COL_TITLE_G = 0.78; COL_TITLE_B = 0.35;
COL_SEC_R = 0.55; COL_SEC_G = 0.50; COL_SEC_B = 0.40;
COL_TEXT_R = 0.78; COL_TEXT_G = 0.78; COL_TEXT_B = 0.82;
COL_DIM_R = 0.38; COL_DIM_G = 0.38; COL_DIM_B = 0.42;
COL_ACCENT_R = 0.95; COL_ACCENT_G = 0.45; COL_ACCENT_B = 0.15;
COL_GREEN_R = 0.25; COL_GREEN_G = 0.80; COL_GREEN_B = 0.50;
COL_CYAN_R = 0.20; COL_CYAN_G = 0.60; COL_CYAN_B = 0.85;
COL_BAR_BG_R = 0.12; COL_BAR_BG_G = 0.12; COL_BAR_BG_B = 0.16;

// ============================================================================
//  BACKGROUND
// ============================================================================
gfx_r = COL_BG_R; gfx_g = COL_BG_G; gfx_b = COL_BG_B;
gfx_rect(0, 0, gfx_w, gfx_h);
gfx_r = 0.03; gfx_g = 0.03; gfx_b = 0.05;
gfx_rect(0, 0, gfx_w, 44);
gfx_r = COL_TITLE_R * 0.6; gfx_g = COL_TITLE_G * 0.6; gfx_b = COL_TITLE_B * 0.6;
gfx_rect(0, 44, gfx_w, 2);

// ============================================================================
//  HELPER: draw_bar
// ============================================================================
function draw_bar(bx, by, bw, bh, val, vmin, vmax, label, show_val) (
  gfx_r = COL_BAR_BG_R; gfx_g = COL_BAR_BG_G; gfx_b = COL_BAR_BG_B;
  gfx_rect(bx, by, bw, bh);
  norm = (val - vmin) / (vmax - vmin);
  norm = max(0, min(1, norm));
  fill_w = norm * bw;
  fill_w > 0 ? (
    gfx_r = COL_CYAN_R * 0.6; gfx_g = COL_CYAN_G * 0.6; gfx_b = COL_CYAN_B * 0.6;
    gfx_rect(bx, by, fill_w, bh);
    gfx_r = COL_CYAN_R * 0.8; gfx_g = COL_CYAN_G * 0.8; gfx_b = COL_CYAN_B * 0.8;
    gfx_rect(bx, by, fill_w, floor(bh / 2));
    gfx_r = COL_CYAN_R; gfx_g = COL_CYAN_G; gfx_b = COL_CYAN_B;
    gfx_rect(bx, by, fill_w, 1);
  );
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_rect(bx, by, bw, 1); gfx_rect(bx, by + bh - 1, bw, 1);
  gfx_rect(bx, by, 1, bh); gfx_rect(bx + bw - 1, by, 1, bh);
  gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
  gfx_setfont(1, "Arial", 12);
  gfx_x = bx + 5; gfx_y = by + floor((bh - 12) / 2);
  gfx_drawstr(label);
  show_val ? (
    gfx_setfont(1, "Arial", 11);
    gfx_x = bx + bw - 40; gfx_y = by + floor((bh - 11) / 2);
    gfx_drawnumber(val, val == floor(val) ? 0 : 1);
  );
  mouse_cap & 1 ? (
    mouse_x >= bx && mouse_x <= bx + bw &&
    mouse_y >= by && mouse_y <= by + bh ? (
      new_norm = (mouse_x - bx) / bw;
      new_norm = max(0, min(1, new_norm));
      val = vmin + new_norm * (vmax - vmin);
    );
  );
  val;
);

// ============================================================================
//  HELPER: draw_panel
// ============================================================================
function draw_panel(px, py, pw, ph, title) (
  gfx_r = COL_PANEL_R; gfx_g = COL_PANEL_G; gfx_b = COL_PANEL_B;
  gfx_rect(px, py, pw, ph);
  gfx_r = COL_PANEL_HI_R; gfx_g = COL_PANEL_HI_G; gfx_b = COL_PANEL_HI_B;
  gfx_rect(px, py, pw, 22);
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_rect(px, py + 22, pw, 1);
  gfx_r = COL_BORDER_R * 0.7; gfx_g = COL_BORDER_G * 0.7; gfx_b = COL_BORDER_B * 0.7;
  gfx_rect(px, py, pw, 1); gfx_rect(px, py, 1, ph);
  gfx_rect(px + pw - 1, py, 1, ph); gfx_rect(px, py + ph - 1, pw, 1);
  gfx_r = COL_SEC_R; gfx_g = COL_SEC_G; gfx_b = COL_SEC_B;
  gfx_setfont(1, "Arial", 12);
  gfx_x = px + 8; gfx_y = py + 4;
  gfx_drawstr(title);
);

// ============================================================================
//  HELPER: draw_toggle
// ============================================================================
function draw_toggle(tx, ty, is_on, label) (
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_circle(tx + 8, ty + 8, 7, 0);
  is_on ? (
    gfx_r = COL_GREEN_R; gfx_g = COL_GREEN_G; gfx_b = COL_GREEN_B;
    gfx_circle(tx + 8, ty + 8, 5, 1);
  ) : (
    gfx_r = 0.15; gfx_g = 0.15; gfx_b = 0.18;
    gfx_circle(tx + 8, ty + 8, 5, 1);
  );
  gfx_r = is_on ? COL_TEXT_R : COL_DIM_R;
  gfx_g = is_on ? COL_TEXT_G : COL_DIM_G;
  gfx_b = is_on ? COL_TEXT_B : COL_DIM_B;
  gfx_setfont(1, "Arial", 11);
  gfx_x = tx + 20; gfx_y = ty + 1;
  gfx_drawstr(label);
  (mouse_cap & 1) && !(last_cap & 1) &&
    mouse_x >= tx && mouse_x <= tx + 80 &&
    mouse_y >= ty && mouse_y <= ty + 16 ? (
      is_on = 1 - is_on;
  );
  is_on;
);

// ============================================================================
//  HELPER: draw_mode_sel — clickable mode selector
// ============================================================================
function draw_mode_sel(mx, my, mw, mh, val, vmax, label, v0, v1, v2, v3) (
  gfx_r = COL_BAR_BG_R; gfx_g = COL_BAR_BG_G; gfx_b = COL_BAR_BG_B;
  gfx_rect(mx, my, mw, mh);
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_rect(mx, my, mw, 1); gfx_rect(mx, my + mh - 1, mw, 1);
  gfx_rect(mx, my, 1, mh); gfx_rect(mx + mw - 1, my, 1, mh);
  gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
  gfx_setfont(1, "Arial", 12);
  gfx_x = mx + 5; gfx_y = my + floor((mh - 12) / 2);
  gfx_drawstr(label);
  gfx_r = COL_ACCENT_R; gfx_g = COL_ACCENT_G; gfx_b = COL_ACCENT_B;
  gfx_x = mx + mw - 72; gfx_y = my + floor((mh - 12) / 2);
  val == 0 ? gfx_drawstr(v0);
  val == 1 ? gfx_drawstr(v1);
  val == 2 ? gfx_drawstr(v2);
  val == 3 ? gfx_drawstr(v3);
  (mouse_cap & 1) && !(last_cap & 1) &&
    mouse_x >= mx && mouse_x <= mx + mw &&
    mouse_y >= my && mouse_y <= my + mh ? (
      val = (val + 1) % (vmax + 1);
  );
  (mouse_cap & 2) && !(last_cap & 2) &&
    mouse_x >= mx && mouse_x <= mx + mw &&
    mouse_y >= my && mouse_y <= my + mh ? (
      val = val - 1; val < 0 ? val = vmax;
  );
  val;
);

// ============================================================================
//  LAYOUT
// ============================================================================
margin = 8;
gap = 6;
bar_h = 18;
bar_sp = 21;
col_w = floor((gfx_w - margin * 2 - gap) / 2);
body_y = 50;

// ============================================================================
//  TITLE
// ============================================================================
gfx_r = COL_TITLE_R; gfx_g = COL_TITLE_G; gfx_b = COL_TITLE_B;
gfx_setfont(1, "Arial", 18);
gfx_x = 12; gfx_y = 12;
gfx_drawstr("MATCHERING REALTIME MASTER");
gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
gfx_setfont(1, "Arial", 11);
gfx_x = 12; gfx_y = 30;
gfx_drawstr("FIR Convolution - 4096 taps");

// ============================================================================
//  COLUMN 1: MATCHERING
// ============================================================================
c1x = margin;
draw_panel(c1x, body_y, col_w, 220, "MATCHERING");
cy = body_y + 26;
_old = slider1; slider1 = draw_bar(c1x + 4, cy, col_w - 8, bar_h, slider1, -20, 20, "In Gain", 1);
slider1 != _old ? slider_automate(2^0);
cy += bar_sp;
_old = slider2; slider2 = draw_bar(c1x + 4, cy, col_w - 8, bar_h, slider2, 0, 100, "Dry/Wet", 1);
slider2 != _old ? slider_automate(2^1);
cy += bar_sp;
_old = slider3; slider3 = draw_toggle(c1x + 8, cy + 2, slider3, "Limiter");
slider3 != _old ? slider_automate(2^2);
cy += bar_sp;
_old = slider4; slider4 = draw_bar(c1x + 4, cy, col_w - 8, bar_h, slider4, -6, 0, "Lim Thr", 1);
slider4 != _old ? slider_automate(2^3);
cy += bar_sp;
_old = slider5; slider5 = draw_bar(c1x + 4, cy, col_w - 8, bar_h, slider5, -6, 6, "Lo Tweak", 1);
slider5 != _old ? slider_automate(2^4);
cy += bar_sp;
_old = slider6; slider6 = draw_bar(c1x + 4, cy, col_w - 8, bar_h, slider6, -6, 6, "Mid Tweak", 1);
slider6 != _old ? slider_automate(2^5);
cy += bar_sp;
_old = slider7; slider7 = draw_bar(c1x + 4, cy, col_w - 8, bar_h, slider7, -6, 6, "Hi Tweak", 1);
slider7 != _old ? slider_automate(2^6);
cy += bar_sp;
_old = slider8; slider8 = draw_bar(c1x + 4, cy, col_w - 8, bar_h, slider8, 100, 2000, "Mid Freq", 1);
slider8 != _old ? slider_automate(2^7);

// ============================================================================
//  COLUMN 2: 42069 COMP
// ============================================================================
c2x = margin + col_w + gap;
draw_panel(c2x, body_y, col_w, 220, "42069 COMP");
cy = body_y + 26;
_old = slider9; slider9 = draw_toggle(c2x + 8, cy + 2, slider9, "42069 On");
slider9 != _old ? slider_automate(2^8);
cy += bar_sp;
_old = slider10; slider10 = draw_bar(c2x + 4, cy, col_w - 8, bar_h, slider10, -40, 0, "Thresh", 1);
slider10 != _old ? slider_automate(2^9);
cy += bar_sp;
_old = slider11; slider11 = draw_mode_sel(c2x + 4, cy, col_w - 8, bar_h, slider11, 3, "Ratio", "4:1", "8:1", "12:1", "20:1");
slider11 != _old ? slider_automate(2^10);
cy += bar_sp;
_old = slider12; slider12 = draw_bar(c2x + 4, cy, col_w - 8, bar_h, slider12, 0.02, 0.8, "Attack", 1);
slider12 != _old ? slider_automate(2^11);
cy += bar_sp;
_old = slider13; slider13 = draw_bar(c2x + 4, cy, col_w - 8, bar_h, slider13, 50, 1100, "Release", 1);
slider13 != _old ? slider_automate(2^12);
cy += bar_sp;
_old = slider14; slider14 = draw_bar(c2x + 4, cy, col_w - 8, bar_h, slider14, 0, 100, "Mix", 1);
slider14 != _old ? slider_automate(2^13);
cy += bar_sp;

// GR meter
comp_on ? (
  gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
  gfx_setfont(1, "Arial", 11);
  gfx_x = c2x + 8; gfx_y = cy + 2;
  gfx_drawstr("GR: ");
  gfx_r = COL_ACCENT_R; gfx_g = COL_ACCENT_G; gfx_b = COL_ACCENT_B;
  gfx_drawstr("-");
  gfx_drawnumber(comp42.gr_db, 1);
  gfx_drawstr("dB");
  cy += 16;
  // GR bar
  gfx_r = COL_BAR_BG_R; gfx_g = COL_BAR_BG_G; gfx_b = COL_BAR_BG_B;
  gfx_rect(c2x + 4, cy, col_w - 8, 6);
  gr_w = min(comp42.gr_db * 6, col_w - 8);
  gr_w > 0 ? (
    gfx_r = COL_ACCENT_R; gfx_g = COL_ACCENT_G * 0.4; gfx_b = 0.1;
    gfx_rect(c2x + 4, cy, gr_w, 6);
  );
);
  // ============================================================
  // INSTANCE MANAGER PANEL
  // ============================================================
  bc_rows_per_page = 5;
  bc_panel_h = bc_panel_expanded ? (30 + bc_rows_per_page * 14 + 18) : 30;
  bc_panel_y = gfx_h - bc_panel_h;

  gfx_r = 0.04; gfx_g = 0.04; gfx_b = 0.06;
  gfx_rect(0, bc_panel_y, gfx_w, bc_panel_h);
  gfx_r = 0.15; gfx_g = 0.15; gfx_b = 0.20;
  gfx_rect(0, bc_panel_y, gfx_w, 1);

  gfx_setfont(1, "Arial", 11);
  gfx_r = 0.95; gfx_g = 0.45; gfx_b = 0.15;
  gfx_x = 8; gfx_y = bc_panel_y + 8;
  bc_my_slot >= 0 ? (
    gfx_drawstr("I");
    gfx_drawnumber(bc_my_slot + 1, 0);
    gfx_drawstr("/");
    gfx_drawnumber(bc_instance_count, 0);
  ) : (
    gfx_drawstr("--");
  );

  bc_following > 0 ? (
    gfx_r = 0.2; gfx_g = 0.8; gfx_b = 0.3;
    gfx_drawstr("  Following: I");
    bc_fs = 0;
    loop(BC_MAX_INST,
      fsb = BC_MY_REGION + bc_fs * BC_SLOT_SIZE;
      gmem[fsb + 1] == bc_following ? (
        gfx_drawnumber(bc_fs + 1, 0);
        bc_fs = BC_MAX_INST;
      );
      bc_fs += 1;
    );
  ) : (
    gfx_r = 0.3; gfx_g = 0.3; gfx_b = 0.4;
    gfx_drawstr("  Following: --");
  );

  exp_x = gfx_w - 200;
  exp_y = bc_panel_y + 4;
  exp_w = 65;
  exp_h = 20;
  gfx_r = 0.12; gfx_g = 0.12; gfx_b = 0.16;
  gfx_rect(exp_x, exp_y, exp_w, exp_h);
  gfx_r = 0.5; gfx_g = 0.5; gfx_b = 0.6;
  gfx_x = exp_x + 5; gfx_y = exp_y + 4;
  bc_panel_expanded ? gfx_drawstr("COLLAPSE") : gfx_drawstr("EXPAND");
  (mouse_cap & 1) && !(last_cap & 1) &&
    mouse_x >= exp_x && mouse_x < exp_x + exp_w &&
    mouse_y >= exp_y && mouse_y < exp_y + exp_h ? (
    bc_panel_expanded = !bc_panel_expanded;
    bc_steal_mode = 0;
  );

  stl_x = gfx_w - 125;
  stl_y = bc_panel_y + 4;
  stl_w = 50;
  stl_h = 20;
  bc_steal_mode ? (
    gfx_r = 0.6; gfx_g = 0.2; gfx_b = 0.1;
  ) : (
    gfx_r = 0.2; gfx_g = 0.1; gfx_b = 0.1;
  );
  gfx_rect(stl_x, stl_y, stl_w, stl_h);
  gfx_r = 0.9; gfx_g = 0.5; gfx_b = 0.2;
  gfx_x = stl_x + 6; gfx_y = stl_y + 4;
  gfx_drawstr("STEAL");
  (mouse_cap & 1) && !(last_cap & 1) &&
    mouse_x >= stl_x && mouse_x < stl_x + stl_w &&
    mouse_y >= stl_y && mouse_y < stl_y + stl_h ? (
    bc_steal_mode = !bc_steal_mode;
    !bc_panel_expanded ? bc_panel_expanded = 1;
  );

  bc_following > 0 ? (
    unf_x = gfx_w - 65;
    unf_y = bc_panel_y + 4;
    unf_w = 55;
    unf_h = 20;
    gfx_r = 0.1; gfx_g = 0.2; gfx_b = 0.1;
    gfx_rect(unf_x, unf_y, unf_w, unf_h);
    gfx_r = 0.5; gfx_g = 0.9; gfx_b = 0.5;
    gfx_x = unf_x + 4; gfx_y = unf_y + 4;
    gfx_drawstr("UNFLW");
    (mouse_cap & 1) && !(last_cap & 1) &&
      mouse_x >= unf_x && mouse_x < unf_x + unf_w &&
      mouse_y >= unf_y && mouse_y < unf_y + unf_h ? (
      bc_following = 0;
      bc_follow_slot = -1;
    );
  );

  bc_panel_expanded ? (
    row_y = bc_panel_y + 30;
    row_h = 14;

    // Page nav — auto-scroll to show YOU on expand
    bc_my_page = bc_my_slot >= 0 ? floor(bc_my_slot / bc_rows_per_page) : 0;
    bc_page < 0 ? bc_page = 0;

    // Count active slots for page count
    bc_active_slots = 0;
    bc_si = 0;
    loop(BC_MAX_INST,
      gmem[BC_MY_REGION + bc_si * BC_SLOT_SIZE + 1] > 0 ? bc_active_slots += 1;
      bc_si += 1;
    );
    bc_total_pages = max(1, ceil(bc_active_slots / bc_rows_per_page));
    bc_page >= bc_total_pages ? bc_page = bc_total_pages - 1;

    // Prev page button
    pg_btn_w = 18; pg_btn_h = 14;
    pg_prev_x = 8; pg_prev_y = bc_panel_y + 30 + bc_rows_per_page * row_h + 2;
    bc_total_pages > 1 ? (
      gfx_r = 0.25; gfx_g = 0.25; gfx_b = 0.32;
      gfx_rect(pg_prev_x, pg_prev_y, pg_btn_w, pg_btn_h);
      gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.8;
      gfx_x = pg_prev_x + 4; gfx_y = pg_prev_y + 2;
      gfx_drawstr("<");
      (mouse_cap & 1) && !(last_cap & 1) &&
        mouse_x >= pg_prev_x && mouse_x < pg_prev_x + pg_btn_w &&
        mouse_y >= pg_prev_y && mouse_y < pg_prev_y + pg_btn_h ? (
        bc_page > 0 ? bc_page -= 1;
      );

      gfx_r = 0.25; gfx_g = 0.25; gfx_b = 0.32;
      gfx_rect(pg_prev_x + pg_btn_w + 2, pg_prev_y, pg_btn_w, pg_btn_h);
      gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.8;
      gfx_x = pg_prev_x + pg_btn_w + 6; gfx_y = pg_prev_y + 2;
      gfx_drawstr(">");
      (mouse_cap & 1) && !(last_cap & 1) &&
        mouse_x >= pg_prev_x + pg_btn_w + 2 && mouse_x < pg_prev_x + pg_btn_w * 2 + 2 &&
        mouse_y >= pg_prev_y && mouse_y < pg_prev_y + pg_btn_h ? (
        bc_page < bc_total_pages - 1 ? bc_page += 1;
      );

      // Page indicator
      gfx_r = 0.4; gfx_g = 0.4; gfx_b = 0.5;
      gfx_x = pg_prev_x + pg_btn_w * 2 + 8; gfx_y = pg_prev_y + 2;
      gfx_drawnumber(bc_page + 1, 0);
      gfx_drawstr("/");
      gfx_drawnumber(bc_total_pages, 0);

      // YOU button — jump to your page
      bc_page != bc_my_page ? (
        you_x = pg_prev_x + pg_btn_w * 2 + 40;
        gfx_r = 0.15; gfx_g = 0.15; gfx_b = 0.20;
        gfx_rect(you_x, pg_prev_y, 30, pg_btn_h);
        gfx_r = 0.95; gfx_g = 0.45; gfx_b = 0.15;
        gfx_x = you_x + 3; gfx_y = pg_prev_y + 2;
        gfx_drawstr("YOU");
        (mouse_cap & 1) && !(last_cap & 1) &&
          mouse_x >= you_x && mouse_x < you_x + 30 &&
          mouse_y >= pg_prev_y && mouse_y < pg_prev_y + pg_btn_h ? (
          bc_page = bc_my_page;
        );
      );
    );

    // Draw rows for current page
    bc_page_start = bc_page * bc_rows_per_page;
    bc_page_end = bc_page_start + bc_rows_per_page - 1;
    bc_visible = 0;
    bc_s = 0;
    loop(BC_MAX_INST,
      isb = BC_MY_REGION + bc_s * BC_SLOT_SIZE;
      isid = gmem[isb + 1];

      isid > 0 ? (
        bc_visible >= bc_page_start && bc_visible <= bc_page_end ? (
          draw_row_y = row_y + (bc_visible - bc_page_start) * row_h;

          mouse_y >= draw_row_y && mouse_y < draw_row_y + row_h &&
            mouse_x >= 8 && mouse_x < gfx_w - 8 &&
            bc_s != bc_my_slot ? (
            gfx_r = 0.10; gfx_g = 0.10; gfx_b = 0.14;
            gfx_rect(4, draw_row_y, gfx_w - 8, row_h);
          );

          gfx_setfont(1, "Arial", 10);
          bc_s == bc_my_slot ? (
            gfx_r = 0.95; gfx_g = 0.45; gfx_b = 0.15;
          ) : (
            gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.8;
          );
          gfx_x = 12; gfx_y = draw_row_y + 1;
          gfx_drawstr("I");
          gfx_drawnumber(bc_s + 1, 0);
          gfx_drawstr("  ");

          bc_s == bc_my_slot ? (
            gfx_drawstr("[YOU]");
          ) : (
            iwho = gmem[isb + 3];
            // Check if anyone is following this instance
            bc_has_follower = 0;
            bc_fsc = 0;
            loop(BC_MAX_INST,
              fsb2 = BC_MY_REGION + bc_fsc * BC_SLOT_SIZE;
              gmem[fsb2 + 1] > 0 && gmem[fsb2 + 3] == isid ? bc_has_follower = 1;
              bc_fsc += 1;
            );
            iwho > 0 ? (
              // This instance is following someone — FOLLOWER
              gfx_r = 0.4; gfx_g = 0.6; gfx_b = 0.9;
              gfx_drawstr("[FOLLOWER]");
            ) : bc_has_follower ? (
              // Someone is following this instance — LEADER
              gfx_r = 0.95; gfx_g = 0.78; gfx_b = 0.35;
              gfx_drawstr("[LEADER]");
            ) : (
              // Nobody following, not following anyone — UNASSIGNED
              gfx_r = 0.38; gfx_g = 0.38; gfx_b = 0.45;
              gfx_drawstr("[UNASSIGNED]");
            );
            gfx_r = 0.35; gfx_g = 0.45; gfx_b = 0.35;
            bc_steal_mode ? (
              gfx_drawstr("  click: steal");
            ) : (
              gfx_drawstr("  click: follow");
            );
            (mouse_cap & 1) && !(last_cap & 1) &&
              mouse_y >= draw_row_y && mouse_y < draw_row_y + row_h &&
              mouse_x >= 8 && mouse_x < gfx_w - 8 ? (
              bc_steal_mode ? (
                bc_steal_target = isid;
                bc_steal_pending = 1;
                bc_steal_mode = 0;
              ) : (
                bc_can_follow = 1;
                bc_cursor = isid;
                bc_hops = 0;
                while(bc_cursor > 0 && bc_hops < BC_MAX_INST) (
                  bc_cursor == bc_my_id ? (
                    bc_can_follow = 0;
                    bc_cursor = 0;
                  ) : (
                    bc_next = 0;
                    bc_cs = 0;
                    loop(BC_MAX_INST,
                      csb = BC_MY_REGION + bc_cs * BC_SLOT_SIZE;
                      gmem[csb + 1] == bc_cursor ? (
                        bc_next = gmem[csb + 3];
                        bc_cs = BC_MAX_INST;
                      );
                      bc_cs += 1;
                    );
                    bc_cursor = bc_next;
                  );
                  bc_hops += 1;
                );
                bc_can_follow ? (
                  bc_following = isid;
                );
              );
            );
          );
        );
        bc_visible += 1;
      );
      bc_s += 1;
    );
  );

  last_cap = mouse_cap;

  // --- NOTICE BUTTON ---
  notice_btn_x = gfx_w - 60;
  notice_btn_y = bc_panel_y - 18;
  gfx_r = 0.6; gfx_g = 0.5; gfx_b = 0.3;
  gfx_rect(notice_btn_x, notice_btn_y, 55, 15);
  gfx_r = 0; gfx_g = 0; gfx_b = 0;
  gfx_x = notice_btn_x + 4; gfx_y = notice_btn_y + 2;
  gfx_drawstr("NOTICE");
  (mouse_cap & 1) && mouse_x >= notice_btn_x && mouse_x <= notice_btn_x + 55 && mouse_y >= notice_btn_y && mouse_y <= notice_btn_y + 15 && !notice_clicked ? (
    notice_show = !notice_show;
    notice_clicked = 1;
  );
  !(mouse_cap & 1) ? notice_clicked = 0;
  notice_show ? (
    gfx_r = 0.05; gfx_g = 0.05; gfx_b = 0.05; gfx_a = 0.95;
    gfx_rect(0, 0, gfx_w, gfx_h);
    gfx_a = 1;
    gfx_r = 0.9; gfx_g = 0.8; gfx_b = 0.5;
    gfx_x = 15; gfx_y = 10;
    gfx_drawstr("NOTICE: THEY ARE TRYING TO STEAL YOUR COMPUTER");
    gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.7;
    gfx_x = 15; gfx_y = 30;
    gfx_drawstr("The algorithms in our favorite software are decades old.");
    gfx_x = 15; gfx_y = 45;
    gfx_drawstr("A mathematical model is a truth about the world,");
    gfx_x = 15; gfx_y = 60;
    gfx_drawstr("not a copyrightable product. You do not have to stay");
    gfx_x = 15; gfx_y = 75;
    gfx_drawstr("a slave to subscription software. Install Linux.");
    gfx_x = 15; gfx_y = 90;
    gfx_drawstr("Build your own tools. Believe in yourself.");
    gfx_r = 0.5; gfx_g = 0.7; gfx_b = 1.0;
    gfx_x = 15; gfx_y = 115;
    gfx_drawstr("github.com/LMSBAND  |  instagram.com/LMSSKABAND");
    gfx_r = 0.4; gfx_g = 0.4; gfx_b = 0.4;
    gfx_x = 15; gfx_y = 140;
    gfx_r = 0.6; gfx_g = 0.5; gfx_b = 0.3;
    gfx_rect(notice_btn_x, notice_btn_y, 55, 15);
    gfx_r = 0; gfx_g = 0; gfx_b = 0;
    gfx_x = notice_btn_x + 4; gfx_y = notice_btn_y + 2;
    gfx_drawstr("NOTICE");
  );

// ============================================================
// @SERIALIZE — Persist follow state
// ============================================================
@serialize
file_var(0, bc_following);
file_var(0, bc_my_id);
