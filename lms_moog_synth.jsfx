desc:LMS Moog Synth
//tags: synthesizer instrument mono moog
//author: LMS

options:gmem=DrumBanger
options:maxmem=33554432

// ============================================================================
//  LMS MOOG SYNTH — Fat monophonic analog-style synthesizer
//  Moog-inspired ladder filter, PolyBLEP oscillators, unison, presets,
//  randomizer, DrumBanger integration, built-in effects
// ============================================================================

// ---------- OSCILLATORS ----------
slider1:0<0,4,1{Saw,Square,Triangle,Sine,Noise}>-OSC 1 Wave
slider2:0<-24,24,1>-OSC 1 Tune (semi)
slider3:0<-100,100,1>-OSC 1 Fine (cents)
slider4:100<0,100,1>-OSC 1 Level
slider5:50<0,100,1>-OSC 1 Pulse Width (%)

slider6:0<0,4,1{Saw,Square,Triangle,Sine,Noise}>-OSC 2 Wave
slider7:0<-24,24,1>-OSC 2 Tune (semi)
slider8:7<-100,100,1>-OSC 2 Fine (cents)
slider9:80<0,100,1>-OSC 2 Level

slider10:1<0,1,1{Off,On}>-Sub Osc
slider11:60<0,100,1>-Sub Level
slider12:30<0,100,1>-Noise Level
slider13:4<1,8,1>-Unison Voices
slider14:25<0,100,1>-Unison Detune

// ---------- FILTER ----------
slider15:800<20,20000,1>-Filter Cutoff (Hz)
slider16:0<0,100,1>-Filter Resonance
slider17:0<0,3,1{LP 24dB,LP 12dB,HP 24dB,BP 12dB}>-Filter Mode
slider18:50<0,100,1>-Filter Env Amount
slider19:5<0,2000,1>-Filter Attack (ms)
slider20:200<0,5000,1>-Filter Decay (ms)
slider21:30<0,100,1>-Filter Sustain
slider22:200<0,5000,1>-Filter Release (ms)

// ---------- AMP ENVELOPE ----------
slider23:2<0,2000,1>-Amp Attack (ms)
slider24:200<0,5000,1>-Amp Decay (ms)
slider25:70<0,100,1>-Amp Sustain
slider26:300<0,5000,1>-Amp Release (ms)

// ---------- LFO ----------
slider27:0<0,5,1{Sine,Triangle,Saw,Square,S&H,Random}>-LFO Shape
slider28:3.0<0.01,50,0.01>-LFO Rate (Hz)
slider29:0<0,1,1{Free,Sync}>-LFO Sync
slider30:0<0,100,1>-LFO > Pitch
slider31:0<0,100,1>-LFO > Filter
slider32:0<0,100,1>-LFO > Amp
slider33:0<0,100,1>-LFO > PWM

// ---------- PERFORMANCE ----------
slider34:0<0,1000,1>-Glide Time (ms)
slider35:0<0,1,1{Off,On}>-Glide
slider36:100<0,100,1>-Velocity > Amp
slider37:0<0,100,1>-Velocity > Filter

// ---------- EFFECTS ----------
slider38:0<0,3,1{Off,Warm,Hot,Fuzz}>-Drive Type
slider39:0<0,100,1>-Drive Amount
slider40:0<0,1,1{Off,On}>-Chorus
slider41:50<0,100,1>-Chorus Depth
slider42:1.5<0.1,5,0.1>-Chorus Rate (Hz)
slider43:0<0,1,1{Off,On}>-Delay
slider44:300<1,1000,1>-Delay Time (ms)
slider45:40<0,90,1>-Delay Feedback (%)
slider46:50<0,100,1>-Delay Mix (%)

// ---------- MASTER ----------
slider47:0<-24,24,0.1>-Master Volume (dB)
slider48:0<0,8,1{MIDI Only,Pad 1,Pad 2,Pad 3,Pad 4,Pad 5,Pad 6,Pad 7,Pad 8}>-DrumBanger Pad
slider49:0<0,12,1{INIT,Fat Bass,Acid Lead,Warm Pad,Sub Growl,Pluck,Brass,Hoover,Wobble,FX Sweep,Noise Hit,Random Bass,Random Lead}>-Preset
slider50:0<0,4,1{All,Bass,Lead,Pad,FX}>-Random Category
slider51:0<0,1,1{-,RANDOMIZE!}>-Randomize!
slider52:50<0,100,1>-FX Mix (%)

in_pin:none
out_pin:Left
out_pin:Right

@init
// ============================================================================
//  MEMORY LAYOUT
// ============================================================================

// Oscillator phases — 8 unison voices × 2 oscillators + sub
MEM_OSC1_PHASE = 0;     // 0..7
MEM_OSC2_PHASE = 8;     // 8..15
MEM_SUB_PHASE  = 16;
MEM_NOISE_SEED = 17;

// Moog ladder filter state — 4 stages × 2 channels
MEM_LADDER_L = 20;      // 20..23
MEM_LADDER_R = 24;      // 24..27

// Envelope states
amp_env_stage = 0;
amp_env_level = 0;
filt_env_stage = 0;
filt_env_level = 0;

// LFO
lfo_phase = 0;
lfo_value = 0;
lfo_sh_value = 0;
lfo_sh_prev = 0;
lfo_rand_target = 0;
lfo_rand_current = 0;

// Glide
glide_freq = 440;
target_freq = 440;
current_note = 60;
current_vel = 0;
note_on_flag = 0;
gate = 0;

// Mono voice tracking
notes_held = 0;        // count of held notes
note_stack_base = 200;  // memory for note stack (up to 16 notes)
note_stack_size = 0;

// Triangle oscillator integrators (for leaky integrated square)
MEM_TRI1_INT = 30;     // 30..37  (8 unison voices)
MEM_TRI2_INT = 38;     // 38..45

// DC blocker state
dc_l_x1 = 0; dc_l_y1 = 0;
dc_r_x1 = 0; dc_r_y1 = 0;

// Noise seed
MEM_NOISE_SEED[0] = 12345;

// Init oscillator phases with slight random offsets for unison spread
i = 0;
loop(8,
  MEM_OSC1_PHASE[i] = rand();
  MEM_OSC2_PHASE[i] = rand();
  MEM_TRI1_INT[i] = 0;
  MEM_TRI2_INT[i] = 0;
  i += 1;
);
MEM_SUB_PHASE[0] = 0;

// Init ladder filter
i = 0;
loop(4,
  MEM_LADDER_L[i] = 0;
  MEM_LADDER_R[i] = 0;
  i += 1;
);

// ============================================================================
//  CHORUS BUFFER
// ============================================================================
CHORUS_BUF_SIZE = 8192;
CHORUS_BUF_L = 1000;
CHORUS_BUF_R = CHORUS_BUF_L + CHORUS_BUF_SIZE;
chorus_wpos = 0;
chorus_lfo_phase = 0;
memset(CHORUS_BUF_L, 0, CHORUS_BUF_SIZE);
memset(CHORUS_BUF_R, 0, CHORUS_BUF_SIZE);

// ============================================================================
//  DELAY BUFFER
// ============================================================================
DELAY_BUF_SIZE = 96000;  // ~2s at 48k
DELAY_BUF_L = CHORUS_BUF_R + CHORUS_BUF_SIZE + 100;
DELAY_BUF_R = DELAY_BUF_L + DELAY_BUF_SIZE;
delay_wpos = 0;
memset(DELAY_BUF_L, 0, DELAY_BUF_SIZE);
memset(DELAY_BUF_R, 0, DELAY_BUF_SIZE);
delay_filt_l = 0;
delay_filt_r = 0;

// ============================================================================
//  SCOPE BUFFER
// ============================================================================
SCOPE_BUF = DELAY_BUF_R + DELAY_BUF_SIZE + 100;
SCOPE_SIZE = 1024;
scope_pos = 0;
scope_trigger_armed = 1;
memset(SCOPE_BUF, 0, SCOPE_SIZE);

// ============================================================================
//  PRESET DATA — stored in memory arrays
// ============================================================================
PRESET_DATA = SCOPE_BUF + SCOPE_SIZE + 100;
// Each preset = 52 values (slider1..slider52)
PRESET_COUNT = 11;
PRESET_STRIDE = 52;

// Preset 0: INIT — clean saw, open filter
p = PRESET_DATA + 0 * PRESET_STRIDE;
//        s1  s2 s3  s4  s5  s6  s7 s8  s9 s10 s11 s12 s13 s14
p[0]=0;  p[1]=0; p[2]=0; p[3]=100; p[4]=50;
p[5]=0;  p[6]=0; p[7]=7; p[8]=80;
p[9]=1;  p[10]=60; p[11]=0; p[12]=1; p[13]=0;
//        s15   s16 s17 s18 s19  s20  s21 s22
p[14]=2000; p[15]=0; p[16]=0; p[17]=50; p[18]=5; p[19]=200; p[20]=30; p[21]=200;
//        s23 s24  s25 s26
p[22]=2; p[23]=200; p[24]=70; p[25]=300;
//        s27 s28  s29 s30 s31 s32 s33
p[26]=0; p[27]=3; p[28]=0; p[29]=0; p[30]=0; p[31]=0; p[32]=0;
//        s34 s35 s36  s37
p[33]=0; p[34]=0; p[35]=100; p[36]=0;
//        s38 s39 s40 s41 s42  s43 s44  s45 s46
p[37]=0; p[38]=0; p[39]=0; p[40]=50; p[41]=1.5; p[42]=0; p[43]=300; p[44]=40; p[45]=50;
//        s47 s48 s49 s50 s51 s52
p[46]=0; p[47]=0; p[48]=0; p[49]=0; p[50]=0; p[51]=50;

// Preset 1: Fat Bass — saw+sq, low cutoff, high env, unison 3
p = PRESET_DATA + 1 * PRESET_STRIDE;
p[0]=0; p[1]=-12; p[2]=0; p[3]=100; p[4]=50;
p[5]=1; p[6]=-12; p[7]=5; p[8]=90;
p[9]=1; p[10]=80; p[11]=0; p[12]=3; p[13]=30;
p[14]=200; p[15]=30; p[16]=0; p[17]=80; p[18]=5; p[19]=300; p[20]=10; p[21]=200;
p[22]=2; p[23]=150; p[24]=80; p[25]=200;
p[26]=0; p[27]=3; p[28]=0; p[29]=0; p[30]=0; p[31]=0; p[32]=0;
p[33]=0; p[34]=0; p[35]=100; p[36]=30;
p[37]=1; p[38]=30; p[39]=0; p[40]=50; p[41]=1.5; p[42]=0; p[43]=300; p[44]=40; p[45]=50;
p[46]=0; p[47]=0; p[48]=1; p[49]=0; p[50]=0; p[51]=50;

// Preset 2: Acid Lead — saw, high res, env mod, warm drive
p = PRESET_DATA + 2 * PRESET_STRIDE;
p[0]=0; p[1]=0; p[2]=0; p[3]=100; p[4]=50;
p[5]=0; p[6]=0; p[7]=10; p[8]=60;
p[9]=0; p[10]=0; p[11]=0; p[12]=1; p[13]=0;
p[14]=400; p[15]=70; p[16]=0; p[17]=90; p[18]=2; p[19]=150; p[20]=5; p[21]=100;
p[22]=2; p[23]=200; p[24]=70; p[25]=200;
p[26]=0; p[27]=3; p[28]=0; p[29]=0; p[30]=0; p[31]=0; p[32]=0;
p[33]=50; p[34]=1; p[35]=100; p[36]=50;
p[37]=1; p[38]=50; p[39]=0; p[40]=50; p[41]=1.5; p[42]=0; p[43]=300; p[44]=40; p[45]=50;
p[46]=0; p[47]=0; p[48]=2; p[49]=0; p[50]=0; p[51]=50;

// Preset 3: Warm Pad — tri+sine, slow attack, chorus, wide unison
p = PRESET_DATA + 3 * PRESET_STRIDE;
p[0]=2; p[1]=0; p[2]=0; p[3]=80; p[4]=50;
p[5]=3; p[6]=0; p[7]=7; p[8]=70;
p[9]=0; p[10]=0; p[11]=10; p[12]=4; p[13]=40;
p[14]=3000; p[15]=10; p[16]=0; p[17]=20; p[18]=800; p[19]=2000; p[20]=60; p[21]=1500;
p[22]=500; p[23]=1000; p[24]=80; p[25]=2000;
p[26]=0; p[27]=0.5; p[28]=0; p[29]=5; p[30]=10; p[31]=0; p[32]=0;
p[33]=0; p[34]=0; p[35]=80; p[36]=20;
p[37]=0; p[38]=0; p[39]=1; p[40]=70; p[41]=1.0; p[42]=0; p[43]=300; p[44]=40; p[45]=50;
p[46]=0; p[47]=0; p[48]=3; p[49]=0; p[50]=0; p[51]=50;

// Preset 4: Sub Growl — saw, sub on, LFO→filter, drive hot
p = PRESET_DATA + 4 * PRESET_STRIDE;
p[0]=0; p[1]=-12; p[2]=0; p[3]=100; p[4]=50;
p[5]=0; p[6]=-12; p[7]=15; p[8]=70;
p[9]=1; p[10]=100; p[11]=0; p[12]=2; p[13]=20;
p[14]=300; p[15]=50; p[16]=0; p[17]=60; p[18]=5; p[19]=400; p[20]=20; p[21]=300;
p[22]=2; p[23]=200; p[24]=80; p[25]=300;
p[26]=0; p[27]=6; p[28]=0; p[29]=0; p[30]=50; p[31]=0; p[32]=0;
p[33]=30; p[34]=1; p[35]=100; p[36]=40;
p[37]=2; p[38]=60; p[39]=0; p[40]=50; p[41]=1.5; p[42]=0; p[43]=300; p[44]=40; p[45]=50;
p[46]=0; p[47]=0; p[48]=4; p[49]=0; p[50]=0; p[51]=50;

// Preset 5: Pluck — saw, zero attack/sustain, short decay
p = PRESET_DATA + 5 * PRESET_STRIDE;
p[0]=0; p[1]=0; p[2]=0; p[3]=100; p[4]=50;
p[5]=1; p[6]=0; p[7]=5; p[8]=60;
p[9]=0; p[10]=0; p[11]=0; p[12]=1; p[13]=0;
p[14]=5000; p[15]=20; p[16]=0; p[17]=80; p[18]=0; p[19]=100; p[20]=0; p[21]=80;
p[22]=0; p[23]=120; p[24]=0; p[25]=80;
p[26]=0; p[27]=3; p[28]=0; p[29]=0; p[30]=0; p[31]=0; p[32]=0;
p[33]=0; p[34]=0; p[35]=100; p[36]=50;
p[37]=0; p[38]=0; p[39]=0; p[40]=50; p[41]=1.5; p[42]=0; p[43]=300; p[44]=40; p[45]=50;
p[46]=0; p[47]=0; p[48]=5; p[49]=0; p[50]=0; p[51]=50;

// Preset 6: Brass — saw+sq, med attack, unison 4
p = PRESET_DATA + 6 * PRESET_STRIDE;
p[0]=0; p[1]=0; p[2]=0; p[3]=100; p[4]=50;
p[5]=1; p[6]=0; p[7]=3; p[8]=80;
p[9]=0; p[10]=0; p[11]=0; p[12]=4; p[13]=25;
p[14]=1500; p[15]=20; p[16]=0; p[17]=70; p[18]=50; p[19]=300; p[20]=40; p[21]=200;
p[22]=50; p[23]=200; p[24]=80; p[25]=150;
p[26]=0; p[27]=3; p[28]=0; p[29]=0; p[30]=0; p[31]=0; p[32]=0;
p[33]=20; p[34]=1; p[35]=100; p[36]=40;
p[37]=1; p[38]=20; p[39]=0; p[40]=50; p[41]=1.5; p[42]=0; p[43]=300; p[44]=40; p[45]=50;
p[46]=0; p[47]=0; p[48]=6; p[49]=0; p[50]=0; p[51]=50;

// Preset 7: Hoover — saw, heavy detune, glide, unison 6
p = PRESET_DATA + 7 * PRESET_STRIDE;
p[0]=0; p[1]=0; p[2]=0; p[3]=100; p[4]=50;
p[5]=0; p[6]=7; p[7]=30; p[8]=100;
p[9]=1; p[10]=40; p[11]=0; p[12]=6; p[13]=60;
p[14]=2000; p[15]=30; p[16]=0; p[17]=50; p[18]=20; p[19]=500; p[20]=30; p[21]=400;
p[22]=10; p[23]=300; p[24]=70; p[25]=400;
p[26]=0; p[27]=2; p[28]=0; p[29]=5; p[30]=10; p[31]=0; p[32]=0;
p[33]=100; p[34]=1; p[35]=100; p[36]=20;
p[37]=1; p[38]=30; p[39]=0; p[40]=50; p[41]=1.5; p[42]=0; p[43]=300; p[44]=40; p[45]=50;
p[46]=0; p[47]=0; p[48]=7; p[49]=0; p[50]=0; p[51]=50;

// Preset 8: Wobble — sq, heavy LFO→filter, resonance high
p = PRESET_DATA + 8 * PRESET_STRIDE;
p[0]=1; p[1]=0; p[2]=0; p[3]=100; p[4]=50;
p[5]=1; p[6]=0; p[7]=5; p[8]=80;
p[9]=1; p[10]=60; p[11]=0; p[12]=2; p[13]=20;
p[14]=800; p[15]=70; p[16]=0; p[17]=30; p[18]=5; p[19]=200; p[20]=30; p[21]=200;
p[22]=2; p[23]=200; p[24]=80; p[25]=300;
p[26]=0; p[27]=4; p[28]=0; p[29]=0; p[30]=80; p[31]=0; p[32]=0;
p[33]=0; p[34]=0; p[35]=100; p[36]=0;
p[37]=0; p[38]=0; p[39]=0; p[40]=50; p[41]=1.5; p[42]=0; p[43]=300; p[44]=40; p[45]=50;
p[46]=0; p[47]=0; p[48]=8; p[49]=0; p[50]=0; p[51]=50;

// Preset 9: FX Sweep — noise+sine, long filter attack, delay+chorus
p = PRESET_DATA + 9 * PRESET_STRIDE;
p[0]=4; p[1]=0; p[2]=0; p[3]=60; p[4]=50;
p[5]=3; p[6]=0; p[7]=0; p[8]=80;
p[9]=0; p[10]=0; p[11]=60; p[12]=2; p[13]=30;
p[14]=500; p[15]=40; p[16]=0; p[17]=70; p[18]=1500; p[19]=3000; p[20]=40; p[21]=2000;
p[22]=200; p[23]=2000; p[24]=60; p[25]=3000;
p[26]=0; p[27]=0.3; p[28]=0; p[29]=10; p[30]=30; p[31]=20; p[32]=0;
p[33]=0; p[34]=0; p[35]=80; p[36]=30;
p[37]=0; p[38]=0; p[39]=1; p[40]=60; p[41]=1.0; p[42]=1; p[43]=400; p[44]=50; p[45]=60;
p[46]=0; p[47]=0; p[48]=9; p[49]=0; p[50]=0; p[51]=60;

// Preset 10: Noise Hit — noise, short amp, high res, fuzz
p = PRESET_DATA + 10 * PRESET_STRIDE;
p[0]=4; p[1]=0; p[2]=0; p[3]=40; p[4]=50;
p[5]=0; p[6]=0; p[7]=0; p[8]=40;
p[9]=0; p[10]=0; p[11]=100; p[12]=1; p[13]=0;
p[14]=2000; p[15]=80; p[16]=0; p[17]=90; p[18]=0; p[19]=80; p[20]=0; p[21]=60;
p[22]=0; p[23]=50; p[24]=0; p[25]=50;
p[26]=0; p[27]=3; p[28]=0; p[29]=0; p[30]=0; p[31]=0; p[32]=0;
p[33]=0; p[34]=0; p[35]=100; p[36]=60;
p[37]=3; p[38]=70; p[39]=0; p[40]=50; p[41]=1.5; p[42]=0; p[43]=300; p[44]=40; p[45]=50;
p[46]=0; p[47]=0; p[48]=10; p[49]=0; p[50]=0; p[51]=50;

// DrumBanger integration state
db_connected = 0;
db_timeout = 0;
last_heartbeat = 0;
db_trig_active = 0;

// Preset tracking
last_preset = -1;
last_randomize = 0;

// GUI state
rand_flash = 0;
gui_scope_zoom = 1;

// ============================================================================
//  SATURATION FUNCTIONS (from lms_tube_sat.jsfx)
// ============================================================================

function fast_tanh(x)
  local(e2x)
(
  x > 10 ? 1 : x < -10 ? -1 : (
    e2x = exp(2 * x);
    (e2x - 1) / (e2x + 1);
  );
);

function warm_tube(x, drive, bias)
  local(b)
(
  b = x + bias * 0.1;
  b = b * (1 + drive);
  b > 0 ? (
    b = fast_tanh(b);
  ) : (
    b = fast_tanh(b * 0.8) * 1.25;
  );
  b;
);

function tape_sat(x, drive, bias)
  local(b)
(
  b = x + bias * 0.05;
  b = b * (1 + drive * 1.5);
  b = (2 / $pi) * atan(b * $pi * 0.5);
  b;
);

function fuzz(x, drive, bias)
  local(b)
(
  b = x + bias * 0.1;
  b = b * (1 + drive * 4);
  abs(b) < 0.1 * (1 - drive * 0.5) ? (
    b = b * (0.3 + drive * 0.7);
  ) : (
    b = sign(b) * (1 - exp(-abs(b)));
  );
  b;
);

// ============================================================================
//  CUBIC HERMITE INTERPOLATION (from lms_tape_echo.jsfx)
// ============================================================================

function buf_read_cubic(buf, pos, bmax)
  local(p0, p1, p2, p3, x0, x1, x2, x3, a, b, c, d, frac, idx)
(
  idx = floor(pos);
  frac = pos - idx;

  p0 = idx - 1; p0 < 0 ? p0 += bmax;
  p1 = idx;     p1 >= bmax ? p1 -= bmax;
  p2 = idx + 1; p2 >= bmax ? p2 -= bmax;
  p3 = idx + 2; p3 >= bmax ? p3 -= bmax;

  x0 = buf[p0]; x1 = buf[p1]; x2 = buf[p2]; x3 = buf[p3];

  a = -0.5*x0 + 1.5*x1 - 1.5*x2 + 0.5*x3;
  b = x0 - 2.5*x1 + 2*x2 - 0.5*x3;
  c = -0.5*x0 + 0.5*x2;
  d = x1;

  ((a * frac + b) * frac + c) * frac + d;
);

// ============================================================================
//  POLYBLEP ANTIALIASING
// ============================================================================

function polyblep(t, dt) (
  t < dt ? (
    t = t / dt;
    2*t - t*t - 1;
  ) : t > 1 - dt ? (
    t = (t - 1) / dt;
    t*t + 2*t + 1;
  ) : 0;
);

// ============================================================================
//  @SLIDER — recalculate coefficients
// ============================================================================

@slider

// Oscillator parameters
osc1_wave = slider1;
osc1_tune_semi = slider2;
osc1_fine_cents = slider3;
osc1_level = slider4 / 100;
osc1_pw = max(0.05, min(0.95, slider5 / 100));

osc2_wave = slider6;
osc2_tune_semi = slider7;
osc2_fine_cents = slider8;
osc2_level = slider9 / 100;

sub_on = slider10;
sub_level = slider11 / 100;
noise_level = slider12 / 100;
unison_count = max(1, min(8, slider13));
unison_detune = slider14 / 100;

// Filter parameters
filt_cutoff = slider15;
filt_reso = slider16 / 100;
filt_mode = slider17;
filt_env_amt = slider18 / 100;

// Filter envelope times → per-sample coefficients
filt_att_ms = max(0.5, slider19);
filt_dec_ms = max(0.5, slider20);
filt_sus = slider21 / 100;
filt_rel_ms = max(0.5, slider22);

filt_att_coeff = 1.0 / (filt_att_ms * 0.001 * srate);
filt_dec_coeff = exp(-1.0 / (filt_dec_ms * 0.001 * srate));
filt_rel_coeff = exp(-1.0 / (filt_rel_ms * 0.001 * srate));

// Amp envelope times
amp_att_ms = max(0.5, slider23);
amp_dec_ms = max(0.5, slider24);
amp_sus = slider25 / 100;
amp_rel_ms = max(0.5, slider26);

amp_att_coeff = 1.0 / (amp_att_ms * 0.001 * srate);
amp_dec_coeff = exp(-1.0 / (amp_dec_ms * 0.001 * srate));
amp_rel_coeff = exp(-1.0 / (amp_rel_ms * 0.001 * srate));

// LFO
lfo_shape = slider27;
lfo_rate = slider28;
lfo_sync = slider29;
lfo_to_pitch = slider30 / 100;
lfo_to_filter = slider31 / 100;
lfo_to_amp = slider32 / 100;
lfo_to_pwm = slider33 / 100;

// Glide
glide_ms = slider34;
glide_on = slider35;
vel_to_amp = slider36 / 100;
vel_to_filter = slider37 / 100;

// Effects
drive_type = slider38;
drive_amount = slider39 / 100;
chorus_on = slider40;
chorus_depth = slider41 / 100;
chorus_rate = slider42;
delay_on = slider43;
delay_time_ms = slider44;
delay_feedback = slider45 / 100;
delay_mix = slider46 / 100;

// Master
master_vol = 10 ^ (slider47 / 20);
fx_mix = slider52 / 100;

// Glide coefficient
glide_ms > 0 && glide_on ? (
  glide_coeff = exp(-1.0 / (glide_ms * 0.001 * srate));
) : (
  glide_coeff = 0;
);

// Delay samples
delay_samples = min(delay_time_ms * 0.001 * srate, DELAY_BUF_SIZE - 1);

// ============================================================================
//  PRESET LOADING
// ============================================================================

slider49 != last_preset ? (
  last_preset = slider49;

  // Presets 11,12 = random bass/lead → trigger randomizer
  slider49 == 11 ? (
    slider50 = 1; // Bass category
    slider51 = 1; // trigger randomize
  ) : slider49 == 12 ? (
    slider50 = 2; // Lead category
    slider51 = 1;
  ) : slider49 > 0 && slider49 <= 10 ? (
    // Load preset data
    p = PRESET_DATA + (slider49) * PRESET_STRIDE;
    slider1 = p[0]; slider2 = p[1]; slider3 = p[2]; slider4 = p[3]; slider5 = p[4];
    slider6 = p[5]; slider7 = p[6]; slider8 = p[7]; slider9 = p[8];
    slider10 = p[9]; slider11 = p[10]; slider12 = p[11]; slider13 = p[12]; slider14 = p[13];
    slider15 = p[14]; slider16 = p[15]; slider17 = p[16]; slider18 = p[17];
    slider19 = p[18]; slider20 = p[19]; slider21 = p[20]; slider22 = p[21];
    slider23 = p[22]; slider24 = p[23]; slider25 = p[24]; slider26 = p[25];
    slider27 = p[26]; slider28 = p[27]; slider29 = p[28]; slider30 = p[29];
    slider31 = p[30]; slider32 = p[31]; slider33 = p[32];
    slider34 = p[33]; slider35 = p[34]; slider36 = p[35]; slider37 = p[36];
    slider38 = p[37]; slider39 = p[38]; slider40 = p[39]; slider41 = p[40]; slider42 = p[41];
    slider43 = p[42]; slider44 = p[43]; slider45 = p[44]; slider46 = p[45];
    slider47 = p[46];
    // slider48 (DrumBanger Pad) intentionally NOT overwritten by presets
    slider50 = p[49]; slider51 = p[50]; slider52 = p[51];
  );
);

// ============================================================================
//  RANDOMIZER
// ============================================================================

slider51 == 1 && last_randomize == 0 ? (
  rand_flash = 60;
  cat = slider50; // 0=All, 1=Bass, 2=Lead, 3=Pad, 4=FX

  // OSC waves
  cat == 1 ? ( // Bass
    slider1 = floor(rand() * 2);      // Saw or Square
    slider6 = floor(rand() * 2);
  ) : cat == 3 ? ( // Pad
    w = floor(rand() * 3);
    slider1 = w == 0 ? 0 : w == 1 ? 2 : 3;  // Saw, Tri, Sine
    w = floor(rand() * 3);
    slider6 = w == 0 ? 0 : w == 1 ? 2 : 3;
  ) : (
    slider1 = floor(rand() * 5);
    slider6 = floor(rand() * 5);
  );

  // Tuning
  cat == 1 ? (
    slider2 = rand() > 0.5 ? 0 : -12;
    slider7 = rand() > 0.5 ? 0 : -12;
    slider8 = floor(rand() * 15);
  ) : cat == 2 ? (
    slider2 = floor(rand() * 25) - 12;
    slider7 = floor(rand() * 25) - 12;
    slider8 = floor(rand() * 30);
  ) : cat == 3 ? (
    slider2 = 0;
    t = floor(rand() * 4);
    slider7 = t == 0 ? 0 : t == 1 ? 7 : t == 2 ? -7 : 12;
    slider8 = floor(rand() * 20);
  ) : (
    slider2 = floor(rand() * 49) - 24;
    slider7 = floor(rand() * 49) - 24;
    slider8 = floor(rand() * 100);
  );
  slider3 = 0;

  // Levels
  slider4 = 60 + floor(rand() * 40);
  slider9 = 40 + floor(rand() * 60);
  slider5 = 20 + floor(rand() * 60);

  // Sub & noise
  cat == 1 ? ( slider10 = 1; slider11 = 40 + floor(rand() * 60); slider12 = floor(rand() * 20); )
  : cat == 4 ? ( slider10 = floor(rand() * 2); slider11 = floor(rand() * 80); slider12 = floor(rand() * 100); )
  : ( slider10 = floor(rand() * 2); slider11 = floor(rand() * 60); slider12 = floor(rand() * 40); );

  // Unison
  cat == 1 ? ( slider13 = 1 + floor(rand() * 4); slider14 = floor(rand() * 40); )
  : cat == 2 ? ( slider13 = 1 + floor(rand() * 6); slider14 = floor(rand() * 50); )
  : cat == 3 ? ( slider13 = 2 + floor(rand() * 3); slider14 = 20 + floor(rand() * 40); )
  : ( slider13 = 1 + floor(rand() * 8); slider14 = floor(rand() * 80); );

  // Filter cutoff
  cat == 1 ? ( slider15 = 60 + floor(rand() * 340); )
  : cat == 2 ? ( slider15 = 200 + floor(rand() * 7800); )
  : cat == 3 ? ( slider15 = 800 + floor(rand() * 5200); )
  : ( slider15 = 100 + floor(rand() * 14900); );

  // Resonance
  cat == 1 ? ( slider16 = floor(rand() * 40); )
  : cat == 2 ? ( slider16 = 10 + floor(rand() * 70); )
  : cat == 3 ? ( slider16 = floor(rand() * 30); )
  : ( slider16 = 20 + floor(rand() * 80); );

  // Filter env
  cat == 1 ? ( slider17 = 0; slider18 = 20 + floor(rand() * 60); )
  : cat == 2 ? ( slider17 = 0; slider18 = 10 + floor(rand() * 80); )
  : cat == 3 ? ( slider17 = 0; slider18 = 5 + floor(rand() * 25); )
  : ( slider17 = floor(rand() * 4); slider18 = floor(rand() * 100); );

  // Filter ADSR
  cat == 1 ? (
    slider19 = floor(rand() * 50); slider20 = 100 + floor(rand() * 400);
    slider21 = floor(rand() * 30); slider22 = 100 + floor(rand() * 200);
  ) : cat == 2 ? (
    slider19 = floor(rand() * 200); slider20 = 50 + floor(rand() * 750);
    slider21 = floor(rand() * 60); slider22 = 50 + floor(rand() * 300);
  ) : cat == 3 ? (
    slider19 = 100 + floor(rand() * 1900); slider20 = 500 + floor(rand() * 4500);
    slider21 = 30 + floor(rand() * 50); slider22 = 500 + floor(rand() * 2000);
  ) : (
    slider19 = floor(rand() * 2000); slider20 = 50 + floor(rand() * 4950);
    slider21 = floor(rand() * 100); slider22 = 50 + floor(rand() * 3000);
  );

  // Amp ADSR
  cat == 1 ? (
    slider23 = floor(rand() * 10); slider24 = 100 + floor(rand() * 400);
    slider25 = 50 + floor(rand() * 50); slider26 = 100 + floor(rand() * 200);
  ) : cat == 2 ? (
    slider23 = floor(rand() * 50); slider24 = 100 + floor(rand() * 900);
    slider25 = 30 + floor(rand() * 60); slider26 = 100 + floor(rand() * 400);
  ) : cat == 3 ? (
    slider23 = 200 + floor(rand() * 1800); slider24 = 500 + floor(rand() * 4500);
    slider25 = 50 + floor(rand() * 40); slider26 = 500 + floor(rand() * 2500);
  ) : (
    slider23 = floor(rand() * 2000); slider24 = 50 + floor(rand() * 4950);
    slider25 = floor(rand() * 100); slider26 = 50 + floor(rand() * 3000);
  );

  // LFO
  slider27 = floor(rand() * 6);
  cat == 1 ? ( slider28 = 0.5 + rand() * 7.5; )
  : cat == 2 ? ( slider28 = 0.1 + rand() * 19.9; )
  : cat == 3 ? ( slider28 = 0.05 + rand() * 1.95; )
  : ( slider28 = 0.01 + rand() * 49.99; );

  slider29 = 0;
  cat == 1 ? ( slider30 = 0; slider31 = floor(rand() * 30); )
  : cat == 2 ? ( slider30 = floor(rand() * 20); slider31 = floor(rand() * 60); )
  : cat == 3 ? ( slider30 = floor(rand() * 10); slider31 = floor(rand() * 40); )
  : ( slider30 = floor(rand() * 100); slider31 = floor(rand() * 100); );
  slider32 = floor(rand() * 20);
  slider33 = floor(rand() * 30);

  // Glide
  cat == 1 ? ( slider34 = floor(rand() * 100); )
  : cat == 2 ? ( slider34 = floor(rand() * 200); )
  : cat == 3 ? ( slider34 = 0; )
  : ( slider34 = floor(rand() * 500); );
  slider35 = slider34 > 10 ? 1 : 0;

  slider36 = 60 + floor(rand() * 40);
  slider37 = floor(rand() * 60);

  // Drive
  cat == 1 ? ( slider38 = rand() > 0.5 ? 0 : 1; slider39 = floor(rand() * 40); )
  : cat == 3 ? ( slider38 = 0; slider39 = 0; )
  : ( slider38 = floor(rand() * 4); slider39 = floor(rand() * 80); );

  // Chorus
  cat == 3 ? ( slider40 = rand() > 0.2 ? 1 : 0; )
  : cat == 1 ? ( slider40 = rand() > 0.5 ? 1 : 0; )
  : ( slider40 = rand() > 0.5 ? 1 : 0; );
  slider41 = 20 + floor(rand() * 60);
  slider42 = 0.5 + rand() * 3;

  // Delay
  cat == 3 ? ( slider43 = rand() > 0.4 ? 1 : 0; )
  : cat == 2 ? ( slider43 = rand() > 0.6 ? 1 : 0; )
  : ( slider43 = rand() > 0.7 ? 1 : 0; );
  slider44 = 100 + floor(rand() * 600);
  slider45 = 20 + floor(rand() * 50);
  slider46 = 30 + floor(rand() * 40);

  slider47 = 0;
  slider52 = 40 + floor(rand() * 30);

  slider51 = 0; // reset trigger
);
last_randomize = slider51;


// ============================================================================
//  @BLOCK — MIDI input + DrumBanger integration
// ============================================================================

@block

// ---- DrumBanger gmem integration ----
slider48 > 0 ? (
  watch_pad = slider48 - 1;
  heartbeat = gmem[10];
  heartbeat != last_heartbeat ? (
    last_heartbeat = heartbeat;
    db_connected = 1;
    db_timeout = srate * 0.5;
  );
  db_timeout > 0 ? db_timeout -= samplesblock : db_connected = 0;

  // Check for trigger from DrumBanger pad
  db_connected ? (
    trig_vel = gmem[100 + watch_pad];
    trig_vel > 0 ? (
      gmem[100 + watch_pad] = 0;
      current_vel = trig_vel / 127;
      gate = 1;
      amp_env_stage = 1;
      filt_env_stage = 1;
      db_trig_active = 1;
    );

    pad_active = gmem[120 + watch_pad];
    !pad_active && db_trig_active ? (
      gate = 0;
      db_trig_active = 0;
    );
  );
);

// ---- MIDI processing ----
while (midirecv(offset, msg1, msg2, msg3)) (
  status = msg1 & 0xF0;

  // Note On
  status == 0x90 && msg3 > 0 ? (
    // Push to note stack
    note_stack_size < 16 ? (
      (note_stack_base + note_stack_size * 2)[0] = msg2;
      (note_stack_base + note_stack_size * 2)[1] = msg3;
      note_stack_size += 1;
    );

    current_note = msg2;
    current_vel = msg3 / 127;
    target_freq = 440 * 2 ^ ((msg2 - 69) / 12);

    // If no glide or first note, snap immediately
    (!glide_on || note_stack_size <= 1) ? (
      glide_freq = target_freq;
    );

    gate = 1;
    amp_env_stage = 1;
    filt_env_stage = 1;
  );

  // Note Off
  (status == 0x80 || (status == 0x90 && msg3 == 0)) ? (
    // Remove from stack
    i = 0;
    found = -1;
    while (i < note_stack_size) (
      (note_stack_base + i * 2)[0] == msg2 ? found = i;
      i += 1;
    );
    found >= 0 ? (
      // Shift remaining notes down
      i = found;
      while (i < note_stack_size - 1) (
        (note_stack_base + i * 2)[0] = (note_stack_base + (i+1) * 2)[0];
        (note_stack_base + i * 2)[1] = (note_stack_base + (i+1) * 2)[1];
        i += 1;
      );
      note_stack_size -= 1;
    );

    note_stack_size > 0 ? (
      // Switch to the most recent held note (last-note priority)
      current_note = (note_stack_base + (note_stack_size - 1) * 2)[0];
      current_vel = (note_stack_base + (note_stack_size - 1) * 2)[1] / 127;
      target_freq = 440 * 2 ^ ((current_note - 69) / 12);
    ) : (
      gate = 0;
    );
  );

  // Pass MIDI through
  midisend(offset, msg1, msg2, msg3);
);


// ============================================================================
//  @SAMPLE — THE SOUND ENGINE
// ============================================================================

@sample

// ---- Glide (portamento) ----
glide_coeff > 0 ? (
  glide_freq = glide_freq * glide_coeff + target_freq * (1 - glide_coeff);
) : (
  glide_freq = target_freq;
);

// ---- LFO ----
lfo_dt = lfo_rate / srate;
lfo_phase += lfo_dt;
lfo_phase >= 1 ? (
  lfo_phase -= 1;
  // S&H: latch new random value on phase wrap
  lfo_shape == 4 ? ( lfo_sh_value = rand() * 2 - 1; );
  // Smooth random: pick new target
  lfo_shape == 5 ? ( lfo_rand_target = rand() * 2 - 1; );
);

lfo_shape == 0 ? ( lfo_value = sin(2 * $pi * lfo_phase); )                    // Sine
: lfo_shape == 1 ? ( lfo_value = lfo_phase < 0.5 ? 4*lfo_phase-1 : 3-4*lfo_phase; ) // Triangle
: lfo_shape == 2 ? ( lfo_value = 2 * lfo_phase - 1; )                          // Saw
: lfo_shape == 3 ? ( lfo_value = lfo_phase < 0.5 ? 1 : -1; )                  // Square
: lfo_shape == 4 ? ( lfo_value = lfo_sh_value; )                               // S&H
: lfo_shape == 5 ? (                                                             // Smooth Random
  lfo_rand_current += (lfo_rand_target - lfo_rand_current) * 0.001;
  lfo_value = lfo_rand_current;
);

// LFO modulation amounts
lfo_pitch_mod = lfo_value * lfo_to_pitch * 2;   // ±2 semitones max at 100%
lfo_filt_mod = lfo_value * lfo_to_filter;
lfo_amp_mod = 1 + lfo_value * lfo_to_amp * 0.5;  // ±50% amp mod at 100%
lfo_amp_mod = max(0, lfo_amp_mod);
lfo_pwm_mod = lfo_value * lfo_to_pwm * 0.4;     // ±40% PW modulation

// ---- Envelope processing ----

// Amp envelope
amp_env_stage == 1 ? (  // Attack
  amp_env_level += amp_att_coeff;
  amp_env_level >= 1.0 ? ( amp_env_level = 1.0; amp_env_stage = 2; );
) : amp_env_stage == 2 ? (  // Decay
  amp_env_level = amp_env_level * amp_dec_coeff + amp_sus * (1 - amp_dec_coeff);
  abs(amp_env_level - amp_sus) < 0.001 ? ( amp_env_stage = 3; );
) : amp_env_stage == 3 ? (  // Sustain
  amp_env_level = amp_sus;
) : amp_env_stage == 4 ? (  // Release
  amp_env_level *= amp_rel_coeff;
  amp_env_level < 0.0001 ? ( amp_env_level = 0; amp_env_stage = 0; );
);

// Gate off → release
!gate && amp_env_stage > 0 && amp_env_stage < 4 ? ( amp_env_stage = 4; );

// Filter envelope
filt_env_stage == 1 ? (
  filt_env_level += filt_att_coeff;
  filt_env_level >= 1.0 ? ( filt_env_level = 1.0; filt_env_stage = 2; );
) : filt_env_stage == 2 ? (
  filt_env_level = filt_env_level * filt_dec_coeff + filt_sus * (1 - filt_dec_coeff);
  abs(filt_env_level - filt_sus) < 0.001 ? ( filt_env_stage = 3; );
) : filt_env_stage == 3 ? (
  filt_env_level = filt_sus;
) : filt_env_stage == 4 ? (
  filt_env_level *= filt_rel_coeff;
  filt_env_level < 0.0001 ? ( filt_env_level = 0; filt_env_stage = 0; );
);

!gate && filt_env_stage > 0 && filt_env_stage < 4 ? ( filt_env_stage = 4; );

// ---- Velocity scaling ----
vel_amp = 1 - vel_to_amp + vel_to_amp * current_vel;
vel_filt = vel_to_filter * current_vel;

// ---- Oscillator synthesis ----
mix_out = 0;

// Calculate base frequencies with LFO pitch modulation
base_freq = glide_freq * 2 ^ (lfo_pitch_mod / 12);

osc1_freq_base = base_freq * 2 ^ ((osc1_tune_semi + osc1_fine_cents / 100) / 12);
osc2_freq_base = base_freq * 2 ^ ((osc2_tune_semi + osc2_fine_cents / 100) / 12);
sub_freq = base_freq * 0.5;  // Sub = one octave down

// Pulse width with LFO modulation
pw1 = max(0.05, min(0.95, osc1_pw + lfo_pwm_mod));
pw2 = 0.5;  // OSC2 fixed 50% PW (can expand later)

// Generate oscillators with unison
osc1_mix = 0;
osc2_mix = 0;

v = 0;
loop(unison_count,
  // Unison detune spread: voices spread evenly across ±detune range
  unison_count > 1 ? (
    detune_spread = (v / (unison_count - 1) - 0.5) * 2;  // -1 to +1
    detune_factor = 2 ^ (detune_spread * unison_detune * 0.5 / 12);  // up to ±0.5 semitone
  ) : (
    detune_factor = 1;
  );

  // OSC 1
  f1 = osc1_freq_base * detune_factor;
  dt1 = f1 / srate;
  phase1 = MEM_OSC1_PHASE[v];

  osc1_wave == 0 ? (  // Saw
    osc1_out = 2 * phase1 - 1 - polyblep(phase1, dt1);
  ) : osc1_wave == 1 ? (  // Square
    raw = phase1 < pw1 ? 1 : -1;
    osc1_out = raw + polyblep(phase1, dt1);
    // Correct for PW offset in polyBLEP
    pw_phase = phase1 + (1 - pw1);
    pw_phase >= 1 ? pw_phase -= 1;
    osc1_out -= polyblep(pw_phase, dt1);
  ) : osc1_wave == 2 ? (  // Triangle (leaky integrated square)
    raw = phase1 < 0.5 ? 1 : -1;
    raw += polyblep(phase1, dt1);
    pw_phase = phase1 + 0.5;
    pw_phase >= 1 ? pw_phase -= 1;
    raw -= polyblep(pw_phase, dt1);
    // Leaky integrator
    MEM_TRI1_INT[v] = MEM_TRI1_INT[v] * 0.999 + raw * dt1 * 4;
    osc1_out = MEM_TRI1_INT[v];
  ) : osc1_wave == 3 ? (  // Sine
    osc1_out = sin(2 * $pi * phase1);
  ) : (  // Noise
    MEM_NOISE_SEED[0] = (MEM_NOISE_SEED[0] * 1103515245 + 12345) & 0x7FFFFFFF;
    osc1_out = MEM_NOISE_SEED[0] / 0x7FFFFFFF * 2 - 1;
  );

  // Advance OSC1 phase
  phase1 += dt1;
  phase1 >= 1 ? phase1 -= 1;
  MEM_OSC1_PHASE[v] = phase1;

  osc1_mix += osc1_out;

  // OSC 2
  f2 = osc2_freq_base * detune_factor;
  dt2 = f2 / srate;
  phase2 = MEM_OSC2_PHASE[v];

  osc2_wave == 0 ? (  // Saw
    osc2_out = 2 * phase2 - 1 - polyblep(phase2, dt2);
  ) : osc2_wave == 1 ? (  // Square
    raw = phase2 < pw2 ? 1 : -1;
    osc2_out = raw + polyblep(phase2, dt2);
    pw_phase = phase2 + 0.5;
    pw_phase >= 1 ? pw_phase -= 1;
    osc2_out -= polyblep(pw_phase, dt2);
  ) : osc2_wave == 2 ? (  // Triangle
    raw = phase2 < 0.5 ? 1 : -1;
    raw += polyblep(phase2, dt2);
    pw_phase = phase2 + 0.5;
    pw_phase >= 1 ? pw_phase -= 1;
    raw -= polyblep(pw_phase, dt2);
    MEM_TRI2_INT[v] = MEM_TRI2_INT[v] * 0.999 + raw * dt2 * 4;
    osc2_out = MEM_TRI2_INT[v];
  ) : osc2_wave == 3 ? (  // Sine
    osc2_out = sin(2 * $pi * phase2);
  ) : (  // Noise
    MEM_NOISE_SEED[0] = (MEM_NOISE_SEED[0] * 1103515245 + 12345) & 0x7FFFFFFF;
    osc2_out = MEM_NOISE_SEED[0] / 0x7FFFFFFF * 2 - 1;
  );

  phase2 += dt2;
  phase2 >= 1 ? phase2 -= 1;
  MEM_OSC2_PHASE[v] = phase2;

  osc2_mix += osc2_out;

  v += 1;
);

// Normalize unison mix
unison_gain = 1 / sqrt(unison_count);
osc1_mix *= unison_gain;
osc2_mix *= unison_gain;

// Sub oscillator (square, one octave down, no unison)
sub_dt = sub_freq / srate;
sub_phase = MEM_SUB_PHASE[0];
sub_out = sub_phase < 0.5 ? 1 : -1;
sub_out += polyblep(sub_phase, sub_dt);
pw_phase = sub_phase + 0.5;
pw_phase >= 1 ? pw_phase -= 1;
sub_out -= polyblep(pw_phase, sub_dt);
sub_phase += sub_dt;
sub_phase >= 1 ? sub_phase -= 1;
MEM_SUB_PHASE[0] = sub_phase;

// Noise (independent of osc noise — dedicated noise gen)
MEM_NOISE_SEED[0] = (MEM_NOISE_SEED[0] * 1103515245 + 12345) & 0x7FFFFFFF;
noise_out = MEM_NOISE_SEED[0] / 0x7FFFFFFF * 2 - 1;

// ---- Mixer ----
mix_out = osc1_mix * osc1_level
        + osc2_mix * osc2_level
        + (sub_on ? sub_out * sub_level : 0)
        + noise_out * noise_level;

// ---- Moog Ladder Filter ----

// Calculate modulated cutoff
mod_cutoff = filt_cutoff;
// Envelope modulation (exponential mapping for musical response)
mod_cutoff = mod_cutoff * 2 ^ (filt_env_level * filt_env_amt * 4 - filt_env_amt * 2);
// Velocity modulation
mod_cutoff = mod_cutoff * 2 ^ (vel_filt * 2);
// LFO modulation
mod_cutoff = mod_cutoff * 2 ^ (lfo_filt_mod * 2);
// Clamp
mod_cutoff = max(20, min(srate * 0.45, mod_cutoff));

// Ladder filter coefficients
fc = 2 * mod_cutoff / srate;
fc = min(fc, 0.95);
f = fc * 1.16;
fb = filt_reso * (1.0 - 0.15 * f * f);

// Process left channel (mono synth, but we'll make stereo from effects)
input_l = mix_out;
input_l -= fb * 4.0 * MEM_LADDER_L[3];
input_l = fast_tanh(input_l);

MEM_LADDER_L[0] += f * (input_l    - MEM_LADDER_L[0]);
MEM_LADDER_L[1] += f * (MEM_LADDER_L[0] - MEM_LADDER_L[1]);
MEM_LADDER_L[2] += f * (MEM_LADDER_L[1] - MEM_LADDER_L[2]);
MEM_LADDER_L[3] += f * (MEM_LADDER_L[2] - MEM_LADDER_L[3]);

// Select filter mode output
filt_mode == 0 ? ( filt_out = MEM_LADDER_L[3]; )       // LP 24dB
: filt_mode == 1 ? ( filt_out = MEM_LADDER_L[1]; )     // LP 12dB
: filt_mode == 2 ? ( filt_out = mix_out - MEM_LADDER_L[3]; )  // HP 24dB
: ( filt_out = MEM_LADDER_L[1] - MEM_LADDER_L[3]; );   // BP 12dB

// ---- Amp envelope + velocity ----
synth_out = filt_out * amp_env_level * vel_amp * lfo_amp_mod;

// ---- Drive / Saturation ----
drive_type > 0 && drive_amount > 0 ? (
  drv = drive_amount;
  drive_type == 1 ? ( synth_out = warm_tube(synth_out, drv * 3, 0); )
  : drive_type == 2 ? ( synth_out = tape_sat(synth_out, drv * 3, 0); )
  : drive_type == 3 ? ( synth_out = fuzz(synth_out, drv, 0); );
);

// Mono → stereo
out_l = synth_out;
out_r = synth_out;

// ---- Dry signal for FX mix ----
dry_l = out_l;
dry_r = out_r;

// ---- Chorus ----
chorus_on ? (
  // Write to chorus buffer
  CHORUS_BUF_L[chorus_wpos] = out_l;
  CHORUS_BUF_R[chorus_wpos] = out_r;

  // Chorus LFO
  chorus_lfo_phase += chorus_rate / srate;
  chorus_lfo_phase >= 1 ? chorus_lfo_phase -= 1;
  chorus_lfo_val = sin(2 * $pi * chorus_lfo_phase);

  // Modulated delay for L and R (opposite phase for stereo width)
  base_delay = 0.006 * srate;  // 6ms base delay
  mod_depth = chorus_depth * 0.002 * srate;  // ±2ms at full depth

  rd_l = chorus_wpos - base_delay - chorus_lfo_val * mod_depth;
  rd_r = chorus_wpos - base_delay + chorus_lfo_val * mod_depth;
  rd_l < 0 ? rd_l += CHORUS_BUF_SIZE;
  rd_r < 0 ? rd_r += CHORUS_BUF_SIZE;

  chorus_l = buf_read_cubic(CHORUS_BUF_L, rd_l, CHORUS_BUF_SIZE);
  chorus_r = buf_read_cubic(CHORUS_BUF_R, rd_r, CHORUS_BUF_SIZE);

  out_l = out_l * 0.7 + chorus_l * 0.7;
  out_r = out_r * 0.7 + chorus_r * 0.7;

  chorus_wpos += 1;
  chorus_wpos >= CHORUS_BUF_SIZE ? chorus_wpos = 0;
);

// ---- Delay ----
delay_on ? (
  // Read from delay buffer
  rd_pos = delay_wpos - delay_samples;
  rd_pos < 0 ? rd_pos += DELAY_BUF_SIZE;

  delay_tap_l = buf_read_cubic(DELAY_BUF_L, rd_pos, DELAY_BUF_SIZE);
  delay_tap_r = buf_read_cubic(DELAY_BUF_R, rd_pos, DELAY_BUF_SIZE);

  // Lowpass in feedback path (tame the highs)
  delay_filt_l = delay_filt_l * 0.7 + delay_tap_l * 0.3;
  delay_filt_r = delay_filt_r * 0.7 + delay_tap_r * 0.3;

  // Write: input + filtered feedback (ping-pong: swap L/R)
  DELAY_BUF_L[delay_wpos] = out_l + delay_filt_r * delay_feedback;
  DELAY_BUF_R[delay_wpos] = out_r + delay_filt_l * delay_feedback;

  // Mix delay into output
  out_l += delay_tap_l * delay_mix;
  out_r += delay_tap_r * delay_mix;

  delay_wpos += 1;
  delay_wpos >= DELAY_BUF_SIZE ? delay_wpos = 0;
);

// ---- FX Mix (dry/wet blend) ----
(chorus_on || delay_on) ? (
  out_l = dry_l * (1 - fx_mix) + out_l * fx_mix;
  out_r = dry_r * (1 - fx_mix) + out_r * fx_mix;
);

// ---- DC Blocker ----
dc_coeff = 0.995;
dc_out_l = out_l - dc_l_x1 + dc_coeff * dc_l_y1;
dc_l_x1 = out_l;
dc_l_y1 = dc_out_l;

dc_out_r = out_r - dc_r_x1 + dc_coeff * dc_r_y1;
dc_r_x1 = out_r;
dc_r_y1 = dc_out_r;

out_l = dc_out_l;
out_r = dc_out_r;

// ---- Master Volume ----
out_l *= master_vol;
out_r *= master_vol;

// ---- Scope buffer ----
SCOPE_BUF[scope_pos] = out_l;
scope_pos += 1;
scope_pos >= SCOPE_SIZE ? scope_pos = 0;

// ---- Output ----
spl0 = out_l;
spl1 = out_r;


// ============================================================================
//  @GFX — FULL GUI (redesigned)
// ============================================================================

@gfx 750 480

// ============================================================================
//  COLOR PALETTE
// ============================================================================
COL_BG_R = 0.05; COL_BG_G = 0.05; COL_BG_B = 0.07;
COL_PANEL_R = 0.08; COL_PANEL_G = 0.08; COL_PANEL_B = 0.11;
COL_PANEL_HI_R = 0.12; COL_PANEL_HI_G = 0.12; COL_PANEL_HI_B = 0.16;
COL_BORDER_R = 0.20; COL_BORDER_G = 0.20; COL_BORDER_B = 0.25;
COL_TITLE_R = 0.95; COL_TITLE_G = 0.78; COL_TITLE_B = 0.35;
COL_SEC_R = 0.55; COL_SEC_G = 0.50; COL_SEC_B = 0.40;
COL_TEXT_R = 0.78; COL_TEXT_G = 0.78; COL_TEXT_B = 0.82;
COL_DIM_R = 0.38; COL_DIM_G = 0.38; COL_DIM_B = 0.42;
COL_ACCENT_R = 0.95; COL_ACCENT_G = 0.45; COL_ACCENT_B = 0.15;
COL_GREEN_R = 0.25; COL_GREEN_G = 0.80; COL_GREEN_B = 0.50;
COL_CYAN_R = 0.20; COL_CYAN_G = 0.60; COL_CYAN_B = 0.85;
COL_BAR_BG_R = 0.12; COL_BAR_BG_G = 0.12; COL_BAR_BG_B = 0.16;

// ============================================================================
//  BACKGROUND — subtle gradient feel via two-tone
// ============================================================================
gfx_r = COL_BG_R; gfx_g = COL_BG_G; gfx_b = COL_BG_B;
gfx_rect(0, 0, gfx_w, gfx_h);

// Top strip — darker header band
gfx_r = 0.03; gfx_g = 0.03; gfx_b = 0.05;
gfx_rect(0, 0, gfx_w, 58);

// Header accent line (warm gold)
gfx_r = COL_TITLE_R * 0.6; gfx_g = COL_TITLE_G * 0.6; gfx_b = COL_TITLE_B * 0.6;
gfx_rect(0, 58, gfx_w, 2);

// ============================================================================
//  HELPER: draw_bar — slick slider bar with glow fill
// ============================================================================
function draw_bar(bx, by, bw, bh, val, vmin, vmax, label, show_val) (
  // Bar background with subtle inset
  gfx_r = COL_BAR_BG_R; gfx_g = COL_BAR_BG_G; gfx_b = COL_BAR_BG_B;
  gfx_rect(bx, by, bw, bh);

  // Fill with gradient feel (brighter at top)
  norm = (val - vmin) / (vmax - vmin);
  norm = max(0, min(1, norm));
  fill_w = norm * bw;

  fill_w > 0 ? (
    gfx_r = COL_CYAN_R * 0.6; gfx_g = COL_CYAN_G * 0.6; gfx_b = COL_CYAN_B * 0.6;
    gfx_rect(bx, by, fill_w, bh);
    // Brighter top half for depth
    gfx_r = COL_CYAN_R * 0.8; gfx_g = COL_CYAN_G * 0.8; gfx_b = COL_CYAN_B * 0.8;
    gfx_rect(bx, by, fill_w, floor(bh / 2));
    // Bright edge line at top
    gfx_r = COL_CYAN_R; gfx_g = COL_CYAN_G; gfx_b = COL_CYAN_B;
    gfx_rect(bx, by, fill_w, 1);
  );

  // Thin border
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_rect(bx, by, bw, 1);
  gfx_rect(bx, by + bh - 1, bw, 1);
  gfx_rect(bx, by, 1, bh);
  gfx_rect(bx + bw - 1, by, 1, bh);

  // Label (left)
  gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
  gfx_setfont(1, "Arial", 12);
  gfx_x = bx + 5; gfx_y = by + floor((bh - 12) / 2);
  gfx_drawstr(label);

  // Value (right)
  show_val ? (
    gfx_setfont(1, "Arial", 11);
    gfx_x = bx + bw - 40; gfx_y = by + floor((bh - 11) / 2);
    gfx_drawnumber(val, val == floor(val) ? 0 : 1);
  );

  // Drag
  mouse_cap & 1 ? (
    mouse_x >= bx && mouse_x <= bx + bw &&
    mouse_y >= by && mouse_y <= by + bh ? (
      new_norm = (mouse_x - bx) / bw;
      new_norm = max(0, min(1, new_norm));
      val = vmin + new_norm * (vmax - vmin);
    );
  );

  val;
);

// ============================================================================
//  HELPER: draw_panel — section panel with header bar
// ============================================================================
function draw_panel(px, py, pw, ph, title) (
  // Panel body
  gfx_r = COL_PANEL_R; gfx_g = COL_PANEL_G; gfx_b = COL_PANEL_B;
  gfx_rect(px, py, pw, ph);

  // Header bar
  gfx_r = COL_PANEL_HI_R; gfx_g = COL_PANEL_HI_G; gfx_b = COL_PANEL_HI_B;
  gfx_rect(px, py, pw, 22);

  // Header bottom accent
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_rect(px, py + 22, pw, 1);

  // Panel border
  gfx_r = COL_BORDER_R * 0.7; gfx_g = COL_BORDER_G * 0.7; gfx_b = COL_BORDER_B * 0.7;
  gfx_rect(px, py, pw, 1);
  gfx_rect(px, py, 1, ph);
  gfx_rect(px + pw - 1, py, 1, ph);
  gfx_rect(px, py + ph - 1, pw, 1);

  // Title text
  gfx_r = COL_SEC_R; gfx_g = COL_SEC_G; gfx_b = COL_SEC_B;
  gfx_setfont(1, "Arial", 12);
  gfx_x = px + 8; gfx_y = py + 4;
  gfx_drawstr(title);
);

// ============================================================================
//  HELPER: wave_sel — draw waveform shape icon + click to cycle
// ============================================================================
function draw_wave_sel(wx, wy, ww, wh, wave_val, max_waves) (
  // Background
  gfx_r = COL_BAR_BG_R; gfx_g = COL_BAR_BG_G; gfx_b = COL_BAR_BG_B;
  gfx_rect(wx, wy, ww, wh);
  // Border
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_rect(wx, wy, ww, 1); gfx_rect(wx, wy+wh-1, ww, 1);
  gfx_rect(wx, wy, 1, wh); gfx_rect(wx+ww-1, wy, 1, wh);

  // Draw actual waveform shape
  gfx_r = COL_ACCENT_R; gfx_g = COL_ACCENT_G; gfx_b = COL_ACCENT_B;
  cx = wx + 4; cw = ww - 8; cmid = wy + floor(wh/2); camp = floor(wh/2) - 3;

  wave_val == 0 ? ( // Saw — ramp up then drop
    gfx_x = cx; gfx_y = cmid + camp;
    gfx_lineto(cx + cw, cmid - camp);
    gfx_lineto(cx + cw, cmid + camp);
  ) : wave_val == 1 ? ( // Square
    gfx_x = cx; gfx_y = cmid + camp;
    gfx_lineto(cx, cmid - camp);
    gfx_lineto(cx + floor(cw/2), cmid - camp);
    gfx_lineto(cx + floor(cw/2), cmid + camp);
    gfx_lineto(cx + cw, cmid + camp);
  ) : wave_val == 2 ? ( // Triangle
    gfx_x = cx; gfx_y = cmid;
    gfx_lineto(cx + floor(cw/4), cmid - camp);
    gfx_lineto(cx + floor(cw*3/4), cmid + camp);
    gfx_lineto(cx + cw, cmid);
  ) : wave_val == 3 ? ( // Sine (approximated with line segments)
    gfx_x = cx; gfx_y = cmid;
    gfx_lineto(cx + floor(cw*0.15), cmid - floor(camp*0.7));
    gfx_lineto(cx + floor(cw*0.25), cmid - camp);
    gfx_lineto(cx + floor(cw*0.35), cmid - floor(camp*0.7));
    gfx_lineto(cx + floor(cw*0.5), cmid);
    gfx_lineto(cx + floor(cw*0.65), cmid + floor(camp*0.7));
    gfx_lineto(cx + floor(cw*0.75), cmid + camp);
    gfx_lineto(cx + floor(cw*0.85), cmid + floor(camp*0.7));
    gfx_lineto(cx + cw, cmid);
  ) : ( // Noise — random-ish zigzag
    gfx_x = cx; gfx_y = cmid;
    gfx_lineto(cx + floor(cw*0.1), cmid - camp);
    gfx_lineto(cx + floor(cw*0.2), cmid + floor(camp*0.5));
    gfx_lineto(cx + floor(cw*0.35), cmid - floor(camp*0.3));
    gfx_lineto(cx + floor(cw*0.45), cmid + camp);
    gfx_lineto(cx + floor(cw*0.55), cmid - floor(camp*0.8));
    gfx_lineto(cx + floor(cw*0.7), cmid + floor(camp*0.6));
    gfx_lineto(cx + floor(cw*0.8), cmid - floor(camp*0.5));
    gfx_lineto(cx + floor(cw*0.9), cmid + floor(camp*0.9));
    gfx_lineto(cx + cw, cmid);
  );

  // Label text underneath shape
  gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
  gfx_setfont(1, "Arial", 9);
  wave_val == 0 ? ( gfx_x = wx + floor((ww - 20)/2); gfx_y = wy + wh + 1; gfx_drawstr("SAW"); )
  : wave_val == 1 ? ( gfx_x = wx + floor((ww - 20)/2); gfx_y = wy + wh + 1; gfx_drawstr("SQR"); )
  : wave_val == 2 ? ( gfx_x = wx + floor((ww - 16)/2); gfx_y = wy + wh + 1; gfx_drawstr("TRI"); )
  : wave_val == 3 ? ( gfx_x = wx + floor((ww - 20)/2); gfx_y = wy + wh + 1; gfx_drawstr("SIN"); )
  : ( gfx_x = wx + floor((ww - 20)/2); gfx_y = wy + wh + 1; gfx_drawstr("NSE"); );

  // Click to cycle
  (mouse_cap & 1) && !(last_cap & 1) &&
    mouse_x >= wx && mouse_x <= wx + ww &&
    mouse_y >= wy && mouse_y <= wy + wh + 12 ? (
      wave_val = (wave_val + 1) % (max_waves + 1);
  );

  wave_val;
);

// ============================================================================
//  HELPER: toggle button
// ============================================================================
function draw_toggle(tx, ty, is_on, label) (
  // Outer ring
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_circle(tx + 8, ty + 8, 7, 0);
  // Inner fill
  is_on ? (
    gfx_r = COL_GREEN_R; gfx_g = COL_GREEN_G; gfx_b = COL_GREEN_B;
    gfx_circle(tx + 8, ty + 8, 5, 1);
  ) : (
    gfx_r = 0.15; gfx_g = 0.15; gfx_b = 0.18;
    gfx_circle(tx + 8, ty + 8, 5, 1);
  );
  // Label
  gfx_r = is_on ? COL_TEXT_R : COL_DIM_R;
  gfx_g = is_on ? COL_TEXT_G : COL_DIM_G;
  gfx_b = is_on ? COL_TEXT_B : COL_DIM_B;
  gfx_setfont(1, "Arial", 11);
  gfx_x = tx + 20; gfx_y = ty + 1;
  gfx_drawstr(label);

  // Click
  (mouse_cap & 1) && !(last_cap & 1) &&
    mouse_x >= tx && mouse_x <= tx + 80 &&
    mouse_y >= ty && mouse_y <= ty + 16 ? (
      is_on = 1 - is_on;
  );
  is_on;
);

// ============================================================================
//  HELPER: clickable mode selector
// ============================================================================
function draw_mode_sel(mx, my, label, value_str) (
  gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
  gfx_setfont(1, "Arial", 11);
  gfx_x = mx; gfx_y = my;
  gfx_drawstr(label);
  gfx_r = COL_ACCENT_R; gfx_g = COL_ACCENT_G; gfx_b = COL_ACCENT_B;
  gfx_setfont(1, "Arial", 12);
  gfx_drawstr("  ");
  gfx_drawstr(value_str);
);

// ============================================================================
//  LAYOUT CONSTANTS
// ============================================================================
margin = 10;
gap = 6;
bar_h = 18;
bar_sp = 21;
col_w = floor((gfx_w - margin * 2 - gap * 2) / 3);
body_y = 64;

// ============================================================================
//  TITLE BAR
// ============================================================================
gfx_r = COL_TITLE_R; gfx_g = COL_TITLE_G; gfx_b = COL_TITLE_B;
gfx_setfont(1, "Arial", 22);
gfx_x = 18; gfx_y = 10;
gfx_drawstr("LMS MOOG SYNTH");

// Subtitle
gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
gfx_setfont(1, "Arial", 11);
gfx_x = 18; gfx_y = 38;
gfx_drawstr("Mono  //  Ladder Filter  //  Unison  //  FX");

// Preset name (top bar, right of title)
gfx_r = COL_SEC_R; gfx_g = COL_SEC_G; gfx_b = COL_SEC_B;
gfx_setfont(1, "Arial", 12);
gfx_x = 320; gfx_y = 14;
gfx_drawstr("PRESET: ");
gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
slider49 == 0 ? gfx_drawstr("INIT")
: slider49 == 1 ? gfx_drawstr("FAT BASS")
: slider49 == 2 ? gfx_drawstr("ACID LEAD")
: slider49 == 3 ? gfx_drawstr("WARM PAD")
: slider49 == 4 ? gfx_drawstr("SUB GROWL")
: slider49 == 5 ? gfx_drawstr("PLUCK")
: slider49 == 6 ? gfx_drawstr("BRASS")
: slider49 == 7 ? gfx_drawstr("HOOVER")
: slider49 == 8 ? gfx_drawstr("WOBBLE")
: slider49 == 9 ? gfx_drawstr("FX SWEEP")
: slider49 == 10 ? gfx_drawstr("NOISE HIT")
: slider49 == 11 ? gfx_drawstr("RND BASS")
: gfx_drawstr("RND LEAD");

// Preset click — left=forward, right=backward
(mouse_cap & 1) && !(last_cap & 1) &&
  mouse_x >= 320 && mouse_x < 500 &&
  mouse_y >= 10 && mouse_y < 30 ? (
  slider49 = (slider49 + 1) % 13;
);
(mouse_cap & 2) && !(last_cap & 2) &&
  mouse_x >= 320 && mouse_x < 500 &&
  mouse_y >= 10 && mouse_y < 30 ? (
  slider49 = slider49 - 1;
  slider49 < 0 ? slider49 = 12;
);

// Note/vel display (top bar)
gfx_setfont(1, "Arial", 11);
gfx_x = 320; gfx_y = 34;
gate ? (
  gfx_r = COL_GREEN_R; gfx_g = COL_GREEN_G; gfx_b = COL_GREEN_B;
  // Note name
  note_num = current_note % 12;
  note_num == 0 ? gfx_drawstr("C")
  : note_num == 1 ? gfx_drawstr("C#")
  : note_num == 2 ? gfx_drawstr("D")
  : note_num == 3 ? gfx_drawstr("D#")
  : note_num == 4 ? gfx_drawstr("E")
  : note_num == 5 ? gfx_drawstr("F")
  : note_num == 6 ? gfx_drawstr("F#")
  : note_num == 7 ? gfx_drawstr("G")
  : note_num == 8 ? gfx_drawstr("G#")
  : note_num == 9 ? gfx_drawstr("A")
  : note_num == 10 ? gfx_drawstr("A#")
  : gfx_drawstr("B");
  gfx_drawnumber(floor(current_note / 12) - 1, 0);
  gfx_drawstr("  vel ");
  gfx_drawnumber(floor(current_vel * 127), 0);
) : (
  gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
  gfx_drawstr("--");
);

// Envelope meters in top bar
env_bar_y = 16; env_bar_h = 6;
// AMP
gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
gfx_setfont(1, "Arial", 9);
gfx_x = gfx_w - 280; gfx_y = env_bar_y - 2;
gfx_drawstr("AMP");
gfx_r = COL_BAR_BG_R; gfx_g = COL_BAR_BG_G; gfx_b = COL_BAR_BG_B;
gfx_rect(gfx_w - 252, env_bar_y, 80, env_bar_h);
gfx_r = COL_GREEN_R; gfx_g = COL_GREEN_G; gfx_b = COL_GREEN_B;
gfx_rect(gfx_w - 252, env_bar_y, amp_env_level * 80, env_bar_h);
// FILT
gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
gfx_x = gfx_w - 280; gfx_y = env_bar_y + env_bar_h + 6;
gfx_drawstr("FLT");
gfx_r = COL_BAR_BG_R; gfx_g = COL_BAR_BG_G; gfx_b = COL_BAR_BG_B;
gfx_rect(gfx_w - 252, env_bar_y + env_bar_h + 6, 80, env_bar_h);
gfx_r = COL_CYAN_R; gfx_g = COL_CYAN_G; gfx_b = COL_CYAN_B;
gfx_rect(gfx_w - 252, env_bar_y + env_bar_h + 6, filt_env_level * 80, env_bar_h);

// RANDOMIZE button
rand_btn_x = gfx_w - 145; rand_btn_y = 10; rand_btn_w = 130; rand_btn_h = 34;
rand_flash > 0 ? (
  // Flash green
  flash_amt = rand_flash / 60;
  gfx_r = COL_GREEN_R * flash_amt; gfx_g = COL_GREEN_G * flash_amt; gfx_b = COL_GREEN_B * flash_amt;
  rand_flash -= 1;
) : (
  gfx_r = COL_ACCENT_R * 0.8; gfx_g = COL_ACCENT_G * 0.5; gfx_b = COL_ACCENT_B * 0.3;
);
gfx_rect(rand_btn_x, rand_btn_y, rand_btn_w, rand_btn_h);
// Button highlight edge
gfx_r = COL_ACCENT_R; gfx_g = COL_ACCENT_G; gfx_b = COL_ACCENT_B;
gfx_rect(rand_btn_x, rand_btn_y, rand_btn_w, 2);
// Button text
gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_setfont(1, "Arial", 14);
gfx_x = rand_btn_x + 14; gfx_y = rand_btn_y + 9;
gfx_drawstr("RANDOMIZE!");

// Click randomize
(mouse_cap & 1) && !(last_cap & 1) &&
  mouse_x >= rand_btn_x && mouse_x <= rand_btn_x + rand_btn_w &&
  mouse_y >= rand_btn_y && mouse_y <= rand_btn_y + rand_btn_h ? (
    slider51 = 1;
);

// Random Category selector — below RANDOMIZE button
cat_x = rand_btn_x; cat_y = rand_btn_y + rand_btn_h + 4;
gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
gfx_setfont(1, "Arial", 10);
gfx_x = cat_x; gfx_y = cat_y;
gfx_drawstr("CAT: ");
gfx_r = COL_ACCENT_R; gfx_g = COL_ACCENT_G; gfx_b = COL_ACCENT_B;
slider50 == 0 ? gfx_drawstr("ALL")
: slider50 == 1 ? gfx_drawstr("BASS")
: slider50 == 2 ? gfx_drawstr("LEAD")
: slider50 == 3 ? gfx_drawstr("PAD")
: gfx_drawstr("FX");
(mouse_cap & 1) && !(last_cap & 1) &&
  mouse_x >= cat_x && mouse_x < cat_x + 80 &&
  mouse_y >= cat_y && mouse_y < cat_y + 14 ? (
  slider50 = (slider50 + 1) % 5;
);
(mouse_cap & 2) && !(last_cap & 2) &&
  mouse_x >= cat_x && mouse_x < cat_x + 80 &&
  mouse_y >= cat_y && mouse_y < cat_y + 14 ? (
  slider50 = slider50 - 1;
  slider50 < 0 ? slider50 = 4;
);

// ============================================================================
//  ROW 1: OSCILLATORS | FILTER | AMP + SCOPE
// ============================================================================
row1_h = 210;

// ---- OSCILLATORS ----
osc_x = margin; osc_w = col_w;
draw_panel(osc_x, body_y, osc_w, row1_h, "OSCILLATORS");

cy = body_y + 28;
pad = 8;
inner_w = osc_w - pad * 2;

// OSC 1 section
gfx_r = COL_SEC_R; gfx_g = COL_SEC_G; gfx_b = COL_SEC_B;
gfx_setfont(1, "Arial", 11);
gfx_x = osc_x + pad; gfx_y = cy;
gfx_drawstr("OSC 1");

// Wave icon
slider1 = draw_wave_sel(osc_x + pad + 50, cy - 2, 42, 22, slider1, 4);

// Level bar next to wave
slider4 = draw_bar(osc_x + pad + 100, cy, inner_w - 100, bar_h, slider4, 0, 100, "LEVEL", 1);
cy += bar_sp + 10;  // extra space for wave label beneath

slider2 = draw_bar(osc_x + pad, cy, floor(inner_w/2) - 2, bar_h, slider2, -24, 24, "TUNE", 1);
slider3 = draw_bar(osc_x + pad + floor(inner_w/2) + 2, cy, floor(inner_w/2) - 2, bar_h, slider3, -100, 100, "FINE", 1);
cy += bar_sp;

slider5 = draw_bar(osc_x + pad, cy, inner_w, bar_h, slider5, 0, 100, "PW", 1);
cy += bar_sp + 6;

// Divider line between OSC 1 and OSC 2
gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
gfx_rect(osc_x + pad, cy - 3, inner_w, 1);

// OSC 2 section
gfx_r = COL_SEC_R; gfx_g = COL_SEC_G; gfx_b = COL_SEC_B;
gfx_setfont(1, "Arial", 11);
gfx_x = osc_x + pad; gfx_y = cy;
gfx_drawstr("OSC 2");

slider6 = draw_wave_sel(osc_x + pad + 50, cy - 2, 42, 22, slider6, 4);
slider9 = draw_bar(osc_x + pad + 100, cy, inner_w - 100, bar_h, slider9, 0, 100, "LEVEL", 1);
cy += bar_sp + 10;

slider7 = draw_bar(osc_x + pad, cy, floor(inner_w/2) - 2, bar_h, slider7, -24, 24, "TUNE", 1);
slider8 = draw_bar(osc_x + pad + floor(inner_w/2) + 2, cy, floor(inner_w/2) - 2, bar_h, slider8, -100, 100, "FINE", 1);

// ---- FILTER ----
flt_x = osc_x + osc_w + gap;
flt_w = col_w;
draw_panel(flt_x, body_y, flt_w, row1_h, "FILTER");

cy = body_y + 28;
inner_w = flt_w - pad * 2;

slider15 = draw_bar(flt_x + pad, cy, inner_w, bar_h, slider15, 20, 20000, "CUTOFF", 1);
cy += bar_sp;
slider16 = draw_bar(flt_x + pad, cy, inner_w, bar_h, slider16, 0, 100, "RESONANCE", 1);
cy += bar_sp;
slider18 = draw_bar(flt_x + pad, cy, inner_w, bar_h, slider18, 0, 100, "ENV AMT", 1);
cy += bar_sp + 4;

// Filter mode
filt_mode == 0 ? draw_mode_sel(flt_x + pad, cy, "MODE:", "LP 24dB")
: filt_mode == 1 ? draw_mode_sel(flt_x + pad, cy, "MODE:", "LP 12dB")
: filt_mode == 2 ? draw_mode_sel(flt_x + pad, cy, "MODE:", "HP 24dB")
: draw_mode_sel(flt_x + pad, cy, "MODE:", "BP 12dB");

(mouse_cap & 1) && !(last_cap & 1) &&
  mouse_x >= flt_x + pad && mouse_x <= flt_x + pad + 140 &&
  mouse_y >= cy && mouse_y <= cy + 16 ? (
    slider17 = (slider17 + 1) % 4;
    filt_mode = slider17;
);

cy += bar_sp + 2;

// Filter ADSR divider
gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
gfx_rect(flt_x + pad, cy - 3, inner_w, 1);

gfx_r = COL_SEC_R; gfx_g = COL_SEC_G; gfx_b = COL_SEC_B;
gfx_setfont(1, "Arial", 10);
gfx_x = flt_x + pad; gfx_y = cy;
gfx_drawstr("FILTER ENVELOPE");
cy += 16;

slider19 = draw_bar(flt_x + pad, cy, floor(inner_w/2) - 2, bar_h, slider19, 0, 2000, "A", 1);
slider20 = draw_bar(flt_x + pad + floor(inner_w/2) + 2, cy, floor(inner_w/2) - 2, bar_h, slider20, 0, 5000, "D", 1);
cy += bar_sp;
slider21 = draw_bar(flt_x + pad, cy, floor(inner_w/2) - 2, bar_h, slider21, 0, 100, "S", 1);
slider22 = draw_bar(flt_x + pad + floor(inner_w/2) + 2, cy, floor(inner_w/2) - 2, bar_h, slider22, 0, 5000, "R", 1);

// ---- AMP + SCOPE ----
amp_x = flt_x + flt_w + gap;
amp_w = gfx_w - amp_x - margin;
draw_panel(amp_x, body_y, amp_w, row1_h, "AMP / OUTPUT");

cy = body_y + 28;
inner_w = amp_w - pad * 2;

slider23 = draw_bar(amp_x + pad, cy, inner_w, bar_h, slider23, 0, 2000, "ATTACK", 1);
cy += bar_sp;
slider24 = draw_bar(amp_x + pad, cy, inner_w, bar_h, slider24, 0, 5000, "DECAY", 1);
cy += bar_sp;
slider25 = draw_bar(amp_x + pad, cy, inner_w, bar_h, slider25, 0, 100, "SUSTAIN", 1);
cy += bar_sp;
slider26 = draw_bar(amp_x + pad, cy, inner_w, bar_h, slider26, 0, 5000, "RELEASE", 1);
cy += bar_sp + 6;

// Scope
scope_x = amp_x + pad;
scope_y = cy;
scope_w = inner_w;
scope_h = row1_h - (cy - body_y) - pad;

// Scope background
gfx_r = 0.03; gfx_g = 0.03; gfx_b = 0.05;
gfx_rect(scope_x, scope_y, scope_w, scope_h);
// Scope border
gfx_r = COL_BORDER_R * 0.5; gfx_g = COL_BORDER_G * 0.5; gfx_b = COL_BORDER_B * 0.5;
gfx_rect(scope_x, scope_y, scope_w, 1);
gfx_rect(scope_x, scope_y+scope_h-1, scope_w, 1);
gfx_rect(scope_x, scope_y, 1, scope_h);
gfx_rect(scope_x+scope_w-1, scope_y, 1, scope_h);

// Center line
gfx_r = 0.12; gfx_g = 0.12; gfx_b = 0.16;
gfx_rect(scope_x + 1, scope_y + floor(scope_h/2), scope_w - 2, 1);

// Waveform
gfx_r = COL_GREEN_R; gfx_g = COL_GREEN_G; gfx_b = COL_GREEN_B; gfx_a = 0.9;
scope_step = SCOPE_SIZE / scope_w;
i = 0;
loop(scope_w,
  idx = floor(i * scope_step);
  idx >= SCOPE_SIZE ? idx = SCOPE_SIZE - 1;
  sv = SCOPE_BUF[(scope_pos + idx) % SCOPE_SIZE];
  sy = scope_y + scope_h * 0.5 - sv * scope_h * 0.4;
  sy = max(scope_y + 1, min(scope_y + scope_h - 2, sy));
  i == 0 ? (
    gfx_x = scope_x + 1; gfx_y = sy;
  ) : (
    gfx_lineto(scope_x + i, sy);
  );
  i += 1;
);
gfx_a = 1;

// ============================================================================
//  ROW 2: SUB/UNI | LFO | EFFECTS | PERFORM
// ============================================================================
row2_y = body_y + row1_h + gap;
row2_h = 148;
col2_w = floor((gfx_w - margin * 2 - gap * 3) / 4);

// ---- SUB / UNISON ----
sub_x = margin; sub_w = col2_w;
draw_panel(sub_x, row2_y, sub_w, row2_h, "SUB / UNISON");

cy = row2_y + 28;
inner_w = sub_w - pad * 2;

slider10 = draw_toggle(sub_x + pad, cy, slider10, "SUB OSC");
sub_on = slider10;
cy += 22;

slider11 = draw_bar(sub_x + pad, cy, inner_w, bar_h, slider11, 0, 100, "SUB LVL", 1);
cy += bar_sp;
slider12 = draw_bar(sub_x + pad, cy, inner_w, bar_h, slider12, 0, 100, "NOISE", 1);
cy += bar_sp;
slider13 = draw_bar(sub_x + pad, cy, inner_w, bar_h, slider13, 1, 8, "UNISON", 1);
cy += bar_sp;
slider14 = draw_bar(sub_x + pad, cy, inner_w, bar_h, slider14, 0, 100, "DETUNE", 1);

// ---- LFO ----
lfo_px = sub_x + sub_w + gap;
lfo_pw = col2_w;
draw_panel(lfo_px, row2_y, lfo_pw, row2_h, "LFO");

cy = row2_y + 28;
inner_w = lfo_pw - pad * 2;

// LFO shape
lfo_shape == 0 ? draw_mode_sel(lfo_px + pad, cy, "SHAPE:", "SINE")
: lfo_shape == 1 ? draw_mode_sel(lfo_px + pad, cy, "SHAPE:", "TRI")
: lfo_shape == 2 ? draw_mode_sel(lfo_px + pad, cy, "SHAPE:", "SAW")
: lfo_shape == 3 ? draw_mode_sel(lfo_px + pad, cy, "SHAPE:", "SQR")
: lfo_shape == 4 ? draw_mode_sel(lfo_px + pad, cy, "SHAPE:", "S&H")
: draw_mode_sel(lfo_px + pad, cy, "SHAPE:", "RND");

(mouse_cap & 1) && !(last_cap & 1) &&
  mouse_x >= lfo_px + pad && mouse_x <= lfo_px + pad + 140 &&
  mouse_y >= cy && mouse_y <= cy + 16 ? (
    slider27 = (slider27 + 1) % 6;
    lfo_shape = slider27;
);
// LFO Sync toggle (right side of SHAPE line)
slider29 = draw_toggle(lfo_px + pad + inner_w - 60, cy, slider29, "SYNC");
lfo_sync = slider29;
cy += bar_sp;

slider28 = draw_bar(lfo_px + pad, cy, inner_w, bar_h, slider28, 0.01, 50, "RATE", 1);
cy += bar_sp;
slider30 = draw_bar(lfo_px + pad, cy, floor(inner_w/2) - 2, bar_h, slider30, 0, 100, ">PIT", 1);
slider31 = draw_bar(lfo_px + pad + floor(inner_w/2) + 2, cy, floor(inner_w/2) - 2, bar_h, slider31, 0, 100, ">FLT", 1);
cy += bar_sp;
slider32 = draw_bar(lfo_px + pad, cy, floor(inner_w/2) - 2, bar_h, slider32, 0, 100, ">AMP", 1);
slider33 = draw_bar(lfo_px + pad + floor(inner_w/2) + 2, cy, floor(inner_w/2) - 2, bar_h, slider33, 0, 100, ">PWM", 1);

// LFO activity indicator — animated dot
cy += bar_sp + 2;
lfo_dot_cx = lfo_px + pad + floor(inner_w / 2);
lfo_dot_x = lfo_dot_cx + lfo_value * floor(inner_w / 2 - 6);
// Track line
gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
gfx_rect(lfo_px + pad, cy + 3, inner_w, 1);
// Dot
gfx_r = COL_GREEN_R; gfx_g = COL_GREEN_G; gfx_b = COL_GREEN_B;
gfx_circle(lfo_dot_x, cy + 3, 4, 1);

// ---- EFFECTS ----
fx_px = lfo_px + lfo_pw + gap;
fx_pw = col2_w;
draw_panel(fx_px, row2_y, fx_pw, row2_h, "EFFECTS");

cy = row2_y + 28;
inner_w = fx_pw - pad * 2;

// Drive mode
drive_type == 0 ? draw_mode_sel(fx_px + pad, cy, "DRIVE:", "OFF")
: drive_type == 1 ? draw_mode_sel(fx_px + pad, cy, "DRIVE:", "WARM")
: drive_type == 2 ? draw_mode_sel(fx_px + pad, cy, "DRIVE:", "HOT")
: draw_mode_sel(fx_px + pad, cy, "DRIVE:", "FUZZ");

(mouse_cap & 1) && !(last_cap & 1) &&
  mouse_x >= fx_px + pad && mouse_x <= fx_px + pad + 140 &&
  mouse_y >= cy && mouse_y <= cy + 16 ? (
    slider38 = (slider38 + 1) % 4;
    drive_type = slider38;
);
cy += bar_sp;

slider39 = draw_bar(fx_px + pad, cy, inner_w, bar_h, slider39, 0, 100, "DRIVE", 1);
cy += bar_sp + 4;

// Chorus
slider40 = draw_toggle(fx_px + pad, cy, slider40, "CHORUS");
chorus_on = slider40;
chr_half = floor((inner_w - 80) / 2) - 1;
slider41 = draw_bar(fx_px + pad + 80, cy, chr_half, bar_h, slider41, 0, 100, "DPTH", 1);
slider42 = draw_bar(fx_px + pad + 80 + chr_half + 2, cy, chr_half, bar_h, slider42, 0.1, 5, "RATE", 1);
cy += 22;

// Delay
slider43 = draw_toggle(fx_px + pad, cy, slider43, "DELAY");
delay_on = slider43;
slider44 = draw_bar(fx_px + pad + 80, cy, inner_w - 80, bar_h, slider44, 1, 1000, "TIME", 1);
cy += 22;

slider45 = draw_bar(fx_px + pad, cy, floor(inner_w/2) - 2, bar_h, slider45, 0, 90, "FB %", 1);
slider46 = draw_bar(fx_px + pad + floor(inner_w/2) + 2, cy, floor(inner_w/2) - 2, bar_h, slider46, 0, 100, "MIX", 1);

// ---- PERFORM ----
perf_px = fx_px + fx_pw + gap;
perf_pw = gfx_w - perf_px - margin;
draw_panel(perf_px, row2_y, perf_pw, row2_h, "PERFORM");

cy = row2_y + 28;
inner_w = perf_pw - pad * 2;

slider35 = draw_toggle(perf_px + pad, cy, slider35, "GLIDE");
glide_on = slider35;
slider34 = draw_bar(perf_px + pad + 80, cy, inner_w - 80, bar_h, slider34, 0, 1000, "ms", 1);
cy += 24;

slider36 = draw_bar(perf_px + pad, cy, inner_w, bar_h, slider36, 0, 100, "VEL > AMP", 1);
cy += bar_sp;
slider37 = draw_bar(perf_px + pad, cy, inner_w, bar_h, slider37, 0, 100, "VEL > FLT", 1);
cy += bar_sp;
slider47 = draw_bar(perf_px + pad, cy, inner_w, bar_h, slider47, -24, 24, "MASTER", 1);
cy += bar_sp;
slider52 = draw_bar(perf_px + pad, cy, inner_w, bar_h, slider52, 0, 100, "FX MIX", 1);

// DrumBanger Pad selector (clickable)
cy += bar_sp + 4;
db_connected ? (
  gfx_r = COL_GREEN_R; gfx_g = COL_GREEN_G; gfx_b = COL_GREEN_B;
) : (
  gfx_r = COL_DIM_R * 0.6; gfx_g = COL_DIM_G * 0.6; gfx_b = COL_DIM_B * 0.6;
);
gfx_circle(perf_px + pad + 8, cy + 4, 4, 1);
gfx_setfont(1, "Arial", 10);
gfx_x = perf_px + pad + 18; gfx_y = cy;
gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
gfx_drawstr("DB: ");
gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
slider48 == 0 ? gfx_drawstr("MIDI")
: (
  gfx_drawstr("PAD ");
  gfx_drawnumber(slider48, 0);
);
(mouse_cap & 1) && !(last_cap & 1) &&
  mouse_x >= perf_px + pad && mouse_x < perf_px + pad + inner_w &&
  mouse_y >= cy && mouse_y < cy + 14 ? (
  slider48 = (slider48 + 1) % 9;
);
(mouse_cap & 2) && !(last_cap & 2) &&
  mouse_x >= perf_px + pad && mouse_x < perf_px + pad + inner_w &&
  mouse_y >= cy && mouse_y < cy + 14 ? (
  slider48 = slider48 - 1;
  slider48 < 0 ? slider48 = 8;
);

// Store mouse state
last_cap = mouse_cap;
