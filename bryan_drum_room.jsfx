desc:Bryan's Sound City Drum Room
//tags: reverb room drums compressor
//author: Bryan + Claude

slider1:50<0,100,0.1>Room Size (%)
slider2:50<0,100,0.1>Decay (%)
slider3:40<0,100,0.1>Damping (%)
slider4:10<0,50,0.1>Pre-delay (ms)
slider5:0<-60,6,0.1>Near Mic (dB)
slider6:-3<-60,6,0.1>Mid Mic (dB)
slider7:-6<-60,6,0.1>Far Mic (dB)
slider8:0<0,2,1{U87 Condenser,Ribbon,421 Dynamic}>Mic Type
slider9:-12<-40,0,0.1>Comp Threshold (dB)
slider10:50<0,100,1>Comp Amount (%)
slider11:0<-12,12,0.1>Output Gain (dB)
slider12:50<0,100,1>Dry/Wet (%)

@init
  // Max buffer sizes at 96kHz
  MAX_BUF = 96000;

  // Buffer allocation
  buf_pos = 0;

  // Early reflection delay lines (stereo)
  er_buf_l = buf_pos; buf_pos += MAX_BUF;
  er_buf_r = buf_pos; buf_pos += MAX_BUF;

  // 8 comb filter buffers L
  comb_buf_l0 = buf_pos; buf_pos += 4096;
  comb_buf_l1 = buf_pos; buf_pos += 4096;
  comb_buf_l2 = buf_pos; buf_pos += 4096;
  comb_buf_l3 = buf_pos; buf_pos += 4096;
  comb_buf_l4 = buf_pos; buf_pos += 4096;
  comb_buf_l5 = buf_pos; buf_pos += 4096;
  comb_buf_l6 = buf_pos; buf_pos += 4096;
  comb_buf_l7 = buf_pos; buf_pos += 4096;

  // 8 comb filter buffers R (slightly different sizes for stereo)
  comb_buf_r0 = buf_pos; buf_pos += 4096;
  comb_buf_r1 = buf_pos; buf_pos += 4096;
  comb_buf_r2 = buf_pos; buf_pos += 4096;
  comb_buf_r3 = buf_pos; buf_pos += 4096;
  comb_buf_r4 = buf_pos; buf_pos += 4096;
  comb_buf_r5 = buf_pos; buf_pos += 4096;
  comb_buf_r6 = buf_pos; buf_pos += 4096;
  comb_buf_r7 = buf_pos; buf_pos += 4096;

  // 4 allpass buffers L
  ap_buf_l0 = buf_pos; buf_pos += 2048;
  ap_buf_l1 = buf_pos; buf_pos += 2048;
  ap_buf_l2 = buf_pos; buf_pos += 2048;
  ap_buf_l3 = buf_pos; buf_pos += 2048;

  // 4 allpass buffers R
  ap_buf_r0 = buf_pos; buf_pos += 2048;
  ap_buf_r1 = buf_pos; buf_pos += 2048;
  ap_buf_r2 = buf_pos; buf_pos += 2048;
  ap_buf_r3 = buf_pos; buf_pos += 2048;

  // Pre-delay buffers for 3 mic positions
  pd_buf_near_l = buf_pos; buf_pos += 4800;
  pd_buf_near_r = buf_pos; buf_pos += 4800;
  pd_buf_mid_l = buf_pos; buf_pos += 4800;
  pd_buf_mid_r = buf_pos; buf_pos += 4800;
  pd_buf_far_l = buf_pos; buf_pos += 4800;
  pd_buf_far_r = buf_pos; buf_pos += 4800;

  // Write positions
  er_pos = 0;
  comb_pos_l0 = 0; comb_pos_l1 = 0; comb_pos_l2 = 0; comb_pos_l3 = 0;
  comb_pos_l4 = 0; comb_pos_l5 = 0; comb_pos_l6 = 0; comb_pos_l7 = 0;
  comb_pos_r0 = 0; comb_pos_r1 = 0; comb_pos_r2 = 0; comb_pos_r3 = 0;
  comb_pos_r4 = 0; comb_pos_r5 = 0; comb_pos_r6 = 0; comb_pos_r7 = 0;
  ap_pos_l0 = 0; ap_pos_l1 = 0; ap_pos_l2 = 0; ap_pos_l3 = 0;
  ap_pos_r0 = 0; ap_pos_r1 = 0; ap_pos_r2 = 0; ap_pos_r3 = 0;
  pd_pos_near = 0; pd_pos_mid = 0; pd_pos_far = 0;

  // Comb filter lowpass states
  comb_lp_l0 = 0; comb_lp_l1 = 0; comb_lp_l2 = 0; comb_lp_l3 = 0;
  comb_lp_l4 = 0; comb_lp_l5 = 0; comb_lp_l6 = 0; comb_lp_l7 = 0;
  comb_lp_r0 = 0; comb_lp_r1 = 0; comb_lp_r2 = 0; comb_lp_r3 = 0;
  comb_lp_r4 = 0; comb_lp_r5 = 0; comb_lp_r6 = 0; comb_lp_r7 = 0;

  // Compressor state
  comp_env_l = 0;
  comp_env_r = 0;
  gr_display = 0;

  // Mic EQ biquad states (2 bands, stereo = 8 state vars each)
  mic_eq_states = buf_pos; buf_pos += 32;

  // Meter smoothing
  meter_near = 0;
  meter_mid = 0;
  meter_far = 0;
  meter_smooth = 0.995;

  // Base comb delays (in samples at 44100, will be scaled by room size and srate)
  // Chosen as mutually prime for minimal metallic resonance
  base_comb_0 = 1116;
  base_comb_1 = 1188;
  base_comb_2 = 1277;
  base_comb_3 = 1356;
  base_comb_4 = 1422;
  base_comb_5 = 1491;
  base_comb_6 = 1557;
  base_comb_7 = 1617;

  // Stereo offset for R channel (slightly longer)
  stereo_spread = 23;

  // Base allpass delays
  base_ap_0 = 556;
  base_ap_1 = 441;
  base_ap_2 = 341;
  base_ap_3 = 225;

  // Early reflection tap delays (ms) and gains, panned L/R
  // Simulating a rectangular room ~8m x 6m x 3m
  er_tap_count = 12;
  er_delays_ms = buf_pos; buf_pos += 12;
  er_gains = buf_pos; buf_pos += 12;
  er_pans = buf_pos; buf_pos += 12;

  er_delays_ms[0] = 2.3;   er_gains[0] = 0.85;  er_pans[0] = 0.3;
  er_delays_ms[1] = 4.1;   er_gains[1] = 0.75;  er_pans[1] = 0.7;
  er_delays_ms[2] = 5.8;   er_gains[2] = 0.70;  er_pans[2] = 0.2;
  er_delays_ms[3] = 8.2;   er_gains[3] = 0.60;  er_pans[3] = 0.8;
  er_delays_ms[4] = 11.7;  er_gains[4] = 0.50;  er_pans[4] = 0.4;
  er_delays_ms[5] = 14.3;  er_gains[5] = 0.45;  er_pans[5] = 0.6;
  er_delays_ms[6] = 18.1;  er_gains[6] = 0.38;  er_pans[6] = 0.15;
  er_delays_ms[7] = 22.5;  er_gains[7] = 0.32;  er_pans[7] = 0.85;
  er_delays_ms[8] = 27.3;  er_gains[8] = 0.26;  er_pans[8] = 0.5;
  er_delays_ms[9] = 33.1;  er_gains[9] = 0.21;  er_pans[9] = 0.35;
  er_delays_ms[10] = 39.7; er_gains[10] = 0.17; er_pans[10] = 0.65;
  er_delays_ms[11] = 47.2; er_gains[11] = 0.13; er_pans[11] = 0.45;

  // Peaking EQ biquad
  function calc_peaking(base, freq, gain_db, q)
    local(a, w0, alpha, a0)
  (
    a = 10 ^ (gain_db / 20);
    w0 = 2 * $pi * freq / srate;
    alpha = sin(w0) / (2 * q);
    a0 = 1 + alpha / a;
    base[0] = (1 + alpha * a) / a0;
    base[1] = (-2 * cos(w0)) / a0;
    base[2] = (1 - alpha * a) / a0;
    base[3] = (-2 * cos(w0)) / a0;
    base[4] = (1 - alpha / a) / a0;
  );

  // Lowpass biquad
  function calc_lowpass(base, freq, q)
    local(w0, alpha, a0)
  (
    w0 = 2 * $pi * freq / srate;
    alpha = sin(w0) / (2 * q);
    a0 = 1 + alpha;
    base[0] = ((1 - cos(w0)) / 2) / a0;
    base[1] = (1 - cos(w0)) / a0;
    base[2] = ((1 - cos(w0)) / 2) / a0;
    base[3] = (-2 * cos(w0)) / a0;
    base[4] = (1 - alpha) / a0;
  );

  // Highpass biquad
  function calc_highpass(base, freq, q)
    local(w0, alpha, a0)
  (
    w0 = 2 * $pi * freq / srate;
    alpha = sin(w0) / (2 * q);
    a0 = 1 + alpha;
    base[0] = ((1 + cos(w0)) / 2) / a0;
    base[1] = (-(1 + cos(w0))) / a0;
    base[2] = ((1 + cos(w0)) / 2) / a0;
    base[3] = (-2 * cos(w0)) / a0;
    base[4] = (1 - alpha) / a0;
  );

  // Apply biquad filter
  function apply_eq(base, input, s)
    local(output)
  (
    output = base[0] * input + base[1] * base[s] + base[2] * base[s+1]
           - base[3] * base[s+2] - base[4] * base[s+3];
    base[s+1] = base[s];
    base[s] = input;
    base[s+3] = base[s+2];
    base[s+2] = output;
    output;
  );

  // Mic EQ coefficient storage (2 filter bands)
  mic_eq_b1 = buf_pos; buf_pos += 16;
  mic_eq_b2 = buf_pos; buf_pos += 16;

@slider
  room_size = slider1 / 100;
  decay = slider2 / 100;
  damping = slider3 / 100;
  predelay_ms = slider4;
  near_gain = slider5 <= -59.9 ? 0 : 10 ^ (slider5 / 20);
  mid_gain = slider6 <= -59.9 ? 0 : 10 ^ (slider6 / 20);
  far_gain = slider7 <= -59.9 ? 0 : 10 ^ (slider7 / 20);
  mic_type = slider8;
  comp_thresh = 10 ^ (slider9 / 20);
  comp_amount = slider10 / 100;
  out_gain = 10 ^ (slider11 / 20);
  dry_wet = slider12 / 100;

  // Scale comb delays by room size (0.5x to 1.5x range)
  scale = 0.5 + room_size;
  srate_scale = srate / 44100;

  comb_len_l0 = (base_comb_0 * scale * srate_scale)|0;
  comb_len_l1 = (base_comb_1 * scale * srate_scale)|0;
  comb_len_l2 = (base_comb_2 * scale * srate_scale)|0;
  comb_len_l3 = (base_comb_3 * scale * srate_scale)|0;
  comb_len_l4 = (base_comb_4 * scale * srate_scale)|0;
  comb_len_l5 = (base_comb_5 * scale * srate_scale)|0;
  comb_len_l6 = (base_comb_6 * scale * srate_scale)|0;
  comb_len_l7 = (base_comb_7 * scale * srate_scale)|0;

  comb_len_r0 = ((base_comb_0 + stereo_spread) * scale * srate_scale)|0;
  comb_len_r1 = ((base_comb_1 + stereo_spread) * scale * srate_scale)|0;
  comb_len_r2 = ((base_comb_2 + stereo_spread) * scale * srate_scale)|0;
  comb_len_r3 = ((base_comb_3 + stereo_spread) * scale * srate_scale)|0;
  comb_len_r4 = ((base_comb_4 + stereo_spread) * scale * srate_scale)|0;
  comb_len_r5 = ((base_comb_5 + stereo_spread) * scale * srate_scale)|0;
  comb_len_r6 = ((base_comb_6 + stereo_spread) * scale * srate_scale)|0;
  comb_len_r7 = ((base_comb_7 + stereo_spread) * scale * srate_scale)|0;

  ap_len_l0 = (base_ap_0 * srate_scale)|0;
  ap_len_l1 = (base_ap_1 * srate_scale)|0;
  ap_len_l2 = (base_ap_2 * srate_scale)|0;
  ap_len_l3 = (base_ap_3 * srate_scale)|0;
  ap_len_r0 = ((base_ap_0 + 13) * srate_scale)|0;
  ap_len_r1 = ((base_ap_1 + 17) * srate_scale)|0;
  ap_len_r2 = ((base_ap_2 + 11) * srate_scale)|0;
  ap_len_r3 = ((base_ap_3 + 7) * srate_scale)|0;

  // Comb feedback (decay)
  comb_fb = 0.6 + decay * 0.35;

  // Damping coefficient for lowpass in comb feedback
  damp1 = damping * 0.4;
  damp2 = 1 - damp1;

  // Allpass coefficient
  ap_fb = 0.5;

  // Pre-delay samples for each mic
  pd_near = max(1, (2 + predelay_ms * 0.1) * srate / 1000)|0;
  pd_mid = max(1, (10 + predelay_ms * 0.5) * srate / 1000)|0;
  pd_far = max(1, (25 + predelay_ms) * srate / 1000)|0;

  // Compressor smoothing coefficients (optical = slow)
  comp_att = exp(-1 / (0.010 * srate));
  comp_rel = exp(-1 / (0.080 * srate));

  // Mic type EQ setup
  mic_type == 0 ? (
    // U87: presence boost 10kHz, low bump 100Hz
    this.calc_peaking(mic_eq_b1, 10000, 3.0, 0.7);
    this.calc_peaking(mic_eq_b2, 100, 1.5, 0.8);
  ) : mic_type == 1 ? (
    // Ribbon: lowpass 8kHz, midrange warmth 2kHz
    this.calc_lowpass(mic_eq_b1, 8000, 0.7);
    this.calc_peaking(mic_eq_b2, 2000, 2.0, 0.8);
  ) : (
    // 421: mid scoop 400Hz, presence 4kHz
    this.calc_peaking(mic_eq_b1, 400, -3.0, 1.0);
    this.calc_peaking(mic_eq_b2, 4000, 2.0, 1.0);
  );

@sample
  dry_l = spl0;
  dry_r = spl1;
  in_l = spl0;
  in_r = spl1;

  // ==========================================
  // EARLY REFLECTIONS
  // ==========================================
  // Write input to ER delay buffer
  er_buf_l[er_pos] = in_l;
  er_buf_r[er_pos] = in_r;

  er_l = 0;
  er_r = 0;
  i = 0;
  loop(er_tap_count,
    tap_delay = (er_delays_ms[i] * (0.5 + room_size) * srate / 1000)|0;
    tap_delay = min(tap_delay, MAX_BUF - 1);
    read_pos = er_pos - tap_delay;
    read_pos < 0 ? read_pos += MAX_BUF;
    tap_val_l = er_buf_l[read_pos] * er_gains[i];
    tap_val_r = er_buf_r[read_pos] * er_gains[i];
    pan = er_pans[i];
    er_l += tap_val_l * (1 - pan) + tap_val_r * pan;
    er_r += tap_val_r * (1 - pan) + tap_val_l * pan;
    i += 1;
  );
  er_pos = (er_pos + 1) % MAX_BUF;

  // ==========================================
  // LATE REVERB - 8 parallel comb filters
  // ==========================================
  // Comb filter macro - read, lowpass in feedback, write
  // L channel combs
  out_l0 = comb_buf_l0[(comb_pos_l0 - comb_len_l0 + 4096) % 4096];
  comb_lp_l0 = out_l0 * damp2 + comb_lp_l0 * damp1;
  comb_buf_l0[comb_pos_l0] = in_l + comb_lp_l0 * comb_fb;
  comb_pos_l0 = (comb_pos_l0 + 1) % 4096;

  out_l1 = comb_buf_l1[(comb_pos_l1 - comb_len_l1 + 4096) % 4096];
  comb_lp_l1 = out_l1 * damp2 + comb_lp_l1 * damp1;
  comb_buf_l1[comb_pos_l1] = in_l + comb_lp_l1 * comb_fb;
  comb_pos_l1 = (comb_pos_l1 + 1) % 4096;

  out_l2 = comb_buf_l2[(comb_pos_l2 - comb_len_l2 + 4096) % 4096];
  comb_lp_l2 = out_l2 * damp2 + comb_lp_l2 * damp1;
  comb_buf_l2[comb_pos_l2] = in_l + comb_lp_l2 * comb_fb;
  comb_pos_l2 = (comb_pos_l2 + 1) % 4096;

  out_l3 = comb_buf_l3[(comb_pos_l3 - comb_len_l3 + 4096) % 4096];
  comb_lp_l3 = out_l3 * damp2 + comb_lp_l3 * damp1;
  comb_buf_l3[comb_pos_l3] = in_l + comb_lp_l3 * comb_fb;
  comb_pos_l3 = (comb_pos_l3 + 1) % 4096;

  out_l4 = comb_buf_l4[(comb_pos_l4 - comb_len_l4 + 4096) % 4096];
  comb_lp_l4 = out_l4 * damp2 + comb_lp_l4 * damp1;
  comb_buf_l4[comb_pos_l4] = in_l + comb_lp_l4 * comb_fb;
  comb_pos_l4 = (comb_pos_l4 + 1) % 4096;

  out_l5 = comb_buf_l5[(comb_pos_l5 - comb_len_l5 + 4096) % 4096];
  comb_lp_l5 = out_l5 * damp2 + comb_lp_l5 * damp1;
  comb_buf_l5[comb_pos_l5] = in_l + comb_lp_l5 * comb_fb;
  comb_pos_l5 = (comb_pos_l5 + 1) % 4096;

  out_l6 = comb_buf_l6[(comb_pos_l6 - comb_len_l6 + 4096) % 4096];
  comb_lp_l6 = out_l6 * damp2 + comb_lp_l6 * damp1;
  comb_buf_l6[comb_pos_l6] = in_l + comb_lp_l6 * comb_fb;
  comb_pos_l6 = (comb_pos_l6 + 1) % 4096;

  out_l7 = comb_buf_l7[(comb_pos_l7 - comb_len_l7 + 4096) % 4096];
  comb_lp_l7 = out_l7 * damp2 + comb_lp_l7 * damp1;
  comb_buf_l7[comb_pos_l7] = in_l + comb_lp_l7 * comb_fb;
  comb_pos_l7 = (comb_pos_l7 + 1) % 4096;

  late_l = (out_l0 + out_l1 + out_l2 + out_l3 + out_l4 + out_l5 + out_l6 + out_l7) * 0.125;

  // R channel combs
  out_r0 = comb_buf_r0[(comb_pos_r0 - comb_len_r0 + 4096) % 4096];
  comb_lp_r0 = out_r0 * damp2 + comb_lp_r0 * damp1;
  comb_buf_r0[comb_pos_r0] = in_r + comb_lp_r0 * comb_fb;
  comb_pos_r0 = (comb_pos_r0 + 1) % 4096;

  out_r1 = comb_buf_r1[(comb_pos_r1 - comb_len_r1 + 4096) % 4096];
  comb_lp_r1 = out_r1 * damp2 + comb_lp_r1 * damp1;
  comb_buf_r1[comb_pos_r1] = in_r + comb_lp_r1 * comb_fb;
  comb_pos_r1 = (comb_pos_r1 + 1) % 4096;

  out_r2 = comb_buf_r2[(comb_pos_r2 - comb_len_r2 + 4096) % 4096];
  comb_lp_r2 = out_r2 * damp2 + comb_lp_r2 * damp1;
  comb_buf_r2[comb_pos_r2] = in_r + comb_lp_r2 * comb_fb;
  comb_pos_r2 = (comb_pos_r2 + 1) % 4096;

  out_r3 = comb_buf_r3[(comb_pos_r3 - comb_len_r3 + 4096) % 4096];
  comb_lp_r3 = out_r3 * damp2 + comb_lp_r3 * damp1;
  comb_buf_r3[comb_pos_r3] = in_r + comb_lp_r3 * comb_fb;
  comb_pos_r3 = (comb_pos_r3 + 1) % 4096;

  out_r4 = comb_buf_r4[(comb_pos_r4 - comb_len_r4 + 4096) % 4096];
  comb_lp_r4 = out_r4 * damp2 + comb_lp_r4 * damp1;
  comb_buf_r4[comb_pos_r4] = in_r + comb_lp_r4 * comb_fb;
  comb_pos_r4 = (comb_pos_r4 + 1) % 4096;

  out_r5 = comb_buf_r5[(comb_pos_r5 - comb_len_r5 + 4096) % 4096];
  comb_lp_r5 = out_r5 * damp2 + comb_lp_r5 * damp1;
  comb_buf_r5[comb_pos_r5] = in_r + comb_lp_r5 * comb_fb;
  comb_pos_r5 = (comb_pos_r5 + 1) % 4096;

  out_r6 = comb_buf_r6[(comb_pos_r6 - comb_len_r6 + 4096) % 4096];
  comb_lp_r6 = out_r6 * damp2 + comb_lp_r6 * damp1;
  comb_buf_r6[comb_pos_r6] = in_r + comb_lp_r6 * comb_fb;
  comb_pos_r6 = (comb_pos_r6 + 1) % 4096;

  out_r7 = comb_buf_r7[(comb_pos_r7 - comb_len_r7 + 4096) % 4096];
  comb_lp_r7 = out_r7 * damp2 + comb_lp_r7 * damp1;
  comb_buf_r7[comb_pos_r7] = in_r + comb_lp_r7 * comb_fb;
  comb_pos_r7 = (comb_pos_r7 + 1) % 4096;

  late_r = (out_r0 + out_r1 + out_r2 + out_r3 + out_r4 + out_r5 + out_r6 + out_r7) * 0.125;

  // ==========================================
  // ALLPASS DIFFUSION (series, 4 stages)
  // ==========================================
  // L allpass 0
  ap_read = ap_buf_l0[(ap_pos_l0 - ap_len_l0 + 2048) % 2048];
  ap_out = -late_l + ap_read;
  ap_buf_l0[ap_pos_l0] = late_l + ap_read * ap_fb;
  late_l = ap_out;
  ap_pos_l0 = (ap_pos_l0 + 1) % 2048;

  ap_read = ap_buf_l1[(ap_pos_l1 - ap_len_l1 + 2048) % 2048];
  ap_out = -late_l + ap_read;
  ap_buf_l1[ap_pos_l1] = late_l + ap_read * ap_fb;
  late_l = ap_out;
  ap_pos_l1 = (ap_pos_l1 + 1) % 2048;

  ap_read = ap_buf_l2[(ap_pos_l2 - ap_len_l2 + 2048) % 2048];
  ap_out = -late_l + ap_read;
  ap_buf_l2[ap_pos_l2] = late_l + ap_read * ap_fb;
  late_l = ap_out;
  ap_pos_l2 = (ap_pos_l2 + 1) % 2048;

  ap_read = ap_buf_l3[(ap_pos_l3 - ap_len_l3 + 2048) % 2048];
  ap_out = -late_l + ap_read;
  ap_buf_l3[ap_pos_l3] = late_l + ap_read * ap_fb;
  late_l = ap_out;
  ap_pos_l3 = (ap_pos_l3 + 1) % 2048;

  // R allpass
  ap_read = ap_buf_r0[(ap_pos_r0 - ap_len_r0 + 2048) % 2048];
  ap_out = -late_r + ap_read;
  ap_buf_r0[ap_pos_r0] = late_r + ap_read * ap_fb;
  late_r = ap_out;
  ap_pos_r0 = (ap_pos_r0 + 1) % 2048;

  ap_read = ap_buf_r1[(ap_pos_r1 - ap_len_r1 + 2048) % 2048];
  ap_out = -late_r + ap_read;
  ap_buf_r1[ap_pos_r1] = late_r + ap_read * ap_fb;
  late_r = ap_out;
  ap_pos_r1 = (ap_pos_r1 + 1) % 2048;

  ap_read = ap_buf_r2[(ap_pos_r2 - ap_len_r2 + 2048) % 2048];
  ap_out = -late_r + ap_read;
  ap_buf_r2[ap_pos_r2] = late_r + ap_read * ap_fb;
  late_r = ap_out;
  ap_pos_r2 = (ap_pos_r2 + 1) % 2048;

  ap_read = ap_buf_r3[(ap_pos_r3 - ap_len_r3 + 2048) % 2048];
  ap_out = -late_r + ap_read;
  ap_buf_r3[ap_pos_r3] = late_r + ap_read * ap_fb;
  late_r = ap_out;
  ap_pos_r3 = (ap_pos_r3 + 1) % 2048;

  // ==========================================
  // THREE MIC POSITIONS with pre-delay
  // ==========================================
  // Near mic: 80% early, 20% late
  near_raw_l = er_l * 0.8 + late_l * 0.2;
  near_raw_r = er_r * 0.8 + late_r * 0.2;

  // Mid mic: 40% early, 60% late
  mid_raw_l = er_l * 0.4 + late_l * 0.6;
  mid_raw_r = er_r * 0.4 + late_r * 0.6;

  // Far mic: 10% early, 90% late, extra damping via simple lowpass
  far_raw_l = er_l * 0.1 + late_l * 0.9;
  far_raw_r = er_r * 0.1 + late_r * 0.9;

  // Pre-delay for each mic position
  pd_buf_near_l[pd_pos_near] = near_raw_l;
  pd_buf_near_r[pd_pos_near] = near_raw_r;
  near_l = pd_buf_near_l[(pd_pos_near - pd_near + 4800) % 4800];
  near_r = pd_buf_near_r[(pd_pos_near - pd_near + 4800) % 4800];

  pd_buf_mid_l[pd_pos_mid] = mid_raw_l;
  pd_buf_mid_r[pd_pos_mid] = mid_raw_r;
  mid_l = pd_buf_mid_l[(pd_pos_mid - pd_mid + 4800) % 4800];
  mid_r = pd_buf_mid_r[(pd_pos_mid - pd_mid + 4800) % 4800];

  pd_buf_far_l[pd_pos_far] = far_raw_l;
  pd_buf_far_r[pd_pos_far] = far_raw_r;
  far_l = pd_buf_far_l[(pd_pos_far - pd_far + 4800) % 4800];
  far_r = pd_buf_far_r[(pd_pos_far - pd_far + 4800) % 4800];

  pd_pos_near = (pd_pos_near + 1) % 4800;
  pd_pos_mid = (pd_pos_mid + 1) % 4800;
  pd_pos_far = (pd_pos_far + 1) % 4800;

  // Mix the three mics
  rev_l = near_l * near_gain + mid_l * mid_gain + far_l * far_gain;
  rev_r = near_r * near_gain + mid_r * mid_gain + far_r * far_gain;

  // Meters (pre-EQ, pre-comp)
  meter_near = max(meter_near * meter_smooth, abs(near_l + near_r) * 0.5 * near_gain);
  meter_mid = max(meter_mid * meter_smooth, abs(mid_l + mid_r) * 0.5 * mid_gain);
  meter_far = max(meter_far * meter_smooth, abs(far_l + far_r) * 0.5 * far_gain);

  // ==========================================
  // MIC TYPE EQ COLORING
  // ==========================================
  rev_l = this.apply_eq(mic_eq_b1, rev_l, 5);
  rev_r = this.apply_eq(mic_eq_b1, rev_r, 9);
  rev_l = this.apply_eq(mic_eq_b2, rev_l, 5);
  rev_r = this.apply_eq(mic_eq_b2, rev_r, 9);

  // ==========================================
  // OPTICAL COMPRESSOR (on reverb signal)
  // ==========================================
  comp_amount > 0 ? (
    // RMS envelope follower
    env_in = (rev_l * rev_l + rev_r * rev_r) * 0.5;
    env_in = sqrt(env_in);

    // Smooth envelope (program-dependent: fast attack, slow release)
    env_in > comp_env_l ? (
      comp_env_l += (1 - comp_att) * (env_in - comp_env_l);
    ) : (
      comp_env_l += (1 - comp_rel) * (env_in - comp_env_l);
    );

    // Gain reduction (soft knee optical style)
    comp_env_l > comp_thresh ? (
      // Soft ratio ~3:1
      over = comp_env_l / comp_thresh;
      gr = 1 / (1 + (over - 1) * 0.67);
    ) : (
      gr = 1;
    );

    gr_display = gr_display * 0.99 + gr * 0.01;

    // Parallel compression blend
    comp_l = rev_l * gr;
    comp_r = rev_r * gr;
    rev_l = rev_l * (1 - comp_amount) + comp_l * comp_amount;
    rev_r = rev_r * (1 - comp_amount) + comp_r * comp_amount;
  );

  // Output gain
  rev_l *= out_gain;
  rev_r *= out_gain;

  // Dry/wet mix
  spl0 = dry_l * (1 - dry_wet) + rev_l * dry_wet;
  spl1 = dry_r * (1 - dry_wet) + rev_r * dry_wet;

@gfx 550 280
  // Background - dark concrete/studio vibe
  gfx_r = 0.08; gfx_g = 0.07; gfx_b = 0.06;
  gfx_rect(0, 0, gfx_w, gfx_h);

  // Title bar
  gfx_r = 0.15; gfx_g = 0.12; gfx_b = 0.08;
  gfx_rect(0, 0, gfx_w, 30);

  gfx_r = 0.95; gfx_g = 0.8; gfx_b = 0.4;
  gfx_x = 10; gfx_y = 8;
  gfx_drawstr("SOUND CITY DRUM ROOM");

  // Mic type indicator
  gfx_r = 0.6; gfx_g = 0.5; gfx_b = 0.3;
  gfx_x = gfx_w - 150; gfx_y = 8;
  mic_type == 0 ? gfx_drawstr("[ U87 Condenser ]");
  mic_type == 1 ? gfx_drawstr("[ Ribbon ]");
  mic_type == 2 ? gfx_drawstr("[ 421 Dynamic ]");

  // ==========================================
  // MIC LEVEL METERS
  // ==========================================
  meter_x = 30;
  meter_w = 25;
  meter_top = 50;
  meter_bot = gfx_h - 60;
  meter_ht = meter_bot - meter_top;

  // Near mic meter
  gfx_r = 0.15; gfx_g = 0.13; gfx_b = 0.1;
  gfx_rect(meter_x, meter_top, meter_w, meter_ht);

  fill = min(1, meter_near * 5) * meter_ht;
  meter_near * 5 < 0.6 ? (
    gfx_r = 0.2; gfx_g = 0.7; gfx_b = 0.3;
  ) : meter_near * 5 < 0.85 ? (
    gfx_r = 0.8; gfx_g = 0.7; gfx_b = 0.1;
  ) : (
    gfx_r = 0.9; gfx_g = 0.3; gfx_b = 0.1;
  );
  gfx_rect(meter_x, meter_bot - fill, meter_w, fill);
  gfx_r = 0.5; gfx_g = 0.4; gfx_b = 0.3;
  gfx_x = meter_x; gfx_y = meter_bot + 5;
  gfx_drawstr("NEAR");

  // Mid mic meter
  meter_x += 50;
  gfx_r = 0.15; gfx_g = 0.13; gfx_b = 0.1;
  gfx_rect(meter_x, meter_top, meter_w, meter_ht);

  fill = min(1, meter_mid * 5) * meter_ht;
  meter_mid * 5 < 0.6 ? (
    gfx_r = 0.2; gfx_g = 0.7; gfx_b = 0.3;
  ) : meter_mid * 5 < 0.85 ? (
    gfx_r = 0.8; gfx_g = 0.7; gfx_b = 0.1;
  ) : (
    gfx_r = 0.9; gfx_g = 0.3; gfx_b = 0.1;
  );
  gfx_rect(meter_x, meter_bot - fill, meter_w, fill);
  gfx_r = 0.5; gfx_g = 0.4; gfx_b = 0.3;
  gfx_x = meter_x + 2; gfx_y = meter_bot + 5;
  gfx_drawstr("MID");

  // Far mic meter
  meter_x += 50;
  gfx_r = 0.15; gfx_g = 0.13; gfx_b = 0.1;
  gfx_rect(meter_x, meter_top, meter_w, meter_ht);

  fill = min(1, meter_far * 5) * meter_ht;
  meter_far * 5 < 0.6 ? (
    gfx_r = 0.2; gfx_g = 0.7; gfx_b = 0.3;
  ) : meter_far * 5 < 0.85 ? (
    gfx_r = 0.8; gfx_g = 0.7; gfx_b = 0.1;
  ) : (
    gfx_r = 0.9; gfx_g = 0.3; gfx_b = 0.1;
  );
  gfx_rect(meter_x, meter_bot - fill, meter_w, fill);
  gfx_r = 0.5; gfx_g = 0.4; gfx_b = 0.3;
  gfx_x = meter_x + 2; gfx_y = meter_bot + 5;
  gfx_drawstr("FAR");

  // ==========================================
  // ROOM VISUALIZATION
  // ==========================================
  room_cx = gfx_w * 0.52;
  room_cy = gfx_h * 0.48;
  room_w = 120 + room_size * 80;
  room_h = 80 + room_size * 60;

  // Room outline
  gfx_r = 0.3; gfx_g = 0.25; gfx_b = 0.15;
  gfx_line(room_cx - room_w/2, room_cy - room_h/2, room_cx + room_w/2, room_cy - room_h/2);
  gfx_line(room_cx + room_w/2, room_cy - room_h/2, room_cx + room_w/2, room_cy + room_h/2);
  gfx_line(room_cx + room_w/2, room_cy + room_h/2, room_cx - room_w/2, room_cy + room_h/2);
  gfx_line(room_cx - room_w/2, room_cy + room_h/2, room_cx - room_w/2, room_cy - room_h/2);

  // Drum kit icon (center of room)
  gfx_r = 0.5; gfx_g = 0.4; gfx_b = 0.2;
  gfx_circle(room_cx, room_cy, 8, 0);
  gfx_circle(room_cx - 12, room_cy + 5, 5, 0);
  gfx_circle(room_cx + 12, room_cy + 5, 5, 0);

  // Mic position dots
  // Near (close to kit)
  near_gain > 0 ? (
    gfx_r = 0.2; gfx_g = 0.8; gfx_b = 0.3;
    gfx_circle(room_cx, room_cy - 20, 4, 1);
  );
  // Mid
  mid_gain > 0 ? (
    gfx_r = 0.8; gfx_g = 0.7; gfx_b = 0.1;
    gfx_circle(room_cx + room_w * 0.25, room_cy - room_h * 0.3, 4, 1);
  );
  // Far (near wall)
  far_gain > 0 ? (
    gfx_r = 0.9; gfx_g = 0.3; gfx_b = 0.1;
    gfx_circle(room_cx + room_w * 0.43, room_cy - room_h * 0.43, 4, 1);
  );

  // ==========================================
  // COMPRESSOR GR METER
  // ==========================================
  gr_x = gfx_w - 50;
  gfx_r = 0.15; gfx_g = 0.13; gfx_b = 0.1;
  gfx_rect(gr_x, meter_top, meter_w, meter_ht);

  // GR fill (inverted - more reduction = more fill from top)
  gr_amount = max(0, min(1, 1 - gr_display));
  gr_fill = gr_amount * meter_ht;
  gfx_r = 0.8; gfx_g = 0.2; gfx_b = 0.2;
  gfx_rect(gr_x, meter_top, meter_w, gr_fill);

  gfx_r = 0.5; gfx_g = 0.4; gfx_b = 0.3;
  gfx_x = gr_x + 4; gfx_y = meter_bot + 5;
  gfx_drawstr("GR");

  // GR dB readout
  gr_db = 20 * log10(max(0.001, gr_display));
  gfx_x = gr_x - 8; gfx_y = meter_top - 15;
  gfx_r = 0.8; gfx_g = 0.4; gfx_b = 0.2;
  sprintf(#gr_str, "%.1fdB", gr_db);
  gfx_drawstr(#gr_str);

  // Room size label
  gfx_r = 0.4; gfx_g = 0.35; gfx_b = 0.25;
  gfx_x = room_cx - 25; gfx_y = room_cy + room_h/2 + 10;
  sprintf(#room_str, "Room: %d%%", slider1|0);
  gfx_drawstr(#room_str);

  // Decay label
  gfx_x = room_cx - 25; gfx_y = room_cy + room_h/2 + 25;
  sprintf(#decay_str, "Decay: %d%%", slider2|0);
  gfx_drawstr(#decay_str);
