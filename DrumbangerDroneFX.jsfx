desc:LMS DroneFX
//author: LMS
//version: 1.0
//license: GPL-3.0
//
// Audio FX satellite for DrumBanger.
// Put this AFTER a synth/instrument on the same track.
// DrumBanger pad triggers drive:
//   - FET compressor (sidechain ducking from pad hits)
//   - Tape delay (wow/flutter, saturation in feedback)
//   - Flanger (exaggerated, deep, Maschine-style)
// All DSP in-house from the LMS suite.

options:gmem=DrumBanger

// ============================================================
// SLIDERS
// ============================================================

// -- Trigger Source --
slider1:0<0,16,1{All Pads,Pad 1,Pad 2,Pad 3,Pad 4,Pad 5,Pad 6,Pad 7,Pad 8,Pad 9,Pad 10,Pad 11,Pad 12,Pad 13,Pad 14,Pad 15,Pad 16}>Trigger Source

// -- FET Compressor (sidechain duck) --
slider2:0<0,1,1{Off,On}>Compressor
slider3:50<0,100,1>Threshold
slider4:60<0,100,1>Ratio
slider5:5<0,100,1>Attack (ms)
slider6:150<10,1000,1>Release (ms)
slider7:50<0,100,1>Duck Depth

// -- Tape Delay --
slider8:0<0,1,1{Off,On}>Delay
slider9:300<1,1000,1>Delay Time (ms)
slider10:45<0,90,1>Feedback (%)
slider11:50<0,100,1>Delay Mix (%)
slider12:30<0,100,1>Tape Age
slider13:40<0,100,1>Wow/Flutter

// -- Flanger --
slider14:0<0,1,1{Off,On}>Flanger
slider15:0.4<0.05,5,0.01>Flanger Rate (Hz)
slider16:70<0,100,1>Flanger Depth
slider17:60<0,100,1>Flanger Feedback
slider18:50<0,100,1>Flanger Mix (%)

// -- Master --
slider19:0<-24,24,0.1>Output (dB)

// -- Mode: Follow (live from DrumBanger) or Lock (captured pattern) --
slider20:0<0,8,1{Follow,Lock 1,Lock 2,Lock 3,Lock 4,Lock 5,Lock 6,Lock 7,Lock 8}>Mode

// -- Mod Targets: which parameter each effect modulates from pattern velocity --
slider21:0<0,3,1{None,Duck Depth,Threshold,Ratio}>Comp Mod
slider22:0<0,4,1{None,Mix,Feedback,Wow/Flutter,Speed}>Delay Mod
slider23:0<0,3,1{None,Depth,Rate,Mix}>Flanger Mod

in_pin:Left
in_pin:Right
out_pin:Left
out_pin:Right

@init

// ============================================================
//  MEMORY
// ============================================================

// Delay buffer — 2 seconds max
DELAY_BUF_SIZE = 96000;
DELAY_BUF_L = 0;
DELAY_BUF_R = DELAY_BUF_SIZE;
delay_wpos = 0;
memset(DELAY_BUF_L, 0, DELAY_BUF_SIZE);
memset(DELAY_BUF_R, 0, DELAY_BUF_SIZE);

// Delay feedback filter state
fb_lp_l = 0; fb_lp_r = 0;
fb_l = 0; fb_r = 0;

// Wow/flutter phases
wow_phase = 0;
flutter_phase = 0;

// Flanger buffer — 20ms max
FLANGE_BUF_SIZE = 2048;
FLANGE_BUF_L = DELAY_BUF_R + DELAY_BUF_SIZE + 100;
FLANGE_BUF_R = FLANGE_BUF_L + FLANGE_BUF_SIZE;
flange_wpos = 0;
flange_lfo_phase = 0;
memset(FLANGE_BUF_L, 0, FLANGE_BUF_SIZE);
memset(FLANGE_BUF_R, 0, FLANGE_BUF_SIZE);

// Scope buffer
SCOPE_BUF = FLANGE_BUF_R + FLANGE_BUF_SIZE + 100;
SCOPE_SIZE = 1024;
scope_pos = 0;
memset(SCOPE_BUF, 0, SCOPE_SIZE);

// Lock mode: local pattern storage (8 slots × 16 steps × 16 pads)
NUM_STEPS = 16;
NUM_PADS = 16;
NUM_LOCKS = 8;
LOCAL_PAT = SCOPE_BUF + SCOPE_SIZE + 100;  // 8*16*16 = 2048
LOCK_HAS_DATA = LOCAL_PAT + NUM_LOCKS * NUM_STEPS * NUM_PADS;  // 8 flags
memset(LOCAL_PAT, 0, NUM_LOCKS * NUM_STEPS * NUM_PADS);
memset(LOCK_HAS_DATA, 0, NUM_LOCKS);

// Mod range floor values (10 total)
// Index: 0=comp_duck, 1=comp_thresh, 2=comp_ratio
//        3=delay_mix, 4=delay_fb, 5=delay_wf, 6=delay_speed
//        7=flange_depth, 8=flange_rate, 9=flange_mix
NUM_MOD_FLOORS = 10;
MOD_FLOOR = LOCK_HAS_DATA + NUM_LOCKS;
memset(MOD_FLOOR, 0, NUM_MOD_FLOORS);

// Lock mode state
prev_mode = -1;         // detect mode changes
lock_seq_step = 0;      // local sequencer step for locked pattern playback
lock_seq_prev_step = -1;

// Mod targets
comp_mod_target = 0;
delay_mod_target = 0;
flanger_mod_target = 0;

// FET compressor state
comp_env = 0;
comp_gain = 1;
comp_gr_display = 0;

// DrumBanger state
db_connected = 0;
db_timeout = 0;
last_heartbeat = 0;
db_step = 0;
db_steps = 16;
db_playing = 0;
db_pattern = 0;
trig_env = 0;       // trigger envelope for comp sidechain
trig_active = 0;

// DC blocker
dc_l_x1 = 0; dc_l_y1 = 0;
dc_r_x1 = 0; dc_r_y1 = 0;

// ============================================================
//  DSP FUNCTIONS — all in-house from LMS suite
// ============================================================

function fast_tanh(x)
  local(e2x)
(
  x > 10 ? 1 : x < -10 ? -1 : (
    e2x = exp(2 * x);
    (e2x - 1) / (e2x + 1);
  );
);

function tape_sat(x, amount)
  local(b)
(
  b = x * (1 + amount * 1.5);
  b = (2 / $pi) * atan(b * $pi * 0.5);
  b;
);

function buf_read_cubic(buf, pos, bmax)
  local(p0, p1, p2, p3, x0, x1, x2, x3, a, b, c, d, frac, idx)
(
  idx = floor(pos);
  frac = pos - idx;

  p0 = idx - 1; p0 < 0 ? p0 += bmax;
  p1 = idx;     p1 >= bmax ? p1 -= bmax;
  p2 = idx + 1; p2 >= bmax ? p2 -= bmax;
  p3 = idx + 2; p3 >= bmax ? p3 -= bmax;

  x0 = buf[p0]; x1 = buf[p1]; x2 = buf[p2]; x3 = buf[p3];

  a = -0.5*x0 + 1.5*x1 - 1.5*x2 + 0.5*x3;
  b = x0 - 2.5*x1 + 2*x2 - 0.5*x3;
  c = -0.5*x0 + 0.5*x2;
  d = x1;

  ((a * frac + b) * frac + c) * frac + d;
);

// ============================================================
//  LOCK MODE HELPERS
// ============================================================

function get_local_step(slot, step, pad) (
  LOCAL_PAT[slot * 256 + step * 16 + pad];
);

function set_local_step(slot, step, pad, vel) (
  LOCAL_PAT[slot * 256 + step * 16 + pad] = vel;
);

function toggle_local_step(slot, step, pad) local(addr, val) (
  addr = slot * 256 + step * 16 + pad;
  val = LOCAL_PAT[addr];
  val > 0 ? LOCAL_PAT[addr] = 0 : LOCAL_PAT[addr] = 100;
);

// Get step velocity from the active source (follow=gmem, lock=local)
function get_active_step(step, pad) local(src_pat) (
  slider20 == 0 ? (
    src_pat = gmem[13];
    gmem[1000 + src_pat * 1024 + step * 16 + pad];
  ) : (
    get_local_step(slider20 - 1, step, pad);
  );
);

// ============================================================
//  @SLIDER
// ============================================================
@slider

trig_source = slider1;  // 0=all, 1-16=specific pad

comp_on = slider2;
comp_thresh = 1 - slider3 / 100;  // invert: higher slider = lower threshold
comp_ratio = 1 + slider4 / 100 * 19;  // 1:1 to 20:1
comp_att = exp(-1 / (max(0.1, slider5) * 0.001 * srate));
comp_rel = exp(-1 / (slider6 * 0.001 * srate));
duck_depth = slider7 / 100;

delay_on = slider8;
delay_time_ms = slider9;
delay_feedback = slider10 / 100;
delay_mix = slider11 / 100;
tape_age = slider12 / 100;
wf_amount = slider13 / 100;
delay_samples = min(delay_time_ms * 0.001 * srate, DELAY_BUF_SIZE - 1);
// Feedback lowpass: tape eats highs each pass — around 4kHz
fb_lp_coeff = exp(-2 * $pi * 4000 / srate);

flange_on = slider14;
flange_rate = slider15;
flange_depth = slider16 / 100;
flange_fb = slider17 / 100 * 0.95;  // cap at 0.95 for stability
flange_mix = slider18 / 100;

master_vol = 10 ^ (slider19 / 20);

comp_mod_target = slider21;
delay_mod_target = slider22;
flanger_mod_target = slider23;

// Trigger envelope attack/release for sidechain
trig_att = exp(-1 / (0.5 * 0.001 * srate));   // 0.5ms — instant
trig_rel = exp(-1 / (80 * 0.001 * srate));     // 80ms decay

// ============================================================
//  @BLOCK — DrumBanger gmem sync + trigger detection
// ============================================================
@block

// ---- Recalculate effect parameters from sliders (GFX changes don't trigger @slider) ----
trig_source = slider1;
comp_on = slider2;
comp_thresh = 1 - slider3 / 100;
comp_ratio = 1 + slider4 / 100 * 19;
comp_att = exp(-1 / (max(0.1, slider5) * 0.001 * srate));
comp_rel = exp(-1 / (slider6 * 0.001 * srate));
duck_depth = slider7 / 100;
delay_on = slider8;
delay_time_ms = slider9;
delay_feedback = slider10 / 100;
delay_mix = slider11 / 100;
tape_age = slider12 / 100;
wf_amount = slider13 / 100;
delay_samples = min(delay_time_ms * 0.001 * srate, DELAY_BUF_SIZE - 1);
fb_lp_coeff = exp(-2 * $pi * 4000 / srate);
flange_on = slider14;
flange_rate = slider15;
flange_depth = slider16 / 100;
flange_fb = slider17 / 100 * 0.95;
flange_mix = slider18 / 100;
master_vol = 10 ^ (slider19 / 20);
comp_mod_target = slider21;
delay_mod_target = slider22;
flanger_mod_target = slider23;
trig_att = exp(-1 / (0.5 * 0.001 * srate));
trig_rel = exp(-1 / (80 * 0.001 * srate));

// ---- Heartbeat check ----
heartbeat = gmem[10];
heartbeat != last_heartbeat ? (
  last_heartbeat = heartbeat;
  db_connected = 1;
  db_timeout = srate;
);
db_timeout > 0 ? db_timeout -= samplesblock : db_connected = 0;

// ---- Read DrumBanger state ----
db_connected ? (
  db_step = gmem[11];
  db_steps = max(1, gmem[12]);
  db_pattern = gmem[13];
  db_playing = gmem[15];

  // ---- Detect mode change: snapshot on switch to Lock ----
  slider20 != prev_mode ? (
    slider20 > 0 ? (
      lock_slot = slider20 - 1;
      // Only snapshot if the slot is empty
      LOCK_HAS_DATA[lock_slot] == 0 ? (
        src_pat = gmem[13];
        // Clear the slot first
        memset(LOCAL_PAT + lock_slot * 256, 0, 256);
        // Only capture selected pad(s)
        trig_source == 0 ? (
          // All pads: copy everything
          snap_i = 0;
          loop(NUM_STEPS * NUM_PADS,
            LOCAL_PAT[lock_slot * 256 + snap_i] = gmem[1000 + src_pat * 1024 + snap_i];
            snap_i += 1;
          );
        ) : (
          // Single pad: only copy that pad's steps, leave rest zeroed
          snap_pad = trig_source - 1;
          snap_s = 0;
          loop(NUM_STEPS,
            LOCAL_PAT[lock_slot * 256 + snap_s * 16 + snap_pad] = gmem[1000 + src_pat * 1024 + snap_s * 16 + snap_pad];
            snap_s += 1;
          );
        );
        LOCK_HAS_DATA[lock_slot] = 1;
      );
    );
    prev_mode = slider20;
  );

  // ---- Trigger detection ----
  got_trigger = 0;
  trig_vel = 0;

  is_follow = (slider20 == 0);

  is_follow ? (
    // ==== FOLLOW MODE: live triggers from gmem (original behavior) ====
    trig_source == 0 ? (
      // All pads: check if any pad just triggered
      p = 0;
      loop(16,
        tv = gmem[100 + p];
        tv > 0 ? (
          got_trigger = 1;
          trig_vel = max(trig_vel, tv);
          gmem[100 + p] = 0;  // consume
        );
        p += 1;
      );
    ) : (
      // Specific pad
      watch_pad = trig_source - 1;
      tv = gmem[100 + watch_pad];
      tv > 0 ? (
        got_trigger = 1;
        trig_vel = tv;
        gmem[100 + watch_pad] = 0;
      );
    );

    // Check if any watched pad is still active
    any_active = 0;
    trig_source == 0 ? (
      p = 0;
      loop(16, gmem[120 + p] ? any_active = 1; p += 1);
    ) : (
      any_active = gmem[120 + trig_source - 1];
    );
    !any_active ? trig_active = 0;

  ) : (
    // ==== LOCK MODE: triggers from captured pattern via DrumBanger transport ====
    lock_slot = slider20 - 1;
    LOCK_HAS_DATA[lock_slot] && db_playing ? (
      lock_seq_step = db_step;  // follow DrumBanger's step position

      // On step change, check if locked pattern has hits
      lock_seq_step != lock_seq_prev_step ? (
        lock_seq_prev_step = lock_seq_step;

        // Check all pads (or specific pad) in the locked pattern
        trig_source == 0 ? (
          p = 0;
          loop(NUM_PADS,
            tv = get_local_step(lock_slot, lock_seq_step, p);
            tv > 0 ? (
              got_trigger = 1;
              trig_vel = max(trig_vel, tv);
            );
            p += 1;
          );
        ) : (
          watch_pad = trig_source - 1;
          tv = get_local_step(lock_slot, lock_seq_step, watch_pad);
          tv > 0 ? (
            got_trigger = 1;
            trig_vel = tv;
          );
        );
      );
    ) : (
      // Not playing or no data — release trigger
      !db_playing ? (
        lock_seq_prev_step = -1;
        trig_active = 0;
      );
    );
  );

  // Update trigger envelope (both modes)
  // Quantize velocity to 16 equal steps for maximum audible range
  // vel 1-8=step1, 9-16=step2, ... 121-127=step16 → mapped to 1/16..16/16
  got_trigger ? (
    trig_active = 1;
    trig_step = min(16, max(1, ceil(trig_vel / 8)));
    trig_env = trig_step / 16;
  );
);

// ============================================================
//  @SAMPLE — THE FX ENGINE
// ============================================================
@sample

in_l = spl0;
in_r = spl1;

// ---- Shared trigger envelope decay (used by all mod targets) ----
trig_active ? (
  trig_env = trig_env;  // hold while active
) : (
  trig_env *= trig_rel;  // decay
  trig_env < 0.001 ? trig_env = 0;
);

// ============================================================
//  TAPE DELAY — from lms_tape_echo, simplified single-head
// ============================================================

delay_on ? (
  // Modulation: floor + (ceiling - floor) * trig_env. Floors stored in slider units.
  delay_mod_target == 1 ? (
    fl = MOD_FLOOR[3] / 100;  // floor in 0-1
    eff_delay_mix = fl + (delay_mix - fl) * trig_env;
  ) : eff_delay_mix = delay_mix;
  delay_mod_target == 2 ? (
    fl = MOD_FLOOR[4] / 100;
    eff_delay_feedback = fl + (delay_feedback - fl) * trig_env;
  ) : eff_delay_feedback = delay_feedback;
  delay_mod_target == 3 ? (
    fl = MOD_FLOOR[5] / 100;
    eff_wf_amount = fl + (wf_amount - fl) * trig_env;
  ) : eff_wf_amount = wf_amount;
  delay_mod_target == 4 ? (
    fl = min(MOD_FLOOR[6] * 0.001 * srate, DELAY_BUF_SIZE - 1);
    eff_delay_samples = fl + (delay_samples - fl) * trig_env;
  ) : eff_delay_samples = delay_samples;

  // ---- Wow & Flutter ----
  wow_phase += 0.5 / srate;
  wow_phase >= 1 ? wow_phase -= 1;
  flutter_phase += 6.3 / srate;
  flutter_phase >= 1 ? flutter_phase -= 1;

  // Wow: triangle wave for natural drift
  wow_val = wow_phase < 0.5 ? (wow_phase * 4 - 1) : (3 - wow_phase * 4);
  // Flutter: sine
  flutter_val = sin(2 * $pi * flutter_phase);

  total_mod = (wow_val * 3.0 + flutter_val * 0.5) * eff_wf_amount * srate / 1000;

  // ---- Write: input + feedback with tape saturation ----
  tape_in_l = in_l + fb_l * eff_delay_feedback;
  tape_in_r = in_r + fb_r * eff_delay_feedback;

  // Tape saturation in the write path
  tape_age > 0.01 ? (
    tape_in_l = tape_sat(tape_in_l, tape_age);
    tape_in_r = tape_sat(tape_in_r, tape_age);
  );

  DELAY_BUF_L[delay_wpos] = tape_in_l;
  DELAY_BUF_R[delay_wpos] = tape_in_r;

  // ---- Read with wow/flutter modulation ----
  rd = delay_wpos - eff_delay_samples - total_mod;
  rd < 0 ? rd += DELAY_BUF_SIZE;
  rd >= DELAY_BUF_SIZE ? rd -= DELAY_BUF_SIZE;

  wet_l = buf_read_cubic(DELAY_BUF_L, rd, DELAY_BUF_SIZE);
  wet_r = buf_read_cubic(DELAY_BUF_R, rd, DELAY_BUF_SIZE);

  // ---- Feedback lowpass: tape eats highs each pass ----
  fb_lp_l = fb_lp_l * fb_lp_coeff + wet_l * (1 - fb_lp_coeff);
  fb_lp_r = fb_lp_r * fb_lp_coeff + wet_r * (1 - fb_lp_coeff);
  fb_l = fb_lp_l;
  fb_r = fb_lp_r;

  // ---- Mix ----
  in_l = in_l * (1 - eff_delay_mix) + wet_l * eff_delay_mix;
  in_r = in_r * (1 - eff_delay_mix) + wet_r * eff_delay_mix;

  delay_wpos += 1;
  delay_wpos >= DELAY_BUF_SIZE ? delay_wpos = 0;
);

// ============================================================
//  FLANGER — deep, exaggerated, Maschine-style
// ============================================================
//
// Through-zero capable, high feedback, wide stereo spread.
// LFO sweeps delay from ~0.2ms to ~7ms for maximum jet effect.
// Feedback runs through tanh for warm self-oscillation at high settings.

flange_on ? (
  // Modulation: floor + (ceiling - floor) * trig_env
  flanger_mod_target == 1 ? (
    fl = MOD_FLOOR[7] / 100;
    eff_flange_depth = fl + (flange_depth - fl) * trig_env;
  ) : eff_flange_depth = flange_depth;
  flanger_mod_target == 2 ? (
    fl = MOD_FLOOR[8];  // rate is in Hz, slider units = Hz
    eff_flange_rate = fl + (flange_rate - fl) * trig_env;
  ) : eff_flange_rate = flange_rate;
  flanger_mod_target == 3 ? (
    fl = MOD_FLOOR[9] / 100;
    eff_flange_mix = fl + (flange_mix - fl) * trig_env;
  ) : eff_flange_mix = flange_mix;

  // Write to flange buffer
  FLANGE_BUF_L[flange_wpos] = in_l + flange_fb_l * flange_fb;
  FLANGE_BUF_R[flange_wpos] = in_r + flange_fb_r * flange_fb;

  // LFO — triangle for smooth sweep
  flange_lfo_phase += eff_flange_rate / srate;
  flange_lfo_phase >= 1 ? flange_lfo_phase -= 1;
  flange_lfo = flange_lfo_phase < 0.5 ? (flange_lfo_phase * 4 - 1) : (3 - flange_lfo_phase * 4);

  // Delay range: 0.2ms to 7ms — wide sweep for jet sound
  base_delay = 0.002 * srate;       // 2ms center
  mod_range = 0.005 * srate;        // ±5ms sweep at full depth

  // Stereo: L and R slightly offset for width
  delay_l = base_delay + flange_lfo * mod_range * eff_flange_depth;
  delay_r = base_delay - flange_lfo * mod_range * eff_flange_depth * 0.85;  // slightly asymmetric

  delay_l = max(1, min(delay_l, FLANGE_BUF_SIZE - 2));
  delay_r = max(1, min(delay_r, FLANGE_BUF_SIZE - 2));

  rd_l = flange_wpos - delay_l;
  rd_r = flange_wpos - delay_r;
  rd_l < 0 ? rd_l += FLANGE_BUF_SIZE;
  rd_r < 0 ? rd_r += FLANGE_BUF_SIZE;

  fl_out_l = buf_read_cubic(FLANGE_BUF_L, rd_l, FLANGE_BUF_SIZE);
  fl_out_r = buf_read_cubic(FLANGE_BUF_R, rd_r, FLANGE_BUF_SIZE);

  // Feedback through tanh for warm self-oscillation
  flange_fb_l = fast_tanh(fl_out_l);
  flange_fb_r = fast_tanh(fl_out_r);

  // Mix — heavy mix for exaggerated effect
  in_l = in_l * (1 - eff_flange_mix) + fl_out_l * eff_flange_mix;
  in_r = in_r * (1 - eff_flange_mix) + fl_out_r * eff_flange_mix;

  flange_wpos += 1;
  flange_wpos >= FLANGE_BUF_SIZE ? flange_wpos = 0;
);

// ============================================================
//  FET COMPRESSOR — sidechain or output mode
// ============================================================
//
// comp_mod_target: 0=None (normal comp on audio), 1=Duck Depth,
//                  2=Threshold, 3=Ratio (modulated by pattern velocity)

comp_on ? (
  // Determine sidechain level and effective parameters based on mod target
  // Floor values: 0=duck, 1=thresh, 2=ratio (in slider units)
  comp_mod_target == 0 ? (
    // OUTPUT MODE: normal compressor on audio signal
    sc_level = max(abs(in_l), abs(in_r));
    eff_thresh = comp_thresh;
    eff_ratio = comp_ratio;
  ) : comp_mod_target == 1 ? (
    // SIDECHAIN: Duck Depth modulated by velocity (floor to ceiling)
    fl = MOD_FLOOR[0] / 100;
    sc_level = (fl + (duck_depth - fl) * trig_env);
    eff_thresh = comp_thresh;
    eff_ratio = comp_ratio;
  ) : comp_mod_target == 2 ? (
    // SIDECHAIN: Threshold modulated (floor to ceiling mapped)
    sc_level = trig_env * duck_depth;
    fl_thresh = 1 - MOD_FLOOR[1] / 100;  // floor thresh in DSP units (inverted)
    eff_thresh = fl_thresh + (comp_thresh - fl_thresh) * trig_env;
    eff_ratio = comp_ratio;
  ) : (
    // SIDECHAIN: Ratio modulated (floor to ceiling)
    sc_level = trig_env * duck_depth;
    eff_thresh = comp_thresh;
    fl_ratio = 1 + MOD_FLOOR[2] / 100 * 19;  // floor ratio in DSP units
    eff_ratio = fl_ratio + (comp_ratio - fl_ratio) * trig_env;
  );

  // FET gain computation
  sc_level > eff_thresh ? (
    over = sc_level - eff_thresh;
    target_gr = eff_thresh + over / eff_ratio;
    comp_target = target_gr / sc_level;
    comp_target = max(0.01, comp_target);
  ) : (
    comp_target = 1;
  );

  // Ballistics: fast attack, slower release (FET style)
  comp_target < comp_gain ? (
    comp_gain = comp_gain * comp_att + comp_target * (1 - comp_att);
  ) : (
    comp_gain = comp_gain * comp_rel + comp_target * (1 - comp_rel);
  );

  // Apply FET gain with soft saturation at extreme reduction
  fet_gain = comp_gain;
  comp_gain < 0.5 ? (
    in_l = fast_tanh(in_l * 1.2) * fet_gain;
    in_r = fast_tanh(in_r * 1.2) * fet_gain;
  ) : (
    in_l *= fet_gain;
    in_r *= fet_gain;
  );

  // Store GR for display (in dB)
  comp_gr_display = comp_gain < 0.999 ? -20 * log10(max(0.001, comp_gain)) : 0;
);

// ============================================================
//  DC BLOCKER
// ============================================================
dc_coeff = 0.995;
dc_out_l = in_l - dc_l_x1 + dc_coeff * dc_l_y1;
dc_l_x1 = in_l; dc_l_y1 = dc_out_l;
dc_out_r = in_r - dc_r_x1 + dc_coeff * dc_r_y1;
dc_r_x1 = in_r; dc_r_y1 = dc_out_r;
in_l = dc_out_l;
in_r = dc_out_r;

// ============================================================
//  MASTER OUTPUT
// ============================================================
in_l *= master_vol;
in_r *= master_vol;

// Scope
SCOPE_BUF[scope_pos] = (in_l + in_r) * 0.5;
scope_pos += 1;
scope_pos >= SCOPE_SIZE ? scope_pos = 0;

spl0 = in_l;
spl1 = in_r;


// ============================================================
//  @GFX
// ============================================================
@gfx 680 490

// ---- Colors ----
COL_BG_R = 0.05; COL_BG_G = 0.05; COL_BG_B = 0.07;
COL_PANEL_R = 0.08; COL_PANEL_G = 0.08; COL_PANEL_B = 0.11;
COL_PANEL_HI_R = 0.12; COL_PANEL_HI_G = 0.12; COL_PANEL_HI_B = 0.16;
COL_BORDER_R = 0.20; COL_BORDER_G = 0.20; COL_BORDER_B = 0.25;
COL_TITLE_R = 0.95; COL_TITLE_G = 0.78; COL_TITLE_B = 0.35;
COL_SEC_R = 0.55; COL_SEC_G = 0.50; COL_SEC_B = 0.40;
COL_TEXT_R = 0.78; COL_TEXT_G = 0.78; COL_TEXT_B = 0.82;
COL_DIM_R = 0.38; COL_DIM_G = 0.38; COL_DIM_B = 0.42;
COL_ACCENT_R = 0.95; COL_ACCENT_G = 0.45; COL_ACCENT_B = 0.15;
COL_GREEN_R = 0.25; COL_GREEN_G = 0.80; COL_GREEN_B = 0.50;
COL_CYAN_R = 0.20; COL_CYAN_G = 0.60; COL_CYAN_B = 0.85;
COL_BAR_BG_R = 0.12; COL_BAR_BG_G = 0.12; COL_BAR_BG_B = 0.16;

// Background
gfx_r = COL_BG_R; gfx_g = COL_BG_G; gfx_b = COL_BG_B;
gfx_rect(0, 0, gfx_w, gfx_h);

// Header band
gfx_r = 0.03; gfx_g = 0.03; gfx_b = 0.05;
gfx_rect(0, 0, gfx_w, 52);
gfx_r = COL_ACCENT_R * 0.6; gfx_g = COL_ACCENT_G * 0.6; gfx_b = COL_ACCENT_B * 0.6;
gfx_rect(0, 52, gfx_w, 2);

// ============================================================
//  HELPERS
// ============================================================

function draw_bar(bx, by, bw, bh, val, vmin, vmax, label, show_val) (
  gfx_r = COL_BAR_BG_R; gfx_g = COL_BAR_BG_G; gfx_b = COL_BAR_BG_B;
  gfx_rect(bx, by, bw, bh);
  norm = (val - vmin) / (vmax - vmin);
  norm = max(0, min(1, norm));
  fill_w = norm * bw;
  fill_w > 0 ? (
    gfx_r = COL_CYAN_R * 0.6; gfx_g = COL_CYAN_G * 0.6; gfx_b = COL_CYAN_B * 0.6;
    gfx_rect(bx, by, fill_w, bh);
    gfx_r = COL_CYAN_R * 0.8; gfx_g = COL_CYAN_G * 0.8; gfx_b = COL_CYAN_B * 0.8;
    gfx_rect(bx, by, fill_w, floor(bh/2));
    gfx_r = COL_CYAN_R; gfx_g = COL_CYAN_G; gfx_b = COL_CYAN_B;
    gfx_rect(bx, by, fill_w, 1);
  );
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_rect(bx, by, bw, 1); gfx_rect(bx, by+bh-1, bw, 1);
  gfx_rect(bx, by, 1, bh); gfx_rect(bx+bw-1, by, 1, bh);
  gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
  gfx_setfont(1, "Arial", 12);
  gfx_x = bx + 5; gfx_y = by + floor((bh - 12)/2);
  gfx_drawstr(label);
  show_val ? (
    gfx_setfont(1, "Arial", 11);
    gfx_x = bx + bw - 40; gfx_y = by + floor((bh - 11)/2);
    gfx_drawnumber(val, val == floor(val) ? 0 : 1);
  );
  mouse_cap & 1 ? (
    mouse_x >= bx && mouse_x <= bx + bw &&
    mouse_y >= by && mouse_y <= by + bh ? (
      new_norm = (mouse_x - bx) / bw;
      new_norm = max(0, min(1, new_norm));
      val = vmin + new_norm * (vmax - vmin);
    );
  );
  val;
);

function draw_panel(px, py, pw, ph, title) (
  gfx_r = COL_PANEL_R; gfx_g = COL_PANEL_G; gfx_b = COL_PANEL_B;
  gfx_rect(px, py, pw, ph);
  gfx_r = COL_PANEL_HI_R; gfx_g = COL_PANEL_HI_G; gfx_b = COL_PANEL_HI_B;
  gfx_rect(px, py, pw, 22);
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_rect(px, py+22, pw, 1);
  gfx_r = COL_BORDER_R*0.7; gfx_g = COL_BORDER_G*0.7; gfx_b = COL_BORDER_B*0.7;
  gfx_rect(px, py, pw, 1); gfx_rect(px, py, 1, ph);
  gfx_rect(px+pw-1, py, 1, ph); gfx_rect(px, py+ph-1, pw, 1);
  gfx_r = COL_SEC_R; gfx_g = COL_SEC_G; gfx_b = COL_SEC_B;
  gfx_setfont(1, "Arial", 12);
  gfx_x = px + 8; gfx_y = py + 4;
  gfx_drawstr(title);
);

function draw_toggle(tx, ty, is_on, label) (
  gfx_r = COL_BORDER_R; gfx_g = COL_BORDER_G; gfx_b = COL_BORDER_B;
  gfx_circle(tx + 8, ty + 8, 7, 0);
  is_on ? (
    gfx_r = COL_GREEN_R; gfx_g = COL_GREEN_G; gfx_b = COL_GREEN_B;
    gfx_circle(tx + 8, ty + 8, 5, 1);
  ) : (
    gfx_r = 0.15; gfx_g = 0.15; gfx_b = 0.18;
    gfx_circle(tx + 8, ty + 8, 5, 1);
  );
  gfx_r = is_on ? COL_TEXT_R : COL_DIM_R;
  gfx_g = is_on ? COL_TEXT_G : COL_DIM_G;
  gfx_b = is_on ? COL_TEXT_B : COL_DIM_B;
  gfx_setfont(1, "Arial", 11);
  gfx_x = tx + 20; gfx_y = ty + 1;
  gfx_drawstr(label);
  (mouse_cap & 1) && !(last_cap & 1) &&
    mouse_x >= tx && mouse_x <= tx + 90 &&
    mouse_y >= ty && mouse_y <= ty + 16 ? (
      is_on = 1 - is_on;
  );
  is_on;
);

// Mod floor marker: draws red floor/ceiling lines on a modulated bar, handles right-click drag for floor.
// Returns the new floor value (in slider units). Pass floor_idx = MOD_FLOOR index.
function draw_mod_range(bx, by, bw, bh, slider_val, vmin, vmax, floor_idx, env) local(fl_val, fl_norm, ceil_norm, eff_norm) (
  fl_val = MOD_FLOOR[floor_idx];
  // Clamp floor to not exceed slider value (ceiling), persist the clamp
  fl_val = max(vmin, min(fl_val, slider_val));
  MOD_FLOOR[floor_idx] = fl_val;
  fl_norm = (fl_val - vmin) / (vmax - vmin);
  fl_norm = max(0, min(1, fl_norm));
  ceil_norm = (slider_val - vmin) / (vmax - vmin);
  ceil_norm = max(0, min(1, ceil_norm));

  // Draw red floor line
  gfx_r = 1; gfx_g = 0.2; gfx_b = 0.2;
  gfx_rect(bx + fl_norm * bw, by, 2, bh);

  // Draw red ceiling line
  gfx_rect(bx + ceil_norm * bw, by, 2, bh);

  // Draw effective value marker (yellow) between floor and ceiling
  eff_norm = fl_norm + (ceil_norm - fl_norm) * env;
  gfx_r = 1; gfx_g = 0.8; gfx_b = 0;
  gfx_rect(bx + eff_norm * bw, by, 2, bh);

  // Right-click drag sets the floor value
  mouse_cap & 2 ? (
    mouse_x >= bx && mouse_x <= bx + bw &&
    mouse_y >= by && mouse_y <= by + bh ? (
      new_norm = (mouse_x - bx) / bw;
      new_norm = max(0, min(1, new_norm));
      fl_val = vmin + new_norm * (vmax - vmin);
      fl_val = min(fl_val, slider_val);
      MOD_FLOOR[floor_idx] = fl_val;
    );
  );
);

// Mod target selector: click to cycle through options
// Returns new value. Labels are up to 5 strings for options 0-4.
function draw_mod_selector(sx, sy, sw, sh, cur, nmax, l0, l1, l2, l3, l4) (
  // Background
  cur > 0 ? (
    gfx_r = COL_ACCENT_R * 0.2; gfx_g = COL_ACCENT_G * 0.2; gfx_b = COL_ACCENT_B * 0.2;
  ) : (
    gfx_r = 0.06; gfx_g = 0.06; gfx_b = 0.08;
  );
  gfx_rect(sx, sy, sw, sh);

  // Border
  cur > 0 ? (
    gfx_r = COL_ACCENT_R * 0.5; gfx_g = COL_ACCENT_G * 0.5; gfx_b = COL_ACCENT_B * 0.5;
  ) : (
    gfx_r = COL_BORDER_R * 0.6; gfx_g = COL_BORDER_G * 0.6; gfx_b = COL_BORDER_B * 0.6;
  );
  gfx_rect(sx, sy, sw, 1); gfx_rect(sx, sy+sh-1, sw, 1);
  gfx_rect(sx, sy, 1, sh); gfx_rect(sx+sw-1, sy, 1, sh);

  // Label text
  cur > 0 ? (
    gfx_r = COL_ACCENT_R; gfx_g = COL_ACCENT_G; gfx_b = COL_ACCENT_B;
  ) : (
    gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
  );
  gfx_setfont(1, "Arial", 10);
  gfx_x = sx + 4; gfx_y = sy + 2;
  gfx_drawstr("MOD: ");
  cur == 0 ? gfx_drawstr(l0);
  cur == 1 ? gfx_drawstr(l1);
  cur == 2 ? gfx_drawstr(l2);
  cur == 3 ? gfx_drawstr(l3);
  cur == 4 ? gfx_drawstr(l4);

  // Click to cycle (left=forward, right=backward)
  (mouse_cap & 1) && !(last_cap & 1) &&
    mouse_x >= sx && mouse_x < sx + sw &&
    mouse_y >= sy && mouse_y < sy + sh ? (
    cur += 1;
    cur > nmax ? cur = 0;
  );
  (mouse_cap & 2) && !(last_cap & 2) &&
    mouse_x >= sx && mouse_x < sx + sw &&
    mouse_y >= sy && mouse_y < sy + sh ? (
    cur -= 1;
    cur < 0 ? cur = nmax;
  );
  cur;
);

// ============================================================
//  TITLE + MODE INDICATOR
// ============================================================
gfx_is_follow = (slider20 == 0);
gfx_is_locked = !gfx_is_follow;
gfx_lock_slot = gfx_is_locked ? (slider20 - 1) : 0;

gfx_r = COL_TITLE_R; gfx_g = COL_TITLE_G; gfx_b = COL_TITLE_B;
gfx_setfont(1, "Arial", 20);
gfx_x = 14; gfx_y = 8;
gfx_drawstr("LMS DRONE FX");

// Mode selector (click to cycle: Follow → Lock 1-8)
mode_btn_x = 180; mode_btn_y = 6; mode_btn_w = 100; mode_btn_h = 18;

gfx_setfont(1, "Arial", 13);
gfx_is_follow ? (
  gfx_r = COL_GREEN_R * 0.3; gfx_g = COL_GREEN_G * 0.3; gfx_b = COL_GREEN_B * 0.3;
  gfx_rect(mode_btn_x, mode_btn_y, mode_btn_w, mode_btn_h);
  gfx_r = COL_GREEN_R; gfx_g = COL_GREEN_G; gfx_b = COL_GREEN_B;
  gfx_x = mode_btn_x + 4; gfx_y = mode_btn_y + 2;
  gfx_drawstr("FOLLOW");
) : (
  gfx_r = COL_CYAN_R * 0.3; gfx_g = COL_CYAN_G * 0.3; gfx_b = COL_CYAN_B * 0.3;
  gfx_rect(mode_btn_x, mode_btn_y, mode_btn_w, mode_btn_h);
  gfx_r = COL_CYAN_R; gfx_g = COL_CYAN_G; gfx_b = COL_CYAN_B;
  gfx_x = mode_btn_x + 4; gfx_y = mode_btn_y + 2;
  gfx_drawstr("LOCK ");
  gfx_drawnumber(gfx_lock_slot + 1, 0);
);

// Click mode button to cycle
(mouse_cap & 1) && !(last_cap & 1) &&
  mouse_x >= mode_btn_x && mouse_x < mode_btn_x + mode_btn_w &&
  mouse_y >= mode_btn_y && mouse_y < mode_btn_y + mode_btn_h ? (
  slider20 = slider20 + 1;
  slider20 > 8 ? slider20 = 0;
);

// Trigger Source selector (click to cycle: All → Pad 1-16)
trig_btn_x = mode_btn_x; trig_btn_y = 28; trig_btn_w = 100; trig_btn_h = 16;

gfx_setfont(1, "Arial", 11);
slider1 == 0 ? (
  gfx_r = COL_DIM_R * 0.5; gfx_g = COL_DIM_G * 0.5; gfx_b = COL_DIM_B * 0.5;
  gfx_rect(trig_btn_x, trig_btn_y, trig_btn_w, trig_btn_h);
  gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
  gfx_x = trig_btn_x + 4; gfx_y = trig_btn_y + 2;
  gfx_drawstr("SRC: All Pads");
) : (
  gfx_r = COL_ACCENT_R * 0.25; gfx_g = COL_ACCENT_G * 0.25; gfx_b = COL_ACCENT_B * 0.25;
  gfx_rect(trig_btn_x, trig_btn_y, trig_btn_w, trig_btn_h);
  gfx_r = COL_ACCENT_R; gfx_g = COL_ACCENT_G; gfx_b = COL_ACCENT_B;
  gfx_x = trig_btn_x + 4; gfx_y = trig_btn_y + 2;
  gfx_drawstr("SRC: Pad ");
  gfx_drawnumber(slider1, 0);
);

// Left-click cycles forward, right-click cycles backward
(mouse_cap & 1) && !(last_cap & 1) &&
  mouse_x >= trig_btn_x && mouse_x < trig_btn_x + trig_btn_w &&
  mouse_y >= trig_btn_y && mouse_y < trig_btn_y + trig_btn_h ? (
  slider1 = slider1 + 1;
  slider1 > 16 ? slider1 = 0;
);
(mouse_cap & 2) && !(last_cap & 2) &&
  mouse_x >= trig_btn_x && mouse_x < trig_btn_x + trig_btn_w &&
  mouse_y >= trig_btn_y && mouse_y < trig_btn_y + trig_btn_h ? (
  slider1 = slider1 - 1;
  slider1 < 0 ? slider1 = 16;
);

// Connection indicator
db_connected ? (
  gfx_r = COL_GREEN_R; gfx_g = COL_GREEN_G; gfx_b = COL_GREEN_B;
  gfx_circle(gfx_w - 30, 25, 6, 1);
  gfx_setfont(1, "Arial", 10);
  gfx_x = gfx_w - 95; gfx_y = 20;
  gfx_drawstr("DB LIVE");
) : (
  gfx_r = 0.3; gfx_g = 0.15; gfx_b = 0.15;
  gfx_circle(gfx_w - 30, 25, 6, 1);
  gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
  gfx_setfont(1, "Arial", 10);
  gfx_x = gfx_w - 95; gfx_y = 20;
  gfx_drawstr("DB ---");
);

// ---- RE-CAPTURE and CLEAR buttons (Lock mode only) ----
gfx_is_locked ? (
  recap_btn_w = 90;
  recap_btn_h = 18;
  recap_btn_x = gfx_w - 110;
  recap_btn_y = 35;

  // RE-CAPTURE button
  gfx_r = COL_CYAN_R * 0.4; gfx_g = COL_CYAN_G * 0.4; gfx_b = COL_CYAN_B * 0.4;
  gfx_rect(recap_btn_x, recap_btn_y, recap_btn_w, recap_btn_h);
  gfx_r = COL_CYAN_R * 0.7; gfx_g = COL_CYAN_G * 0.7; gfx_b = COL_CYAN_B * 0.7;
  gfx_rect(recap_btn_x, recap_btn_y, recap_btn_w, 1);
  gfx_rect(recap_btn_x, recap_btn_y, 1, recap_btn_h);
  gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
  gfx_setfont(1, "Arial", 10);
  gfx_x = recap_btn_x + 8; gfx_y = recap_btn_y + 3;
  gfx_drawstr("RE-CAPTURE");

  (mouse_cap & 1) && !(last_cap & 1) &&
    mouse_x >= recap_btn_x && mouse_x < recap_btn_x + recap_btn_w &&
    mouse_y >= recap_btn_y && mouse_y < recap_btn_y + recap_btn_h ? (
    src_pat = gmem[13];
    memset(LOCAL_PAT + gfx_lock_slot * 256, 0, 256);
    slider1 == 0 ? (
      snap_i = 0;
      loop(NUM_STEPS * NUM_PADS,
        LOCAL_PAT[gfx_lock_slot * 256 + snap_i] = gmem[1000 + src_pat * 1024 + snap_i];
        snap_i += 1;
      );
    ) : (
      snap_pad = slider1 - 1;
      snap_s = 0;
      loop(NUM_STEPS,
        LOCAL_PAT[gfx_lock_slot * 256 + snap_s * 16 + snap_pad] = gmem[1000 + src_pat * 1024 + snap_s * 16 + snap_pad];
        snap_s += 1;
      );
    );
    LOCK_HAS_DATA[gfx_lock_slot] = 1;
  );

  // CLEAR button
  clear_btn_w = 50;
  clear_btn_x = recap_btn_x - clear_btn_w - 6;
  clear_btn_y = recap_btn_y;
  clear_btn_h = recap_btn_h;

  gfx_r = 0.3; gfx_g = 0.12; gfx_b = 0.12;
  gfx_rect(clear_btn_x, clear_btn_y, clear_btn_w, clear_btn_h);
  gfx_r = 0.5; gfx_g = 0.2; gfx_b = 0.2;
  gfx_rect(clear_btn_x, clear_btn_y, clear_btn_w, 1);
  gfx_rect(clear_btn_x, clear_btn_y, 1, clear_btn_h);
  gfx_r = COL_TEXT_R; gfx_g = COL_TEXT_G; gfx_b = COL_TEXT_B;
  gfx_setfont(1, "Arial", 10);
  gfx_x = clear_btn_x + 8; gfx_y = clear_btn_y + 3;
  gfx_drawstr("CLEAR");

  (mouse_cap & 1) && !(last_cap & 1) &&
    mouse_x >= clear_btn_x && mouse_x < clear_btn_x + clear_btn_w &&
    mouse_y >= clear_btn_y && mouse_y < clear_btn_y + clear_btn_h ? (
    clr_i = 0;
    loop(NUM_STEPS * NUM_PADS,
      LOCAL_PAT[gfx_lock_slot * 256 + clr_i] = 0;
      clr_i += 1;
    );
    LOCK_HAS_DATA[gfx_lock_slot] = 0;
  );
);

// ============================================================
//  PATTERN DISPLAY — 16-step × 16-pad overview
// ============================================================
pat_y = 58;
pat_h = 96;
cell_w = floor((gfx_w - 20) / 16);
cell_h = floor(pat_h / 16);

// When a specific pad is selected, filter grid to show only that pad's row
gfx_filter_pad = (slider1 > 0) ? (slider1 - 1) : -1;

// Grid
p = 0;
loop(16,
  // Hide non-selected pad rows in Follow mode when a specific pad is chosen
  pad_visible = (gfx_filter_pad < 0 || p == gfx_filter_pad) ? 1 : 0;

  s = 0;
  loop(16,
    cx = 10 + s * cell_w;
    cy = pat_y + p * cell_h;

    pad_visible ? (
      // Get velocity from active source (follow=gmem, lock=local)
      pv = get_active_step(s, p);

      s < db_steps ? (
        pv > 0 ? (
          br = pv / 127;
          gfx_is_locked ? (
            // Cyan tint in lock mode
            gfx_r = COL_CYAN_R * br;
            gfx_g = COL_CYAN_G * br;
            gfx_b = COL_CYAN_B * br;
          ) : (
            gfx_r = COL_ACCENT_R * br;
            gfx_g = COL_ACCENT_G * br;
            gfx_b = COL_ACCENT_B * br;
          );
        ) : (
          gfx_r = 0.06; gfx_g = 0.06; gfx_b = 0.08;
        );
      ) : (
        gfx_r = 0.03; gfx_g = 0.03; gfx_b = 0.04;
      );
    ) : (
      // Hidden row: dark/invisible
      gfx_r = 0.03; gfx_g = 0.03; gfx_b = 0.04;
    );
    gfx_rect(cx, cy, cell_w - 1, cell_h - 1);

    // Current step column highlight (only on visible rows)
    pad_visible && s == db_step && db_playing ? (
      gfx_r = 1; gfx_g = 1; gfx_b = 1; gfx_a = 0.12;
      gfx_rect(cx, cy, cell_w - 1, cell_h - 1);
      gfx_a = 1;
    );

    // Click to toggle step (Lock mode only)
    gfx_is_locked && LOCK_HAS_DATA[gfx_lock_slot] && s < db_steps &&
      (mouse_cap & 1) && !(last_cap & 1) &&
      mouse_x >= cx && mouse_x < cx + cell_w - 1 &&
      mouse_y >= cy && mouse_y < cy + cell_h - 1 ? (
      toggle_local_step(gfx_lock_slot, s, p);
    );

    s += 1;
  );
  p += 1;
);

// Step numbers below pattern
gfx_setfont(1, "Arial", 8);
gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
s = 0;
loop(16,
  s % 4 == 0 ? (
    gfx_x = 10 + s * cell_w + 2; gfx_y = pat_y + pat_h + 2;
    gfx_drawnumber(s + 1, 0);
  );
  s += 1;
);

// ============================================================
//  FX PANELS
// ============================================================
row_y = pat_y + pat_h + 18;
margin = 10;
gap = 6;
bar_h = 18;
bar_sp = 21;
pad = 8;

// ---- FET COMPRESSOR ----
comp_pw = floor((gfx_w - margin * 2 - gap * 2) / 3);
comp_px = margin;
comp_ph = 188;
draw_panel(comp_px, row_y, comp_pw, comp_ph, "FET COMPRESSOR");

cy = row_y + 28;
inner_w = comp_pw - pad * 2;

slider2 = draw_toggle(comp_px + pad, cy, slider2, "COMP ON");
comp_on = slider2;
cy += 20;
slider21 = draw_mod_selector(comp_px + pad, cy, inner_w, 16, slider21, 3, "None", "Duck", "Thresh", "Ratio", "");
comp_mod_target = slider21;
cy += 20;

slider3 = draw_bar(comp_px + pad, cy, inner_w, bar_h, slider3, 0, 100, "THRESH", 1);
comp_mod_target == 2 ? draw_mod_range(comp_px + pad, cy, inner_w, bar_h, slider3, 0, 100, 1, trig_env);
cy += bar_sp;
slider4 = draw_bar(comp_px + pad, cy, inner_w, bar_h, slider4, 0, 100, "RATIO", 1);
comp_mod_target == 3 ? draw_mod_range(comp_px + pad, cy, inner_w, bar_h, slider4, 0, 100, 2, trig_env);
cy += bar_sp;
slider5 = draw_bar(comp_px + pad, cy, inner_w, bar_h, slider5, 0, 100, "ATTACK", 1);
cy += bar_sp;
slider6 = draw_bar(comp_px + pad, cy, inner_w, bar_h, slider6, 10, 1000, "RELEASE", 1);
cy += bar_sp;
slider7 = draw_bar(comp_px + pad, cy, inner_w, bar_h, slider7, 0, 100, "DUCK", 1);
comp_mod_target == 1 ? draw_mod_range(comp_px + pad, cy, inner_w, bar_h, slider7, 0, 100, 0, trig_env);

// GR meter
cy += bar_sp + 2;
gfx_r = COL_DIM_R; gfx_g = COL_DIM_G; gfx_b = COL_DIM_B;
gfx_setfont(1, "Arial", 10);
gfx_x = comp_px + pad; gfx_y = cy;
gfx_drawstr("GR:");
gr_bar_x = comp_px + pad + 28;
gr_bar_w = inner_w - 28;
gfx_r = COL_BAR_BG_R; gfx_g = COL_BAR_BG_G; gfx_b = COL_BAR_BG_B;
gfx_rect(gr_bar_x, cy, gr_bar_w, 10);
gr_fill = min(1, comp_gr_display / 20);
gr_fill > 0 ? (
  gfx_r = COL_ACCENT_R; gfx_g = COL_ACCENT_G * 0.3; gfx_b = 0;
  gfx_rect(gr_bar_x, cy, gr_fill * gr_bar_w, 10);
);

// ---- TAPE DELAY ----
delay_px = comp_px + comp_pw + gap;
delay_pw = comp_pw;
delay_ph = comp_ph;
draw_panel(delay_px, row_y, delay_pw, delay_ph, "TAPE DELAY");

cy = row_y + 28;
inner_w = delay_pw - pad * 2;

slider8 = draw_toggle(delay_px + pad, cy, slider8, "DELAY ON");
delay_on = slider8;
cy += 20;
slider22 = draw_mod_selector(delay_px + pad, cy, inner_w, 16, slider22, 4, "None", "Mix", "Feedback", "Wow/Flt", "Speed");
delay_mod_target = slider22;
cy += 20;

slider9 = draw_bar(delay_px + pad, cy, inner_w, bar_h, slider9, 1, 1000, "TIME ms", 1);
delay_mod_target == 4 ? draw_mod_range(delay_px + pad, cy, inner_w, bar_h, slider9, 1, 1000, 6, trig_env);
cy += bar_sp;
slider10 = draw_bar(delay_px + pad, cy, inner_w, bar_h, slider10, 0, 90, "FEEDBACK", 1);
delay_mod_target == 2 ? draw_mod_range(delay_px + pad, cy, inner_w, bar_h, slider10, 0, 90, 4, trig_env);
cy += bar_sp;
slider11 = draw_bar(delay_px + pad, cy, inner_w, bar_h, slider11, 0, 100, "MIX", 1);
delay_mod_target == 1 ? draw_mod_range(delay_px + pad, cy, inner_w, bar_h, slider11, 0, 100, 3, trig_env);
cy += bar_sp;
slider12 = draw_bar(delay_px + pad, cy, inner_w, bar_h, slider12, 0, 100, "TAPE AGE", 1);
cy += bar_sp;
slider13 = draw_bar(delay_px + pad, cy, inner_w, bar_h, slider13, 0, 100, "WOW/FLT", 1);
delay_mod_target == 3 ? draw_mod_range(delay_px + pad, cy, inner_w, bar_h, slider13, 0, 100, 5, trig_env);

// ---- FLANGER ----
fl_px = delay_px + delay_pw + gap;
fl_pw = gfx_w - fl_px - margin;
fl_ph = comp_ph;
draw_panel(fl_px, row_y, fl_pw, fl_ph, "FLANGER");

cy = row_y + 28;
inner_w = fl_pw - pad * 2;

slider14 = draw_toggle(fl_px + pad, cy, slider14, "FLANGE ON");
flange_on = slider14;
cy += 20;
slider23 = draw_mod_selector(fl_px + pad, cy, inner_w, 16, slider23, 3, "None", "Depth", "Rate", "Mix", "");
flanger_mod_target = slider23;
cy += 20;

slider15 = draw_bar(fl_px + pad, cy, inner_w, bar_h, slider15, 0.05, 5, "RATE Hz", 1);
flanger_mod_target == 2 ? draw_mod_range(fl_px + pad, cy, inner_w, bar_h, slider15, 0.05, 5, 8, trig_env);
cy += bar_sp;
slider16 = draw_bar(fl_px + pad, cy, inner_w, bar_h, slider16, 0, 100, "DEPTH", 1);
flanger_mod_target == 1 ? draw_mod_range(fl_px + pad, cy, inner_w, bar_h, slider16, 0, 100, 7, trig_env);
cy += bar_sp;
slider17 = draw_bar(fl_px + pad, cy, inner_w, bar_h, slider17, 0, 100, "FEEDBACK", 1);
cy += bar_sp;
slider18 = draw_bar(fl_px + pad, cy, inner_w, bar_h, slider18, 0, 100, "MIX", 1);
flanger_mod_target == 3 ? draw_mod_range(fl_px + pad, cy, inner_w, bar_h, slider18, 0, 100, 9, trig_env);

// ---- OUTPUT + SCOPE ----
out_y = row_y + comp_ph + gap;
out_w = gfx_w - margin * 2;
out_h = gfx_h - out_y - margin;

// Scope background
gfx_r = 0.03; gfx_g = 0.03; gfx_b = 0.05;
gfx_rect(margin, out_y, out_w, out_h);
gfx_r = COL_BORDER_R * 0.5; gfx_g = COL_BORDER_G * 0.5; gfx_b = COL_BORDER_B * 0.5;
gfx_rect(margin, out_y, out_w, 1); gfx_rect(margin, out_y + out_h - 1, out_w, 1);
gfx_rect(margin, out_y, 1, out_h); gfx_rect(margin + out_w - 1, out_y, 1, out_h);

// Center line
gfx_r = 0.10; gfx_g = 0.10; gfx_b = 0.14;
gfx_rect(margin + 1, out_y + floor(out_h / 2), out_w - 2, 1);

// Waveform
gfx_r = COL_GREEN_R; gfx_g = COL_GREEN_G; gfx_b = COL_GREEN_B;
scope_step = SCOPE_SIZE / out_w;
i = 0;
loop(out_w - 2,
  idx = floor(i * scope_step);
  idx >= SCOPE_SIZE ? idx = SCOPE_SIZE - 1;
  sv = SCOPE_BUF[(scope_pos + idx) % SCOPE_SIZE];
  sy = out_y + out_h * 0.5 - sv * out_h * 0.4;
  sy = max(out_y + 1, min(out_y + out_h - 2, sy));
  i == 0 ? (
    gfx_x = margin + 1; gfx_y = sy;
  ) : (
    gfx_lineto(margin + 1 + i, sy);
  );
  i += 1;
);

// Master volume bar in scope area
slider19 = draw_bar(margin + out_w - 120, out_y + 4, 116, 16, slider19, -24, 24, "OUTPUT", 1);

// Trigger activity indicator
trig_env > 0.01 ? (
  gfx_r = COL_ACCENT_R; gfx_g = COL_ACCENT_G; gfx_b = COL_ACCENT_B;
  gfx_circle(margin + 14, out_y + 12, 5, 1);
  gfx_setfont(1, "Arial", 10);
  gfx_x = margin + 24; gfx_y = out_y + 6;
  gfx_drawstr("TRIG");
) : (
  gfx_r = COL_DIM_R * 0.5; gfx_g = COL_DIM_G * 0.5; gfx_b = COL_DIM_B * 0.5;
  gfx_circle(margin + 14, out_y + 12, 5, 1);
);

// --- NOTICE BUTTON ---
notice_btn_x = gfx_w - 60;
notice_btn_y = gfx_h - 18;
gfx_r = 0.6; gfx_g = 0.5; gfx_b = 0.3;
gfx_rect(notice_btn_x, notice_btn_y, 55, 15);
gfx_r = 0; gfx_g = 0; gfx_b = 0;
gfx_x = notice_btn_x + 4; gfx_y = notice_btn_y + 2;
gfx_drawstr("NOTICE");
(mouse_cap & 1) && mouse_x >= notice_btn_x && mouse_x <= notice_btn_x + 55 && mouse_y >= notice_btn_y && mouse_y <= notice_btn_y + 15 && !notice_clicked ? (
  notice_show = !notice_show;
  notice_clicked = 1;
);
!(mouse_cap & 1) ? notice_clicked = 0;
notice_show ? (
  gfx_r = 0.05; gfx_g = 0.05; gfx_b = 0.05; gfx_a = 0.95;
  gfx_rect(0, 0, gfx_w, gfx_h);
  gfx_a = 1;
  gfx_setfont(1, "Arial", 10);
  _nx = 15; _ny = 8; _nl = 13;
  gfx_r = 0.9; gfx_g = 0.8; gfx_b = 0.5;
  gfx_x = _nx; gfx_y = _ny;
  gfx_drawstr("NOTICE: THEY ARE TRYING TO STEAL YOUR COMPUTER"); _ny += _nl + 4;
  gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.7;
  gfx_x = _nx; gfx_y = _ny;
  gfx_drawstr("The algorithms in our favorite software are decades old. A mathematical model is a"); _ny += _nl;
  gfx_x = _nx; gfx_y = _ny;
  gfx_drawstr("truth about the world, not a copyrightable product. You do not have to stay a slave"); _ny += _nl;
  gfx_x = _nx; gfx_y = _ny;
  gfx_drawstr("to subscription software. Install Linux. Build your own tools. Believe in yourself."); _ny += _nl + 2;
  gfx_r = 0.5; gfx_g = 0.7; gfx_b = 1.0;
  gfx_x = _nx; gfx_y = _ny;
  gfx_drawstr("github.com/LMSBAND  |  instagram.com/LMSSKABAND"); _ny += _nl + 8;

  gfx_r = 0.9; gfx_g = 0.6; gfx_b = 0.2;
  gfx_x = _nx; gfx_y = _ny;
  gfx_drawstr("DroneFX — Audio Effects Satellite"); _ny += _nl + 2;
  gfx_r = 0.6; gfx_g = 0.6; gfx_b = 0.65;
  gfx_x = _nx; gfx_y = _ny;
  gfx_drawstr("Place AFTER a synth. Chain: Delay > Flanger > Comp > DC Blocker > Output"); _ny += _nl + 2;

  gfx_r = 0.9; gfx_g = 0.6; gfx_b = 0.2;
  gfx_x = _nx; gfx_y = _ny;
  gfx_drawstr("HEADER CONTROLS (click to cycle, right-click = reverse)"); _ny += _nl + 2;
  gfx_r = 0.6; gfx_g = 0.6; gfx_b = 0.65;
  gfx_x = _nx; gfx_y = _ny;
  gfx_drawstr("MODE: Follow (live from DrumBanger) / Lock 1-8 (captured pattern)."); _ny += _nl;
  gfx_x = _nx; gfx_y = _ny;
  gfx_drawstr("  Lock auto-captures on switch. Click grid to edit. RE-CAPTURE / CLEAR buttons."); _ny += _nl;
  gfx_x = _nx; gfx_y = _ny;
  gfx_drawstr("SRC: All Pads or Pad 1-16. Filters which pad drives the sidechain."); _ny += _nl;
  gfx_x = _nx; gfx_y = _ny;
  gfx_drawstr("  In Follow mode, grid hides non-selected pad rows. Lock captures only selected."); _ny += _nl + 2;

  gfx_r = 0.9; gfx_g = 0.6; gfx_b = 0.2;
  gfx_x = _nx; gfx_y = _ny;
  gfx_drawstr("MOD SELECTOR (per effect, click to cycle)"); _ny += _nl + 2;
  gfx_r = 0.6; gfx_g = 0.6; gfx_b = 0.65;
  gfx_x = _nx; gfx_y = _ny;
  gfx_drawstr("MOD: None = normal insert effect. Other options = pattern step modulator."); _ny += _nl;
  gfx_x = _nx; gfx_y = _ny;
  gfx_drawstr("  Left-drag sets ceiling (max). Right-drag sets floor (min). Red lines = range."); _ny += _nl;
  gfx_x = _nx; gfx_y = _ny;
  gfx_drawstr("  Yellow marker = current effective value. Velocity sweeps between floor and ceiling."); _ny += _nl;
  gfx_x = _nx; gfx_y = _ny;
  gfx_drawstr("  Comp: None (normal comp) / Duck / Thresh / Ratio"); _ny += _nl;
  gfx_x = _nx; gfx_y = _ny;
  gfx_drawstr("  Delay: None / Mix / Feedback / Wow/Flutter"); _ny += _nl;
  gfx_x = _nx; gfx_y = _ny;
  gfx_drawstr("  Flanger: None / Depth / Rate / Mix"); _ny += _nl;

  gfx_setfont(1, "Arial", 12);
  gfx_r = 0.6; gfx_g = 0.5; gfx_b = 0.3;
  gfx_rect(notice_btn_x, notice_btn_y, 55, 15);
  gfx_r = 0; gfx_g = 0; gfx_b = 0;
  gfx_x = notice_btn_x + 4; gfx_y = notice_btn_y + 2;
  gfx_drawstr("NOTICE");
);

last_cap = mouse_cap;

// ============================================================
//  @SERIALIZE — save/load lock slot data
// ============================================================
@serialize

// Save/load all 8 lock slots (8 × 16 steps × 16 pads = 2048)
i = 0;
loop(NUM_LOCKS * NUM_STEPS * NUM_PADS,
  file_var(0, LOCAL_PAT[i]);
  i += 1;
);

// Save/load lock-has-data flags
i = 0;
loop(NUM_LOCKS,
  file_var(0, LOCK_HAS_DATA[i]);
  i += 1;
);

// Save/load prev_mode so mode-change detection doesn't re-trigger on reload
file_var(0, prev_mode);

// Save/load mod range floor values
i = 0;
loop(NUM_MOD_FLOORS,
  file_var(0, MOD_FLOOR[i]);
  i += 1;
);
